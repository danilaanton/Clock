$version 11.00

$rect <-118,40,82,80>
$output false
class Base : Core::Group
{
  $rect <670,70,870,110>
  inherited method Init()
  {
    Bounds.size = $ScreenSize;
    Image.Bounds.size=$ScreenSize;
    Rectangle.Bounds.size=$ScreenSize;
    this.PresentDialog( new Clock::ClockScreen, null, null, null, null, null, null, null, null, false );

  }

  $rect <670,110,870,150>
  inherited property Bounds = <0,0,300,200>;

  $rect <670,380,870,420>
  object Effects::RectEffect SlideDown
  {
    preset OnFinished = SlideDown.StopEffect;
    preset Bounces = 3;
    preset Oscillations = 3;
    preset Timing = Effects::Timing.FastIn_EaseOut;
    preset NoOfCycles = 1;
    preset CycleDuration = 500;
    preset Value2 = <0,0,640,522>;
    preset Value1 = <0,-482,640,40>;
    preset Outlet = ^RunningEvents.Bounds;
  }

  $rect <670,420,870,460>
  object Effects::RectEffect SlideUp
  {
    preset OnFinished = SlideUp.StopEffect;
    preset Bounces = 3;
    preset Oscillations = 3;
    preset Timing = Effects::Timing.FastIn_EaseOut;
    preset NoOfCycles = 1;
    preset CycleDuration = 500;
    preset Value2 = <0,-482,640,40>;
    preset Value1 = <0,0,640,522>;
    preset Outlet = ^RunningEvents.Bounds;
  }

  $rect <669,200,869,240>
  object Core::SystemEventHandler EventTriggeredHandler
  {
    preset OnEvent = onEvent;
    preset Event = Clock::Device.EventTriggered;
  }

  // This slot method is executed when the associated system event handler 'SystemEventHandler' \
  // receives an event.
  $rect <669,240,869,280>
  slot onEvent
  {
    var Clock::Alert alert=new Clock::Alert;
    var Clock::Event event=(Clock::Event)EventTriggeredHandler.Context;
    var string triggerTime=Clock::Time.Initialize( event.TriggerTime + event.Snooze).String;

    alert.Sender=event;
    alert.Icon=Clock::IconsMedium;

    switch(event.Type)
    {
      case Clock::EventType.Alarm: 
      {
        alert.Caption=string(triggerTime).remove( 0, triggerTime.length-8 );
        alert.IconFrame=2;
      }
      case Clock::EventType.Calendar:  
      {
        alert.Caption=string(triggerTime);
        alert.IconFrame=3;
      }
      default:;
    }

    alert.OnButton1=OnButton1;

    if(event.Snooze<1200)
    {
      alert.OnIgnored=OnButton2;
      alert.OnButton2=OnButton2;
    }
    else
    {
      alert.OnIgnored=OnButton1;
      alert.PushButton2.Enabled=false;
    }

    this.PresentDialog( alert, Effects::SlideDownCentered, null, null, null, null, null, null, null, false );

  }

  $rect <669,280,869,320>
  slot OnButton1
  {
    var Clock::Alert alert= (Clock::Alert)sender;

    if(Clock::Device.GetEvent( alert.Index )!=null) 
    {
      alert.Sender.Snooze=0;
      Clock::Device.UpdateEvent( alert.Index );
    }
    this.DismissDialog( (Clock::Alert)sender, null, null, null, null, null, false );
  }

  $rect <20,20,160,60>
  object Views::Image Image
  {
    preset Bounds = <0,0,640,520>;
    preset Alignment = Views::ImageAlignment[AlignHorzCenter, AlignVertCenter, StretchToFill];
    preset Bitmap = Clock::BackgroundImg;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,0,640,480>;
    preset Color = #27608074;
  }

  $rect <20,20,160,60>
  object Clock::RunningEvents RunningEvents
  {
    preset Bounds = <0,-482,640,40>;
  }

  $rect <669,320,869,360>
  slot OnButton2
  {
    var Clock::Alert alert=(Clock::Alert)sender;
    var Clock::Event event=alert.Sender;

    event.Snooze+=alert.Int32Effect.Value+300;

    if(!event.IsScheduled) 
      Clock::Device.AddEvent( event );

    this.DismissDialog( alert, null, null, null, null, null, false );
  }

  // Alert Interactions
  note group Note
  {
    attr Bounds = <660,160,880,370>;
  }
}

$rect <-118,80,82,120>
$output false
class ClockScreen : Core::Group
{
  $rect <680,-10,880,30>
  inherited method Init()
  {
    postsignal UpdateTime;
  }

  $rect <680,50,880,90>
  inherited property Bounds = rect(0,0,$ScreenSize.x,$ScreenSize.y);

  $rect <20,20,160,60>
  object Clock::PlainClock PlainClock
  {
    preset Bounds = <-7,39,384,479>;
    preset Opacity = 255;
    preset Color = #255C7BFF;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle2
  {
    preset Bounds = <0,39,384,480>;
    preset ColorBL = #255C7BFF;
    preset ColorBR = #4FA8C3FF;
    preset ColorTR = #4FA8C3FF;
    preset ColorTL = #255C7BFF;
    preset Color = #FFFFFFB0;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Bounds = <0,39,640,80>;
    preset ColorBL = #0F1E3553;
    preset ColorBR = #0F1E3553;
    preset ColorTR = #0F1E35FF;
    preset ColorTL = #0F1E35FF;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle1
  {
    preset Bounds = <0,439,640,480>;
    preset ColorBL = #0F1E35FF;
    preset ColorBR = #0F1E35FF;
    preset ColorTR = #0F1E3553;
    preset ColorTL = #0F1E3553;
  }

  $rect <20,20,160,60>
  object Views::Image Image
  {
    preset Bounds = <295,430,345,480>;
    preset Color = #FAE9E0FF;
    preset Bitmap = Resources::NavigationIconsMedium;
  }

  $rect <20,20,160,60>
  object Views::Image Image1
  {
    preset Bounds = <295,39,345,89>;
    preset Orientation = Views::Orientation.Rotated_180;
    preset Color = #FAE9E0FF;
    preset Bitmap = Resources::NavigationIconsMedium;
  }

  $rect <20,20,160,60>
  object Views::Line Line
  {
    preset Point2 = <384,439>;
    preset Point1 = <384,80>;
    preset Width = 2;
    preset Color = #FAE9E0FF;
  }

  $rect <20,20,160,60>
  object Views::Line Line1
  {
    preset Point2 = <401,240>;
    preset Point1 = <614,240>;
    preset Width = 1;
    preset Color = #FAE9E0FF;
  }

  $rect <20,20,160,60>
  object Views::Text DayMonth
  {
    preset Bounds = <384,108,552,240>;
    preset WrapText = true;
    preset Alignment = Views::TextAlignment[AlignHorzCenter, AlignHorzJustified, AlignHorzRight, AlignVertCenter];
    preset String = "Mon, July 32";
    preset Font = Resources::FontLarge;
    preset Color = #FAE9E0FF;
  }

  $rect <20,20,160,60>
  object Views::Text Year
  {
    preset Bounds = <413,255,614,318>;
    preset WrapText = true;
    preset String = "Year";
    preset Font = Resources::FontExtraLarge;
    preset Color = #FAE9E0FF;
  }

  $rect <920,190,1120,230>
  slot UpdateTime
  {
    var Core::Time currentTime =  Clock::Time.CurrentTime;

    Second.String=string(currentTime.Second,2);
    Minute.String=string(currentTime.Minute,2);
    Hour.String=string(currentTime.Hour,2);
    DayMonth.String=currentTime.getDayOfWeekName( currentTime.DayOfWeek, false ) + "\n" + currentTime.getMonthName( currentTime.Month, false ) + " " + string(currentTime.Day, 2);
    Year.String = string(currentTime.Year);

    PlainClock.Second=currentTime.Second;
    PlainClock.Hour=currentTime.Hour;
    PlainClock.Minute=currentTime.Minute;

    if(currentTime.Hour>6 && currentTime.Hour<18) 
      Image2.FrameNumber=20;
    else 
      Image2.FrameNumber=21;
  }

  $rect <20,20,160,60>
  object Views::Text Hour
  {
    preset Bounds = <14,108,154,403>;
    preset String = "00";
    preset Font = Clock::ExtraLargeFont;
    preset Color = #FAE9E0FF;
  }

  $rect <20,20,160,60>
  object Views::Text Second
  {
    preset Bounds = <295,108,384,403>;
    preset String = "00";
    preset Font = Clock::LargeFont;
    preset Color = #FAE9E0FF;
  }

  $rect <20,20,160,60>
  object Views::Text Dot
  {
    preset Bounds = <154,107,172,402>;
    preset String = "05:30";
    preset Font = Clock::ExtraLargeFont;
    preset Color = #FAE9E0FF;
  }

  $rect <20,20,160,60>
  object Views::Text Minute
  {
    preset Bounds = <172,108,312,403>;
    preset String = "00";
    preset Font = Clock::ExtraLargeFont;
    preset Color = #FAE9E0FF;
  }

  $rect <680,150,880,190>
  slot WipeUpSlot
  {
    Owner.SwitchToDialog( new Clock::FunctionalitiesScreen, Effects::SlideUpCentered, null, null, null, null, null, null, null, null, false );
  }

  $rect <680,190,880,230>
  slot WipeDownSlot
  {
    var Clock::Base owner=(Clock::Base) Owner;
    owner.SlideDown.Enabled=true;
    owner.DismissDialog( this, Effects::SlideDownCentered, null, null, null, null, false );                    
  }

  $rect <920,149,1120,189>
  object Core::SystemEventHandler TimeChangedHandler
  {
    preset OnEvent = UpdateTime;
    preset Event = Clock::Device.TimeChanged;
  }

  $rect <20,20,160,60>
  object Views::Image Image2
  {
    preset Bounds = <552,130,640,218>;
    preset Color = #FAE9E0FF;
    preset Bitmap = Resources::SymbolIconsLarge;
  }

  $rect <20,20,160,60>
  object Views::Border Border
  {
    preset Bounds = <0,439,640,479>;
    preset Color = #0F1E358C;
  }

  $rect <20,20,160,60>
  object Views::Border Border1
  {
    preset Bounds = <0,0,640,80>;
    preset Color = #0F1E358C;
  }

  $rect <20,20,160,60>
  object Core::WipeTouchHandler WipeDown
  {
    preset Bounds = <0,0,640,108>;
    preset OnBottom = WipeDownSlot;
  }

  $rect <20,20,160,60>
  object Core::WipeTouchHandler WipeUp
  {
    preset Bounds = <0,403,640,479>;
    preset OnTop = WipeUpSlot;
  }

  // Touch Screen Events
  note group Note
  {
    attr Bounds = <670,110,890,240>;
  }

  // Time Display
  note group Note1
  {
    attr Bounds = <910,110,1130,240>;
  }
}

$rect <120,219,320,259>
$output false
resource Resources::Font ExtraLargeFont
{
  attr fontname FontName = Agency FB;
  attr fontheight Height = 150;
  attr fontheightmode HeightMode = Popular;
  attr fontquality Quality = High;
  attr fontranges Ranges = 0x20-0xFF;
  attr fontaspectratio AspectRatio = 1;
  attr fontbold Bold = true;
  attr fontitalic Italic = false;
  attr fontkerning Kerning = true;
  attr fontrowdistance RowDistance;
}

$rect <120,78,320,118>
inline Inline
{
  /*

    TO DO:

    Include external header files or add type and function declarations needed
    in the implementation of Clock::DeviceClass. For example:

      #include "DeviceDriver.h"

      #include "your_middleware_api.h"

      void Your_Middleware_Some_Function( int aSomeArg );

  */
}

$rect <120,38,320,78>
$output false
class DeviceClass : Templates::DeviceClass
{
  $rect <30,80,230,120>
  inherited method Done()
  {
    // The following section is intended to perform de-initialization-related operations
    // in the underlying device or middleware. Consequently, the section is taken in
    // account only when generating code (not during prototyping).
    $if !$prototyper
      var object thisObject = this;

      /*
         TO DO:

         The following native statement is intended to enclose code to communicate with
         your device API. The variable 'thisObject' contains a pointer to the actually
         de-initialized Clock::DeviceClass object. Use the 'thisObject' pointer to
         e.g. de-register the object from the middleware if you have registered it
         beforehand.
         
      */

      native ( thisObject )
      {
        /*
           TO DO:

           Depending on your application case you call functions of the underlying
           middleware (or access the device directly) in order to perform the necessary
           de-initialization steps. For example, you invoke some 'C' function:

             YourDevice_DeInitialize();

           IMPORTANT:
           ----------

           The variable 'thisObject' represents the actually de-initialized instance of the
           Clock::DeviceClass. If you have stored this object at the initialization
           time (in the 'Init' method) in some global C variable or registered it by the
           middleware, it is important to perform now the opposite operation. Set the
           global variable to NULL or de-register 'thisObject' object from the middleware.
           
        */
      }
    $endif
  }

  $rect <30,40,230,80>
  inherited method Init()
  {
    // The following section is intended to perform initialization-related operations
    // in the underlying device or middleware. Consequently, the section is taken in
    // account only when generating code (not during prototyping).
    $if !$prototyper
      var object thisObject = this;

      /*
         TO DO:

         The following native statement is intended to enclose code to communicate with
         your device API. The variable 'thisObject' contains a pointer to the actually
         initialized Clock::DeviceClass object. Use the 'thisObject' pointer to
         e.g. register the object by the middleware as receiver of events, etc.
         
      */

      native ( thisObject )
      {
        /*
           TO DO:

           Depending on your application case you call functions of the underlying
           middleware (or access the device directly) in order to perform the necessary
           initialization steps. For example, you invoke some 'C' function:

             YourDevice_Initialize();

           The variable 'thisObject' represents the actually initialized instance of the
           Clock::DeviceClass. You can store this variable e.g. in the middleware
           and use it whenever the middleware needs to notify the GUI application about
           some state alternation or events. In this manner, the middleware will be able
           to invoke methods of the interface device object.

           For example, you can store 'thisObject' in some global C variable:

             // Declaration of the global C variable
             XObject theDeviceObject;

             // Store the instance in the global variable
             theDeviceObject = thisObject;

           Later use the global variable e.g. to provide the GUI application with events:

             ApplicationDeviceClass__TriggerSomeEvent( theDeviceObject );

           IMPORTANT:
           ----------

           If you store 'thisObject' for later use, don't forget to implement the opposite
           operation in the method 'Done'. Concrete, 'Done' should set the global variable
           again to the value NULL.

        */
      }
    $endif
  }

  // Constructor and Destructor
  note group Note1
  {
    attr Bounds = <10,0,250,140>;
  }

  $rect <729,239,929,279>
  object Core::Timer Timer
  {
    preset OnTrigger = TimeProgress;
    preset Period = 1000;
    preset Enabled = true;
  }

  $rect <729,199,929,239>
  slot TimeProgress
  {
    TimeChanged.Trigger( null, null );

    var int32 index;
    var int64 currentTime=Clock::Time.CurrentTime.Time;

    for(index=0;index<GetEventsCount();)
    {
      var Clock::Event event=GetEvent(index);

      if(event.IsTriggered( currentTime )){
          EventTriggered.Trigger( event, null ); 

          if(event.IsExpired( currentTime )){
                RemoveEvent(index);
                continue;
              }
         }
      index++;
    }
  }

  $rect <729,279,929,319>
  object Core::SystemEvent TimeChanged;

  $rect <480,239,680,279>
  object Core::SystemEvent EventChanged;

  $rect <230,199,430,239>
  method int32 GetEventsCount()
  {
    /* The template just returns the given argument... */
    return 0;
  }

  $rect <230,239,430,279>
  method Clock::Event GetEvent( arg int32 index )
  {
    /* The template just returns the given argument... */
    index;
    return null;
  }

  $rect <30,199,230,239>
  method bool AddEvent( arg Clock::Event event )
  {
    // ToDo
    event;
    return true;
  }

  $rect <30,239,230,279>
  method bool RemoveEvent( arg int32 index )
  {
    // ToDo
    index;
    return true;
  }

  $rect <480,199,680,239>
  object Core::SystemEvent EventTriggered;

  $rect <30,279,230,319>
  method bool UpdateEvent( arg int32 index )
  {
    // ToDo
    index;
    return true;
  }

  // Event Access and Modification
  note group Note2
  {
    attr Bounds = <10,160,450,330>;
  }

  // Time Update
  note group Note3
  {
    attr Bounds = <710,160,950,330>;
  }

  // Event Triggers
  note group Note4
  {
    attr Bounds = <460,160,700,290>;
  }
}

$rect <320,38,520,78>
autoobject Clock::DeviceClass Device;

$rect <120,259,320,299>
$output false
resource Resources::Font LargeFont
{
  attr fontname FontName = Agency FB;
  attr fontheight Height = 50;
  attr fontheightmode HeightMode = Popular;
  attr fontquality Quality = High;
  attr fontranges Ranges = 0x20-0xFF;
  attr fontaspectratio AspectRatio = 1;
  attr fontbold Bold = true;
  attr fontitalic Italic = false;
  attr fontkerning Kerning = true;
  attr fontrowdistance RowDistance;
}

$rect <-117,120,83,160>
$output false
class FunctionalitiesScreen : Core::Group
{
  $rect <890,210,1090,250>
  inherited method Init()
  {
    postsignal UpdateTime;
  }

  $rect <670,210,870,250>
  inherited property Bounds = rect(0,0,$ScreenSize.x,$ScreenSize.y);

  $rect <910,299,1110,339>
  slot WipeDownSlot
  {
    Owner.SwitchToDialog(new Clock::ClockScreen, Effects::SlideDownCentered, null, null, null, null, null, null, null, null, false );
  }

  $rect <1140,339,1340,379>
  slot UpdateTime
  {
    var Core::Time currentTime = Clock::Time.CurrentTime;
    Hour.String=string(currentTime.Hour/10)+string(currentTime.Hour%10)+":"+string(currentTime.Minute/10)+string(currentTime.Minute%10);
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Bounds = <0,39,640,480>;
    preset Color = #1D243858;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle1
  {
    preset Bounds = <0,439,640,480>;
    preset ColorBL = #FFFFFFFF;
    preset ColorBR = #FFFFFFFF;
    preset ColorTR = #FFFFFF53;
    preset ColorTL = #FFFFFF53;
    preset Color = #0F1E35FF;
  }

  $rect <20,20,160,60>
  object Views::Border Border
  {
    preset Bounds = <0,439,640,479>;
    preset Color = #0F1E358C;
  }

  $rect <20,20,160,60>
  object Core::WipeTouchHandler WipeDown
  {
    preset Bounds = <0,0,640,80>;
    preset OnBottom = WipeDownSlot;
    preset OnTop = null;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle3
  {
    preset Bounds = <0,39,640,80>;
    preset ColorBL = #FFFFFF53;
    preset ColorBR = #FFFFFF53;
    preset ColorTR = #FFFFFFFF;
    preset ColorTL = #FFFFFFFF;
    preset Color = #0F1E35FF;
  }

  $rect <20,20,160,60>
  object Views::Image Image
  {
    preset Bounds = <295,34,345,84>;
    preset Color = #FAE9E0FF;
    preset FrameNumber = 1;
    preset Bitmap = Resources::NavigationIconsMedium;
  }

  $rect <20,20,160,60>
  object Views::Text Hour
  {
    preset Bounds = <458,9,640,70>;
    preset String = "Text";
    preset Font = Clock::LargeFont;
    preset Color = #FAE9E0FF;
  }

  $rect <20,20,160,60>
  object Views::Text CronometerText
  {
    preset Bounds = <146,222,246,252>;
    preset String = "Chronometer";
    preset Font = Resources::FontSmall;
    preset Color = #FAE9E0FF;
  }

  $rect <20,20,160,60>
  object Views::Text CalendarText
  {
    preset Bounds = <394,222,494,252>;
    preset String = "Calendar";
    preset Font = Resources::FontSmall;
    preset Color = #FAE9E0FF;
  }

  $rect <20,20,160,60>
  object Views::Text TimerText
  {
    preset Bounds = <146,377,246,407>;
    preset String = "Timer";
    preset Font = Resources::FontSmall;
    preset Color = #FAE9E0FF;
  }

  $rect <20,20,160,60>
  object Views::Text AlarmText
  {
    preset Bounds = <394,377,494,407>;
    preset String = "Alarm";
    preset Font = Resources::FontSmall;
    preset Color = #FAE9E0FF;
  }

  $rect <680,299,880,339>
  slot OnTimerButton
  {
    Owner.SwitchToDialog(new Clock::TimerScreen, Effects::FadeInOutCentered, null, null, null, null, null, null, null, null, false );
  }

  $rect <680,339,880,379>
  slot OnChronButton
  {
    Owner.SwitchToDialog(new Clock::ChronometerScreen, Effects::FadeInOutCentered, null, null, null, null, null, null, null, null, false );
  }

  $rect <680,379,880,419>
  slot OnAlarmButton
  {
    Owner.SwitchToDialog(new Clock::AlarmScreen, Effects::FadeInOutCentered, null, null, null, null, null, null, null, null, false );
  }

  $rect <680,419,880,459>
  slot OnCalButton
  {
    Owner.SwitchToDialog(new Clock::CalendarScreen, Effects::FadeInOutCentered, null, null, null, null, null, null, null, null, false );
  }

  $rect <1140,299,1340,339>
  object Core::SystemEventHandler TimeChangedHandler
  {
    preset OnEvent = UpdateTime;
    preset Event = Clock::Device.TimeChanged;
  }

  $rect <20,20,160,60>
  object Clock::FunctionalitiesButton ChronometerButton
  {
    preset Bounds = <146,125,246,225>;
    preset OnPress = OnChronButton;
    preset Bitmap = Clock::IconsMedium;
    preset IconColor = #0F1E35FF;
    preset Color = #D2D5DBFF;
    preset ShadowColor = #B5C5D3FF;
  }

  $rect <20,20,160,60>
  object Clock::FunctionalitiesButton CalendarButton
  {
    preset Bounds = <394,125,494,225>;
    preset OnPress = OnCalButton;
    preset FrameNumber = 3;
    preset Bitmap = Clock::IconsMedium;
    preset IconColor = #0F1E35FF;
    preset Color = #D2D5DBFF;
    preset ShadowColor = #B5C5D3FF;
  }

  $rect <20,20,160,60>
  object Clock::FunctionalitiesButton TimerButton
  {
    preset Bounds = <146,277,246,377>;
    preset OnPress = OnTimerButton;
    preset FrameNumber = 1;
    preset Bitmap = Clock::IconsMedium;
    preset IconColor = #0F1E35FF;
    preset Color = #D2D5DBFF;
    preset ShadowColor = #B5C5D3FF;
  }

  $rect <20,20,160,60>
  object Clock::FunctionalitiesButton AlarmButton
  {
    preset Bounds = <394,277,494,377>;
    preset OnPress = OnAlarmButton;
    preset FrameNumber = 2;
    preset Bitmap = Clock::IconsMedium;
    preset IconColor = #0F1E35FF;
    preset Color = #D2D5DBFF;
    preset ShadowColor = #B5C5D3FF;
  }

  $rect <20,20,160,60>
  object Views::Border Border1
  {
    preset Bounds = <0,0,640,80>;
    preset Color = #0F1E358C;
  }

  $rect <20,20,160,60>
  object Views::Text CalendarText1
  {
    preset Bounds = <394,222,494,252>;
    preset String = "Calendar";
    preset Font = Resources::FontSmall;
    preset Color = #FAE9E0FF;
  }

  // Button Press Event
  note group Note
  {
    attr Bounds = <670,259,890,469>;
  }

  // Touch Handler Events
  note group Note1
  {
    attr Bounds = <900,259,1120,349>;
  }

  // Time Display
  note group Note2
  {
    attr Bounds = <1130,259,1350,389>;
  }
}

// This class implements a 'rotary knob' widget. The user can touch the knob and \
// rotate it causing the widget's value to be changed accordingly. The current value \
// of the widget is represented by the property @CurrentValue. The valid range for \
// this value is determined by the properties @MinValue and @MaxValue.
// While the user is dragging the knob, the widget sends signals to the slot method \
// stored in the property @OnChange. When the user terminates the interaction, a \
// signal is sent to the slot method stored in @OnApply.
// Alternatively the property @Outlet can refer to any other 'int32' property the \
// widget should remain synchronized with. When the user drags the knob, the affected \
// property is automatically updated to reflect the widget's current value. On the \
// other hand, when the referred property is modified by another one, the widget \
// is automatically notified to remain in sync with the property.
// This approach follows the Model-View-Controller (MVC) programming paradigm. Here \
// the rotary knob represents the 'View' and 'Controller' and the property referred \
// via 'Outlet' can be seen as a part of the 'Model'.
$rect <-130,640,70,680>
$output false
class PlainClock : Core::Group
{
  $rect <440,-10,590,30>
  inherited method Init()
  {
    ClockPath2.SetMaxNoOfSubPaths( 4 );
    SecondPath.SetMaxNoOfSubPaths( 1 );
    MinutePath.SetMaxNoOfSubPaths( 1 );
    HourPath.SetMaxNoOfSubPaths( 1 );
  }

  $rect <640,-10,840,30>
  inherited property Bounds = <0,0,400,400>;

  $rect <640,30,840,70>
  inherited method UpdateLayout()
  {
    ClockPath1.Radius=aSize.x<aSize.y?aSize.x/7*3:aSize.y/7*3;

    ClockCircle.Offset=point(aSize.x/2,aSize.y/2);
    SecondLine.Offset=point(aSize.x/2,aSize.y/2);
    MinuteLine.Offset=point(aSize.x/2,aSize.y/2);
    HourLine.Offset=point(aSize.x/2,aSize.y/2);

    DrawClock();
    DrawSecond();
    DrawMinute();
    DrawHour();
  }

  $rect <441,360,641,400>
  object Graphics::ArcPath ClockPath1
  {
    preset NoOfEdges = 0;
    preset EndAngle = 360;
    preset InnerRadius = 0;
    preset RadiusX = 0.0;
    preset Radius = 170;
    preset Style = Graphics::ArcStyle.Arc;
  }

  $rect <20,20,160,60>
  object Views::StrokePath ClockCircle
  {
    preset Bounds = <0,0,400,400>;
    preset Offset = <200,200>;
    preset Width = 15.0;
    preset Path = ClockPath1;
  }

  $rect <440,99,640,139>
  property int32 Hour;

  $rect <640,99,840,139>
  onset Hour
  {
    // The value doesn't change - nothing to do.
    if ( pure Hour == value )
      return;

    // Remember the property's new value.
    pure Hour = value;

    DrawHour();
  }

  $rect <440,139,640,179>
  property int32 Minute;

  $rect <640,139,840,179>
  onset Minute
  {
    // The value doesn't change - nothing to do.
    if ( pure Minute == value )
      return;

    // Remember the property's new value.
    pure Minute = value;

    DrawMinute();
    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <440,179,640,219>
  property int32 Second;

  $rect <640,179,840,219>
  onset Second
  {
    // The value doesn't change - nothing to do.
    if ( pure Second == value )
      return;

    // Remember the property's new value.
    pure Second = value;

    DrawSecond();
  }

  $rect <440,219,640,259>
  property color Color = #FFFFFFFF;

  $rect <640,219,840,259>
  onset Color
  {
    // The value doesn't change - nothing to do.
    if ( pure Color == value )
      return;

    // Remember the property's new value.
    pure Color = value;

    UpdateColor();
  }

  $rect <441,440,641,480>
  object Graphics::Path SecondPath;

  $rect <20,20,160,60>
  object Views::StrokePath SecondLine
  {
    preset Bounds = <0,0,400,400>;
    preset Offset = <200,200>;
    preset JoinPoints = Graphics::PathJoin.Bevel;
    preset EndCap = Graphics::PathCap.Round;
    preset StartCap = Graphics::PathCap.Round;
    preset Width = 3;
    preset Path = SecondPath;
  }

  $rect <441,480,641,520>
  object Graphics::Path MinutePath;

  $rect <441,520,641,560>
  object Graphics::Path HourPath;

  $rect <20,20,160,60>
  object Views::StrokePath HourLine
  {
    preset Bounds = <0,0,400,400>;
    preset Offset = <200,200>;
    preset EndCap = Graphics::PathCap.Round;
    preset StartCap = Graphics::PathCap.Round;
    preset Width = 8;
    preset Path = HourPath;
  }

  $rect <20,20,160,60>
  object Views::StrokePath MinuteLine
  {
    preset Bounds = <0,0,400,400>;
    preset Offset = <200,200>;
    preset JoinPoints = Graphics::PathJoin.Bevel;
    preset EndCap = Graphics::PathCap.Round;
    preset StartCap = Graphics::PathCap.Round;
    preset Width = 5;
    preset Path = MinutePath;
  }

  $rect <440,400,640,440>
  object Graphics::Path ClockPath2;

  $rect <20,20,160,60>
  object Views::StrokePath ClockLines
  {
    preset Bounds = <0,0,400,400>;
    preset Width = 8;
    preset Path = ClockPath2;
  }

  $rect <649,398,849,438>
  method void DrawClock()
  {
    ClockPath2.InitSubPath( 0, 1 );
    ClockPath2.InitSubPath( 1, 1 );
    ClockPath2.InitSubPath( 2, 1 );
    ClockPath2.InitSubPath( 3, 1 );

    ClockPath2.Begin( 0, Bounds.w/2, Bounds.h/2-ClockPath1.Radius );
    ClockPath2.Begin( 1, Bounds.w/2, Bounds.h/2+ClockPath1.Radius );
    ClockPath2.Begin( 2, Bounds.w/2 -ClockPath1.Radius, Bounds.h/2 );
    ClockPath2.Begin( 3, Bounds.w/2 +ClockPath1.Radius, Bounds.h/2 );

    ClockPath2.AddLine( 0, Bounds.w/2, Bounds.h/2-ClockPath1.Radius/8*7 );
    ClockPath2.AddLine( 1, Bounds.w/2, Bounds.h/2+ClockPath1.Radius/8*7 );
    ClockPath2.AddLine( 2, Bounds.w/2 -ClockPath1.Radius/8*7, Bounds.h/2 );
    ClockPath2.AddLine( 3, Bounds.w/2 +ClockPath1.Radius/8*7, Bounds.h/2 );

    ClockPath2.Close( 0 );
    ClockPath2.Close( 1 );
    ClockPath2.Close( 2 );
    ClockPath2.Close( 3 );
  }

  $rect <650,360,850,400>
  method void UpdateColor()
  {
    SecondLine.Color=Color;
    MinuteLine.Color=Color;
    HourLine.Color=Color;

    ClockLines.Color=Color;
    ClockCircle.Color=Color;
  }

  $rect <649,438,849,478>
  method void DrawSecond()
  {
    SecondPath.InitSubPath( 0, 1 );
    SecondPath.InitMatrix();

    SecondPath.Rotate( Second*6 );
    SecondPath.Begin( 0, 0, 0 );
    SecondPath.AddLine( 0, 0, 0-ClockPath1.Radius/7*6 );

    SecondPath.Close( 0 );
  }

  $rect <649,478,849,518>
  method void DrawHour()
  {
    HourPath.InitSubPath( 0, 1 );
    HourPath.InitMatrix();

    HourPath.Rotate( Hour*15 );
    HourPath.Begin( 0, 0, 0 );
    HourPath.AddLine( 0, 0, 0-ClockPath1.Radius/7*2 );

    HourPath.Close( 0 );
  }

  $rect <649,519,849,559>
  method void DrawMinute()
  {
    MinutePath.InitSubPath( 0, 1 );
    MinutePath.InitMatrix();

    MinutePath.Rotate( Minute*6 );
    MinutePath.Begin( 0, 0, 0 );
    MinutePath.AddLine( 0, 0, 0-ClockPath1.Radius/7*4 );

    MinutePath.Close( 0 );
  }

  // Path Aspect and Drawing
  note group Note
  {
    attr Bounds = <430,320,860,570>;
  }
}

// This class implements a 'rotary knob' widget. The user can touch the knob and \
// rotate it causing the widget's value to be changed accordingly. The current value \
// of the widget is represented by the property @CurrentValue. The valid range for \
// this value is determined by the properties @MinValue and @MaxValue.
// While the user is dragging the knob, the widget sends signals to the slot method \
// stored in the property @OnChange. When the user terminates the interaction, a \
// signal is sent to the slot method stored in @OnApply.
// Alternatively the property @Outlet can refer to any other 'int32' property the \
// widget should remain synchronized with. When the user drags the knob, the affected \
// property is automatically updated to reflect the widget's current value. On the \
// other hand, when the referred property is modified by another one, the widget \
// is automatically notified to remain in sync with the property.
// This approach follows the Model-View-Controller (MVC) programming paradigm. Here \
// the rotary knob represents the 'View' and 'Controller' and the property referred \
// via 'Outlet' can be seen as a part of the 'Model'.
$rect <-130,680,70,720>
$output false
class TimerClock : Core::Group
{
  $rect <440,-10,590,30>
  inherited method Init()
  {
  }

  $rect <440,50,640,90>
  inherited property Bounds = <0,0,379,379>;

  $rect <439,480,639,520>
  object Graphics::ArcPath ArcPath
  {
    preset NoOfEdges = 0;
    preset EndAngle = 360;
    preset InnerRadius = 0;
    preset RadiusX = 0.0;
    preset Radius = 130;
    preset Style = Graphics::ArcStyle.Arc;
  }

  $rect <20,20,160,60>
  object Views::StrokePath StrokePath
  {
    preset Bounds = <0,0,380,380>;
    preset Color = #FAE9E088;
    preset Offset = <190,190>;
    preset Width = 8;
    preset Path = ArcPath;
  }

  $rect <20,20,160,60>
  object Views::StrokePath TimePassing
  {
    preset Bounds = <0,0,380,380>;
    preset ColorBL = #4B3FFFFF;
    preset ColorBR = #41F5FFFF;
    preset ColorTR = #19FF72FF;
    preset ColorTL = #FF43F8FF;
    preset Color = #FAE9E0FF;
    preset Offset = <190,190>;
    preset EndCap = Graphics::PathCap.Round;
    preset Width = 8;
    preset Path = TimerPath;
  }

  $rect <438,440,638,480>
  object Graphics::ArcPath TimerPath
  {
    preset NoOfEdges = 0;
    preset EndAngle = 270;
    preset StartAngle = 270;
    preset InnerRadius = 0;
    preset RadiusX = 0.0;
    preset Radius = 130;
    preset Style = Graphics::ArcStyle.Arc;
  }

  $rect <680,290,880,330>
  slot UpdateSeconds
  {
    var int32 hour = TimePicker.Hour;
    var int32 minute = TimePicker.Minute;
    var int32 second = TimePicker.Second;

    Seconds=hour*3600+minute*60+second;

    if(Seconds>0) 
    {
      postsignal OnValidEntry;
      FloatEffect.CycleDuration=Seconds*1000;
      FloatEffect.Value2=360.0;
      FloatEffect.Value1=0.0;
    }
  }

  $rect <20,20,160,60>
  object Clock::TimePicker TimePicker
  {
    preset Bounds = <66,92,314,289>;
    preset OnTimeChanged = UpdateSeconds;
    preset OnAnimationEnded = OnAnimationEnded;
  }

  $rect <920,370,1120,410>
  method void ResetTime()
  {
    FloatEffect.Enabled=false;

    TimePicker.SetTime( 0 );
    TimePicker.Enabled=true;

    TimerPath.EndAngle=270;

    postsignal OnFinishedTiming;
  }

  $rect <920,330,1120,370>
  method void Start()
  {
    TimePicker.Enabled=false;
    FloatEffect.Enabled=true;
  }

  $rect <920,290,1120,330>
  method void Stop()
  {
    FloatEffect.Enabled=false;
  }

  $rect <650,149,850,189>
  property slot OnFinishedTiming;

  $rect <440,109,640,149>
  property int32 Seconds;

  $rect <440,149,640,189>
  onset Seconds
  {
    // The value doesn't change - nothing to do.
    if ( pure Seconds == value )
      return;

    // Remember the property's new value.
    pure Seconds = value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <440,189,640,229>
  onget Seconds
  {
    return pure Seconds;
  }

  $rect <650,109,850,149>
  property slot OnValidEntry;

  $rect <450,370,650,410>
  slot OnEndEffect
  {
    postsignal OnFinishedTiming;

    TimePicker.SetTime( 0 );
    TimePicker.ColorEffect.Enabled=true;
  }

  $rect <450,330,650,370>
  slot OnAnimateEffect
  {
    TimerPath.EndAngle=TimerPath.StartAngle+uint32(FloatEffect.Value);

    if(Seconds==0) return;

    TimePicker.SetTime( Seconds-int32(FloatEffect.Value/(360.0/float(Seconds))));
  }

  $rect <450,290,650,330>
  object Effects::FloatEffect FloatEffect
  {
    preset OnFinished = OnEndEffect;
    preset OnAnimate = OnAnimateEffect;
    preset NoOfCycles = 1;
    preset Value2 = 360.0;
  }

  $rect <680,330,880,370>
  slot OnAnimationEnded
  {
    ResetTime();
  }

  // Countdown Animation
  note group Note
  {
    attr Bounds = <440,250,659,419>;
  }

  // Time Picker Changes
  note group Note1
  {
    attr Bounds = <670,251,890,379>;
  }

  // Countdown Controls
  note group Note2
  {
    attr Bounds = <899,250,1139,419>;
  }
}

$rect <120,299,320,339>
$output false
resource Resources::Font MediumFont
{
  attr fontname FontName = Agency FB;
  attr fontheight Height = 80;
  attr fontheightmode HeightMode = Popular;
  attr fontquality Quality = High;
  attr fontranges Ranges = 0x20-0xFF;
  attr fontaspectratio AspectRatio = 1;
  attr fontbold Bold = true;
  attr fontitalic Italic = false;
  attr fontkerning Kerning = true;
  attr fontrowdistance RowDistance;
}

// This is a GUI component.
$rect <-130,720,70,760>
$output false
class TimePicker : Templates::PickerControl
{
  $rect <280,-10,480,30>
  inherited property Bounds = <0,0,248,197>;

  $rect <490,-10,690,30>
  inherited method UpdateViewState()
  {
    super( aState );

    var bool isEnabled  = aState.contains( Core::ViewState[ Enabled  ]);

    if(isEnabled)
    {
      TouchHandlerHour.Enabled=true;
      TouchHandlerMinute.Enabled=true;
      TouchHandlerSecond.Enabled=true;
    }
    else
    {
      TouchHandlerHour.Enabled=false;
      TouchHandlerMinute.Enabled=false;
      TouchHandlerSecond.Enabled=false;
    }


  }

  // Touch screen events
  note group Note2
  {
    attr Bounds = <510,319,730,579>;
  }

  // List Management
  note group Note1
  {
    attr Bounds = <280,319,500,489>;
  }

  // This method is called when one of the Slide Touch Handler (TouchHandlerHour, \
  // TouchHandlerMinute or TouchHandlerSecond) has finished the slide animation. \
  // Thereupon the owner of the time picker is notified, that the time has been changed.
  $rect <520,399,720,439>
  slot OnEndSlide
  {
    // The user has finished the interaction with the time picker. Request the
    // UpdateViewState() method to be called in order to eventually refresh
    // the time picker appearance.
    InvalidateViewState();

    // Notify the owner of the time picker, that the user has selected another time.
    // Do this however only after the last list has finished the slide animation.
    if ( !TouchHandlerHour.Sliding && !TouchHandlerMinute.Sliding && !TouchHandlerSecond.Sliding )
      postsignal OnTimeChanged;
  }

  // This method is called when one of the Slide Touch Handler (TouchHandlerHour, \
  // TouchHandlerMinute or TouchHandlerSecond) has begun the slide animation.
  $rect <520,359,720,399>
  slot OnStartSlide
  {
    // The user has begun an interaction with the time picker. Request the
    // UpdateViewState() method to be called in order to eventually refresh
    // the time picker appearance.
    InvalidateViewState();
  }

  // This method is called by 'ListSecond' vertical list every time the list loads \
  // or updates an item.
  $rect <290,439,490,479>
  slot OnLoadSecondItem
  {
    // Get the number of the item to load. The list component takes care of the
    // creation of the corresponding item view. Just access it ...
    var int32       itemNo   = ListSecond.Item;
    var Views::Text itemView = (Views::Text)ListSecond.View;

    // The implementation of this slot method does not match the item class
    // specified in the associated list component. Or the slot method is not
    // called in context of the OnLoadItem list operation.
    if ( itemView == null )
      return;

    var int32 itemCenter = ListSecond.GetItemAtPosition( SecondCenter );
    itemView.String    = string( itemNo, 2 );
    itemView.Font      = ( itemCenter == itemNo )?  Clock::LargeFont : Clock::SmallFont;
    itemView.Color     = ( itemCenter == itemNo )? TimeColor : #FAE9E080;
    itemView.Alignment = Views::TextAlignment[ AlignHorzCenter, AlignVertCenter ];
    itemView.ScrollOffset = <0,-2>;                  
    // Ensure that the item has correct size. The position of the item will be
    // managed by the list component.
    itemView.Bounds.size = point( ListSecond.Bounds.w, ListSecond.ItemHeight );
  }

  // This method is called by 'ListMinute' vertical list every time the list loads \
  // or updates an item.
  $rect <290,399,490,439>
  slot OnLoadMinuteItem
  {
    // Get the number of the item to load. The list component takes care of the
    // creation of the corresponding item view. Just access it ...
    var int32       itemNo   = ListMinute.Item;
    var Views::Text itemView = (Views::Text)ListMinute.View;

    // The implementation of this slot method does not match the item class
    // specified in the associated list component. Or the slot method is not
    // called in context of the OnLoadItem list operation.
    if ( itemView == null )
      return;

    var int32 itemCenter = ListMinute.GetItemAtPosition( MinuteCenter );
    itemView.String    = string( itemNo, 2 );
    itemView.Font      = ( itemCenter == itemNo )?  Clock::LargeFont : Clock::SmallFont;
    itemView.Color     = ( itemCenter == itemNo )? TimeColor : #FAE9E080;
    itemView.Alignment = Views::TextAlignment[ AlignHorzCenter, AlignVertCenter ];
    itemView.ScrollOffset = <0,-2>;                  
    // Ensure that the item has correct size. The position of the item will be
    // managed by the list component.
    itemView.Bounds.size = point( ListMinute.Bounds.w, ListMinute.ItemHeight );
  }

  // This method is called by 'ListHour' vertical list every time the list loads \
  // or updates an item.
  $rect <290,359,490,399>
  slot OnLoadHourItem
  {
    // Get the number of the item to load. The list component takes care of the
    // creation of the corresponding item view. Just access it ...
    var int32       itemNo   = ListHour.Item;
    var Views::Text itemView = (Views::Text)ListHour.View;

    // The implementation of this slot method does not match the item class
    // specified in the associated list component. Or the slot method is not
    // called in context of the OnLoadItem list operation.
    if ( itemView == null )
      return;

    var int32 itemCenter = ListHour.GetItemAtPosition( HourCenter );
    // Configure the item view ...     
    itemView.String    = string( itemNo ,2);
    itemView.Font      = ( itemCenter == itemNo )?  Clock::LargeFont : Clock::SmallFont;
    itemView.Color     = ( itemCenter == itemNo )? TimeColor : #FAE9E080;
    itemView.Alignment = Views::TextAlignment[ AlignHorzCenter, AlignVertCenter ]; 
    itemView.ScrollOffset = <0,-2>;
                     
    // Ensure that the item has correct size. The position of the item will be
    // managed by the list component.
    itemView.Bounds.size = point( ListHour.Bounds.w, ListHour.ItemHeight );
  }

  $rect <701,131,900,171>
  onget Second
  {
    // From the actual scroll offset calculate the number of the corresponding
    // list item. Note, the list displays the actually selected time at the
    // third position (index 2).
    return (( -ListSecond.ScrollOffset / ListSecond.ItemHeight ) + 1 ) % 60;
  }

  $rect <700,91,901,131>
  onset Second
  {
    // Limit the assigned value to the valid range 0 .. 59
    if ( value < 0  ) value = 0;
    if ( value > 59 ) value = 59;

    // Adjust the scroll position of the corresponding list. Note, the
    // list displays the actually selected time scrolled by two items.
    // Take this displacement in account.
    ListSecond.ScrollOffset = ( value - 1 ) * -ListSecond.ItemHeight;

    ListSecond.InvalidateItems( 0, ListSecond.NoOfItems );
  }

  $rect <490,131,690,171>
  onget Minute
  {
    // From the actual scroll offset calculate the number of the corresponding
    // list item. Note, the list displays the actually selected time at the
    // third position (index 2).
    return (( -ListMinute.ScrollOffset / ListMinute.ItemHeight ) + 1 ) % 60;
  }

  $rect <490,91,690,131>
  onset Minute
  {
    // Limit the assigned value to the valid range 0 .. 59
    if ( value < 0  ) value = 0;
    if ( value > 59 ) value = 59;

    // Adjust the scroll position of the corresponding list. Note, the
    // list displays the actually selected time scrolled by two items.
    // Take this displacement in account.
    ListMinute.ScrollOffset = ( value - 1 ) * -ListMinute.ItemHeight;

    ListMinute.InvalidateItems( 0, ListMinute.NoOfItems );
  }

  $rect <280,131,480,171>
  onget Hour
  {
    // From the actual scroll offset calculate the number of the corresponding
    // list item. Note, the list displays the actually selected time at the
    // third position (index 2).
    return (( -ListHour.ScrollOffset / ListHour.ItemHeight ) +1) % 24;
  }

  $rect <280,91,480,131>
  onset Hour
  {
    // Limit the assigned value to the valid range 0 .. 23
    if ( value < 0  ) value = 0;
    if ( value > 23 ) value = 23;
    // Adjust the scroll position of the corresponding list. Note, the
    // list displays the actually selected time scrolled by two items.
    // Take this displacement in account.
    ListHour.ScrollOffset = ( value - 1 ) * -ListHour.ItemHeight;

    ListHour.InvalidateItems( 0, ListHour.NoOfItems );
  }

  $rect <20,20,160,60>
  object Views::Border BorderCurrent
  {
    preset Bounds = <19,68,230,124>;
    preset Width = 5;
    preset Color = #FAE9E0FF;
    preset Visible = true;
  }

  $rect <20,20,160,60>
  object Core::SlideTouchHandler TouchHandlerSecond
  {
    preset Bounds = <169,8,230,187>;
    preset OnSlide = OnSlideSecond;
    preset OnEnd = OnEndSlide;
    preset OnStart = OnStartSlide;
    preset SnapNext = <0,60>;
    preset Friction = 0.2;
  }

  $rect <20,20,160,60>
  object Core::SlideTouchHandler TouchHandlerMinute
  {
    preset Bounds = <94,7,155,186>;
    preset OnSlide = OnSlideMinute;
    preset OnEnd = OnEndSlide;
    preset OnStart = OnStartSlide;
    preset SnapNext = <0,60>;
    preset Friction = 0.2;
  }

  $rect <20,20,160,60>
  object Core::SlideTouchHandler TouchHandlerHour
  {
    preset Bounds = <19,6,80,186>;
    preset OnSlide = OnSlideHour;
    preset OnEnd = OnEndSlide;
    preset OnStart = OnStartSlide;
    preset SnapNext = <0,60>;
    preset Friction = 0.2;
  }

  $rect <20,20,160,60>
  object Core::VerticalList ListSecond
  {
    preset Bounds = <169,7,230,187>;
    preset Enabled = true;
    preset OnLoadItem = OnLoadSecondItem;
    preset Endless = true;
    preset SlideHandler = TouchHandlerSecond;
    preset ScrollOffset = 60;
    preset SelectedItem = -1;
    preset ItemHeight = 60;
    preset NoOfItems = 60;
  }

  $rect <20,20,160,60>
  object Core::VerticalList ListMinute
  {
    preset Bounds = <94,7,155,187>;
    preset Enabled = true;
    preset OnLoadItem = OnLoadMinuteItem;
    preset Endless = true;
    preset SlideHandler = TouchHandlerMinute;
    preset ScrollOffset = 60;
    preset ItemHeight = 60;
    preset NoOfItems = 60;
  }

  $rect <20,20,160,60>
  object Core::VerticalList ListHour
  {
    preset Bounds = <19,7,80,188>;
    preset Enabled = true;
    preset OnLoadItem = OnLoadHourItem;
    preset Endless = true;
    preset SlideHandler = TouchHandlerHour;
    preset ScrollOffset = 60;
    preset SelectedItem = 2;
    preset ItemHeight = 60;
    preset NoOfItems = 24;
  }

  $rect <20,20,160,60>
  object Views::Text Separator1
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToTop];
    preset Bounds = <155,61,169,116>;
    preset String = ":";
    preset Font = Clock::LargeFont;
    preset Color = #FAE9E0FF;
  }

  $rect <20,20,160,60>
  object Views::Text Separator2
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToTop];
    preset Bounds = <80,61,94,116>;
    preset String = ":";
    preset Font = Clock::LargeFont;
    preset Color = #FAE9E0FF;
  }

  // The property 'OnChange' can refer to a slot method, which will receive a signal \
  // each time the user select another time. Thereupon the method's logic will be \
  // executed. In the associated slot method you can evaluate the time picker properties \
  // @Hour, @Minute and @Second.
  $rect <910,91,1110,131>
  property slot OnTimeChanged = null;

  // The property 'Second' stores the number of seconds after the minute. The value \
  // is valid in range 0 .. 59.
  $rect <700,51,900,91>
  property int32 Second = 0;

  // The property 'Minute' stores the number of minutes after the hour. The value \
  // is valid in range 0 .. 59.
  $rect <490,51,690,91>
  property int32 Minute = 0;

  // The property 'Hour' stores the number of hours since midnight. The value is \
  // valid in range 0 .. 23.
  $rect <280,51,480,91>
  property int32 Hour = 0;

  // This method is called when one of the Slide Touch Handler (TouchHandlerDay, \
  // TouchHandlerMonth or TouchHandlerYear) has finished the slide animation. Thereupon \
  // the owner of the date picker is notified, that the date has been changed.
  $rect <520,529,720,569>
  slot OnSlideSecond
  {
    ListSecond.InvalidateItems( 0, ListSecond.NoOfItems );
  }

  // This method is called when one of the Slide Touch Handler (TouchHandlerDay, \
  // TouchHandlerMonth or TouchHandlerYear) has finished the slide animation. Thereupon \
  // the owner of the date picker is notified, that the date has been changed.
  $rect <520,489,720,529>
  slot OnSlideMinute
  {
    ListMinute.InvalidateItems( 0, ListMinute.NoOfItems );
  }

  // This method is called when one of the Slide Touch Handler (TouchHandlerDay, \
  // TouchHandlerMonth or TouchHandlerYear) has finished the slide animation. Thereupon \
  // the owner of the date picker is notified, that the date has been changed.
  $rect <520,449,720,489>
  slot OnSlideHour
  {
    ListHour.InvalidateItems( 0, ListHour.NoOfItems );
  }

  $rect <490,190,690,230>
  var point HourCenter = <30,90>;

  $rect <490,229,690,269>
  var point MinuteCenter = <124,90>;

  $rect <490,270,690,310>
  var point SecondCenter = <199,90>;

  $rect <910,51,1110,91>
  method void SetTime( arg int64 value )
  {
    Second=int32(value%60);
    Minute=int32((value%3600)/60);
    Hour=int32((value%86400)/3600);

  }

  $rect <750,359,950,399>
  object Effects::ColorEffect ColorEffect
  {
    preset OnFinished = OnFinishedFlash;
    preset Symmetric = true;
    preset NoOfCycles = 2;
    preset Enabled = false;
    preset Value2 = #FF0000FF;
    preset Value1 = #FAE9E0FF;
    preset Outlet = ^TimeColor;
  }

  $rect <280,190,480,230>
  property color TimeColor = #FAE9E0FF;

  $rect <280,230,480,270>
  onset TimeColor
  {
    // The value doesn't change - nothing to do.
    if ( pure TimeColor == value )
      return;

    // Remember the property's new value.
    pure TimeColor = value;

    ListHour.InvalidateItems( 0, ListHour.NoOfItems );
    ListMinute.InvalidateItems( 0, ListMinute.NoOfItems );
    ListSecond.InvalidateItems( 0, ListSecond.NoOfItems );
    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <750,399,950,439>
  slot OnFinishedFlash
  {
    postsignal OnAnimationEnded;
  }

  $rect <699,190,899,230>
  property slot OnAnimationEnded;

  // Animation Management
  note group Note3
  {
    attr Bounds = <739,319,960,450>;
  }

  $reorder OnSetOpacity 9
  $reorder OnGetEmbedded 9
  $reorder OnSetEmbedded 9
  $reorder OnGetAlphaBlended 9
  $reorder OnSetAlphaBlended 9
  $reorder OnGetVisible 9
  $reorder OnSetVisible 9
  $reorder DrawForeground 9
  $reorder DrawBackground 9
  $reorder GetMinimalSize 9
  $reorder FindActiveDialogByClass 9
  $reorder FindDialogByClass 9
  $reorder FindCurrentDialog 9
  $reorder IsCurrentDialog 9
  $reorder IsActiveDialog 9
  $reorder IsDialog 9
  $reorder GetIndexOfDialog 9
  $reorder GetDialogAtIndex 9
  $reorder CountDialogs 9
  $reorder SwitchToDialog 9
  $reorder DismissDialog 9
  $reorder PresentDialog 9
  $reorder ObtainFocus 9
  $reorder HasViewState 9
  $reorder LocalPosition 9
  $reorder GlobalPosition 9
  $reorder DispatchEvent 9
  $reorder BroadcastEventAtPosition 9
  $reorder BroadcastEvent 9
  $reorder UpdateLayout 9
  $reorder UpdateViewState 9
  $reorder InvalidateLayout 9
  $reorder InvalidateViewState 9
  $reorder InvalidateArea 9
  $reorder GetIndexOfView 9
  $reorder GetViewAtIndex 9
  $reorder CountViews 9
  $reorder FindViewInDirection 9
  $reorder FindViewWithinArea 9
  $reorder FindViewAtPosition 9
  $reorder FindPrevView 9
  $reorder FindNextView 9
  $reorder FindSiblingView 9
  $reorder GetContentArea 9
  $reorder FadeGroup 9
  $reorder RestackBehind 9
  $reorder RestackBack 9
  $reorder RestackTop 9
  $reorder Restack 9
  $reorder RemoveAll 9
  $reorder Remove 9
  $reorder Opacity 14
  $reorder Embedded 14
  $reorder AlphaBlended 14
  $reorder Visible 14
  $reorder Note2 14
  $reorder Note1 14
  $reorder OnEndSlide 14
  $reorder OnStartSlide 14
  $reorder OnLoadSecondItem 14
  $reorder OnLoadMinuteItem 14
  $reorder OnLoadHourItem 14
  $reorder OnGetSecond 14
  $reorder OnSetSecond 14
  $reorder OnGetMinute 14
  $reorder OnSetMinute 14
  $reorder OnGetHour 14
  $reorder OnSetHour 14
  $reorder BorderCurrent 14
  $reorder TouchHandlerSecond 14
  $reorder TouchHandlerMinute 14
  $reorder TouchHandlerHour 14
  $reorder ListSecond 14
  $reorder ListMinute 14
  $reorder ListHour 14
  $reorder Separator1 14
  $reorder Separator2 14
  $reorder OnTimeChanged 14
  $reorder Second 14
  $reorder Minute 14
  $reorder Hour 14
  $reorder OnSlideSecond 14
  $reorder OnSlideMinute 14
  $reorder OnSlideHour 14
  $reorder AddBehind 9
  $reorder Add 9
  $reorder Focus 9
  $reorder Buffered 9
}

$rect <-118,160,82,200>
$output false
class TimerScreen : Core::Group
{
  $rect <690,39,890,79>
  inherited method Init()
  {
    postsignal UpdateTime;
  }

  $rect <690,-10,890,30>
  inherited property Bounds = rect(0,0,$ScreenSize.x,$ScreenSize.y);

  $rect <930,130,1130,170>
  slot WipeUpSlot
  {
    Owner.SwitchToDialog(new Clock::ClockScreen, Effects::SlideUpCentered, null, null, null, null, null, null, null, null, false );
  }

  $rect <1161,170,1352,210>
  slot UpdateTime
  {
    var Core::Time currentTime = Clock::Time.CurrentTime;

    Hour.String=string(currentTime.Hour/10)+string(currentTime.Hour%10)+":"+string(currentTime.Minute/10)+string(currentTime.Minute%10);
  }

  $rect <700,130,900,170>
  slot OnStart
  {
    switch(StartButton.FrameNumber==1)
    {
      case true:
      {
        TimerClock.Stop();
        StartButton.FrameNumber=0;
      }
      case false:
      {
        TimerClock.Start();
        StartButton.FrameNumber=1;
      }
      default:;
    }              

  }

  $rect <700,210,902,250>
  slot OnCancel
  {
    TimerClock.ResetTime();

  }

  $rect <1379,130,1579,170>
  slot OnValidEntry
  {
    StartButton.Enabled=true;
    CancelButton.Enabled=true;

    StartButton.FrameNumber=0;

  }

  $rect <1161,130,1352,170>
  object Core::SystemEventHandler TimeChangedHandler
  {
    preset OnEvent = UpdateTime;
    preset Event = Clock::Device.TimeChanged;
  }

  $rect <700,170,900,210>
  slot OnEnd
  {
    StartButton.Enabled=false;
    CancelButton.Enabled=false;

    StartButton.FrameNumber=0;

  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Bounds = <0,39,640,480>;
    preset Color = #1D243858;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle1
  {
    preset Bounds = <0,439,640,480>;
    preset ColorBL = #FFFFFFFF;
    preset ColorBR = #FFFFFFFF;
    preset ColorTR = #FFFFFF53;
    preset ColorTL = #FFFFFF53;
    preset Color = #0F1E35FF;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle2
  {
    preset Bounds = <0,39,640,80>;
    preset ColorBL = #FFFFFF53;
    preset ColorBR = #FFFFFF53;
    preset ColorTR = #FFFFFFFF;
    preset ColorTL = #FFFFFFFF;
    preset Color = #0F1E35FF;
  }

  $rect <20,20,160,60>
  object Views::Border Border1
  {
    preset Bounds = <0,0,640,80>;
    preset Color = #0F1E358C;
  }

  $rect <20,20,160,60>
  object Views::Border Border2
  {
    preset Bounds = <0,439,640,479>;
    preset Color = #0F1E358C;
  }

  $rect <20,20,160,60>
  object Views::Image Image
  {
    preset Bounds = <295,430,345,480>;
    preset Color = #FAE9E0FF;
    preset Bitmap = Resources::NavigationIconsMedium;
  }

  $rect <20,20,160,60>
  object Core::WipeTouchHandler WipeUp
  {
    preset Bounds = <0,430,640,479>;
    preset OnTop = WipeUpSlot;
  }

  $rect <20,20,160,60>
  object Views::Text Hour
  {
    preset Bounds = <458,9,640,70>;
    preset Alignment = Views::TextAlignment[AlignHorzAuto, AlignHorzCenter, AlignVertCenter];
    preset String = "Text";
    preset Font = Clock::LargeFont;
    preset Color = #FAE9E0FF;
  }

  $rect <20,20,160,60>
  object Clock::TimerClock TimerClock
  {
    preset Bounds = <131,26,510,405>;
    preset OnFinishedTiming = OnEnd;
    preset OnValidEntry = OnValidEntry;
  }

  $rect <20,20,160,60>
  object Clock::DefaultButton CancelButton
  {
    preset Bounds = <220,367,320,416>;
    preset Enabled = false;
    preset OnPress = OnCancel;
    preset FrameNumber = 14;
    preset Bitmap = Resources::NavigationIconsMedium;
    preset IconColor = #FAE9E0FF;
    preset DefaultColor = #0F1E35FF;
    preset LabelColor = #FAE9E0FF;
    preset Label = "";
    preset Font = Resources::FontMedium;
  }

  $rect <20,20,160,60>
  object Clock::DefaultButton StartButton
  {
    preset Bounds = <320,367,420,416>;
    preset Enabled = false;
    preset OnPress = OnStart;
    preset FrameNumber = 0;
    preset Bitmap = Resources::PlayerIconsMedium;
    preset IconColor = #FAE9E0FF;
    preset DefaultColor = #0F1E35FF;
    preset LabelColor = #FAE9E0FF;
    preset Label = "";
    preset Font = Resources::FontMedium;
  }

  $rect <20,20,160,60>
  object Views::Line Line
  {
    preset Point2 = <320,410>;
    preset Point1 = <320,373>;
    preset Color = #FAE9E0FF;
  }

  $rect <20,20,160,60>
  object Views::Image Image4
  {
    preset Bounds = <615,232,640,282>;
    preset Color = #FAE9E0FF;
    preset FrameNumber = 3;
    preset Bitmap = Resources::NavigationIconsSmall;
  }

  $rect <20,20,160,60>
  object Views::Image Image5
  {
    preset Bounds = <0,240,25,290>;
    preset Color = #FAE9E0FF;
    preset FrameNumber = 2;
    preset Bitmap = Resources::NavigationIconsSmall;
  }

  $rect <20,20,160,60>
  object Core::WipeTouchHandler WipeLeft
  {
    preset Bounds = <550,39,640,479>;
    preset OnLeft = WipeLeftSlot;
    preset RetargetCondition = Core::RetargetReason[WipeDown, WipeUp];
  }

  $rect <20,20,160,60>
  object Core::WipeTouchHandler WipeRight
  {
    preset Bounds = <0,40,90,478>;
    preset OnRight = WipeRightSlot;
    preset RetargetCondition = Core::RetargetReason[WipeDown, WipeUp];
  }

  $rect <930,210,1130,250>
  slot WipeLeftSlot
  {
    Owner.SwitchToDialog(new Clock::AlarmScreen, Effects::SlideLeftCentered, null, null, null, null, null, null, null, null, false );
  }

  $rect <930,170,1130,210>
  slot WipeRightSlot
  {
    Owner.SwitchToDialog(new Clock::CalendarScreen, Effects::SlideRightCentered, null, null, null, null, null, null, null, null, false );
  }

  // Button Press Events
  note group Note
  {
    attr Bounds = <689,90,910,260>;
  }

  // Touch Handler Events
  note group Note1
  {
    attr Bounds = <919,90,1140,260>;
  }

  // Time Display
  note group Note2
  {
    attr Bounds = <1150,90,1361,220>;
  }

  // Time Selection Event
  note group Note3
  {
    attr Bounds = <1370,90,1590,180>;
  }
}

$rect <-118,200,82,240>
$output false
class ChronometerScreen : Core::Group
{
  $rect <670,-10,870,30>
  inherited method Init()
  {
    postsignal UpdateTime;

  }

  $rect <879,-10,1079,30>
  inherited property Bounds = rect(0,0,$ScreenSize.x,$ScreenSize.y);

  $rect <1160,90,1360,130>
  object Core::Timer Timer
  {
    preset OnTrigger = UpdateTime;
    preset Period = 100;
    preset Enabled = true;
  }

  $rect <920,170,1120,210>
  slot WipeUpSlot
  {
    Owner.SwitchToDialog(new Clock::ClockScreen, Effects::SlideUpCentered, null, null, null, null, null, null, null, null, false );
  }

  $rect <1160,130,1360,170>
  slot UpdateTime
  {
    var Core::Time currentTime = Clock::Time.CurrentTime;

    Hour.String=string(currentTime.Hour/10)+string(currentTime.Hour%10)+":"+string(currentTime.Minute/10)+string(currentTime.Minute%10);
  }

  $rect <1400,90,1600,130>
  slot UpdateButtonState
  {
    ResetButton.Enabled=Stopwatch.Running;
    SaveButton.Enabled=Stopwatch.Running;
  }

  $rect <681,89,881,129>
  slot OnPauseButton
  {
    switch(PauseButton.FrameNumber==1)
    {
      case true:
      {
        Stopwatch.Timer.Enabled=false;
        PauseButton.FrameNumber=0;
      }
      case false:
      {
        if(!Stopwatch.Running) Stopwatch.Running=true;
        Stopwatch.Timer.Enabled=true;
        PauseButton.FrameNumber=1;
      }
      default:;
    }

  }

  $rect <681,129,881,169>
  slot OnResetButton
  {
    Stopwatch.Timer.Enabled=false;
    Stopwatch.Running=false;
    Stopwatch.SecondsElapsed=0;

    PauseButton.FrameNumber=0;
  }

  $rect <681,169,881,209>
  slot OnSaveButton
  {
    var Views::Text txt=new Views::Text;

    txt.Embedded = true;
    txt.Bounds = <0,0,320,50>;
    txt.Font = Clock::LargeFont;
    txt.String = Stopwatch.HourText.String + ":" + Stopwatch.MinuteText.String + ":" +Stopwatch.SecondText.String + ":" + Stopwatch.CentisecondText.String;

    Add( txt, 0 );

  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Bounds = <0,39,640,480>;
    preset Color = #1D243858;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle1
  {
    preset Bounds = <0,439,640,480>;
    preset ColorBL = #0F1E35FF;
    preset ColorBR = #0F1E35FF;
    preset ColorTR = #0F1E3553;
    preset ColorTL = #0F1E3553;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle2
  {
    preset Bounds = <0,39,640,80>;
    preset ColorBL = #0F1E3553;
    preset ColorBR = #0F1E3553;
    preset ColorTR = #0F1E35FF;
    preset ColorTL = #0F1E35FF;
  }

  $rect <20,20,160,60>
  object Views::Image Image3
  {
    preset Bounds = <295,430,345,480>;
    preset Color = #FAE9E0FF;
    preset Bitmap = Resources::NavigationIconsMedium;
  }

  $rect <20,20,160,60>
  object Views::Border Border
  {
    preset Bounds = <0,439,640,479>;
    preset Color = #0F1E358C;
  }

  $rect <20,20,160,60>
  object Views::Border Border1
  {
    preset Bounds = <0,0,640,80>;
    preset Color = #0F1E358C;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle4
  {
    preset Bounds = <320,110,640,160>;
    preset ColorBL = #0F1E354A;
    preset ColorBR = #0F1E3592;
    preset ColorTR = #0F1E3592;
    preset ColorTL = #0F1E354A;
    preset Color = #FFFFFFFF;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle5
  {
    preset Bounds = <0,110,320,160>;
    preset ColorBL = #0F1E3592;
    preset ColorBR = #0F1E354A;
    preset ColorTR = #0F1E354A;
    preset ColorTL = #0F1E3592;
    preset Color = #FFFFFFFF;
  }

  $rect <20,20,160,60>
  object Views::Image Image1
  {
    preset Bounds = <595,110,645,160>;
    preset Color = #FAE9E0FF;
    preset ScrollOffset = <0,0>;
    preset FrameNumber = 3;
    preset Bitmap = Resources::NavigationIconsMedium;
  }

  $rect <20,20,160,60>
  object Views::Image Image2
  {
    preset Bounds = <0,110,50,160>;
    preset Color = #FAE9E0FF;
    preset ScrollOffset = <0,0>;
    preset FrameNumber = 2;
    preset Bitmap = Resources::NavigationIconsMedium;
  }

  $rect <20,20,160,60>
  object Core::Outline Outline
  {
    preset Bounds = <0,110,640,160>;
    preset SlideHandler = SlideTouchHandler;
    preset Formation = Core::Formation.LeftToRight;
  }

  $rect <20,20,160,60>
  object Core::SlideTouchHandler SlideTouchHandler
  {
    preset Bounds = <0,110,640,160>;
    preset SnapNext = <50,0>;
    preset SlideVert = false;
    preset RubberBandEffectElasticity = 5.0;
  }

  $rect <20,20,160,60>
  object Clock::DefaultButton ResetButton
  {
    preset Bounds = <270,357,370,406>;
    preset Enabled = false;
    preset OnPress = OnResetButton;
    preset FrameNumber = 14;
    preset Bitmap = Resources::NavigationIconsMedium;
    preset IconColor = #FAE9E0FF;
    preset DefaultColor = #0F1E35FF;
    preset LabelColor = #FAE9E0FF;
    preset Label = "";
    preset Font = Resources::FontMedium;
  }

  $rect <20,20,160,60>
  object Clock::DefaultButton PauseButton
  {
    preset Bounds = <170,357,270,406>;
    preset Enabled = true;
    preset OnPress = OnPauseButton;
    preset FrameNumber = 0;
    preset Bitmap = Resources::PlayerIconsMedium;
    preset IconColor = #FAE9E0FF;
    preset DefaultColor = #0F1E35FF;
    preset LabelColor = #FAE9E0FF;
    preset Label = "";
    preset Font = Resources::FontMedium;
  }

  $rect <20,20,160,60>
  object Clock::DefaultButton SaveButton
  {
    preset Bounds = <369,357,469,406>;
    preset Enabled = false;
    preset OnPress = OnSaveButton;
    preset FrameNumber = 16;
    preset Bitmap = Resources::NavigationIconsMedium;
    preset IconColor = #FAE9E0FF;
    preset DefaultColor = #0F1E35FF;
    preset LabelColor = #FAE9E0FF;
    preset Label = "";
    preset Font = Resources::FontMedium;
  }

  $rect <20,20,160,60>
  object Views::Line Line
  {
    preset Point2 = <270,401>;
    preset Point1 = <270,367>;
  }

  $rect <20,20,160,60>
  object Views::Line Line1
  {
    preset Point2 = <370,401>;
    preset Point1 = <370,367>;
  }

  $rect <20,20,160,60>
  object Views::Image Image
  {
    preset Bounds = <295,430,345,480>;
    preset Color = #FAE9E0FF;
    preset Bitmap = Resources::NavigationIconsMedium;
  }

  $rect <20,20,160,60>
  object Core::WipeTouchHandler WipeUp
  {
    preset Bounds = <0,430,640,479>;
    preset OnTop = WipeUpSlot;
  }

  $rect <20,20,160,60>
  object Views::Text Hour
  {
    preset Bounds = <458,9,640,70>;
    preset Alignment = Views::TextAlignment[AlignHorzAuto, AlignHorzCenter, AlignVertCenter];
    preset String = "Text";
    preset Font = Clock::LargeFont;
    preset Color = #FAE9E0FF;
  }

  $rect <20,20,160,60>
  object Clock::Chronometer Stopwatch
  {
    preset Bounds = <62,172,579,343>;
    preset OnChange = UpdateButtonState;
  }

  $rect <20,20,160,60>
  object Core::WipeTouchHandler WipeLeft
  {
    preset Bounds = <550,39,640,479>;
    preset OnLeft = WipeLeftSlot;
    preset RetargetCondition = Core::RetargetReason[WipeDown, WipeUp];
  }

  $rect <20,20,160,60>
  object Views::Image Image4
  {
    preset Bounds = <615,232,640,282>;
    preset Color = #FAE9E0FF;
    preset FrameNumber = 3;
    preset Bitmap = Resources::NavigationIconsSmall;
  }

  $rect <20,20,160,60>
  object Views::Image Image5
  {
    preset Bounds = <0,240,25,290>;
    preset Color = #FAE9E0FF;
    preset FrameNumber = 2;
    preset Bitmap = Resources::NavigationIconsSmall;
  }

  $rect <20,20,160,60>
  object Core::WipeTouchHandler WipeRight
  {
    preset Bounds = <0,40,90,478>;
    preset OnRight = WipeRightSlot;
    preset RetargetCondition = Core::RetargetReason[WipeDown, WipeUp];
  }

  $rect <920,130,1120,170>
  slot WipeLeftSlot
  {
    Owner.SwitchToDialog(new Clock::CalendarScreen, Effects::SlideLeftCentered, null, null, null, null, null, null, null, null, false );
  }

  $rect <920,90,1120,130>
  slot WipeRightSlot
  {
    Owner.SwitchToDialog(new Clock::AlarmScreen, Effects::SlideRightCentered, null, null, null, null, null, null, null, null, false );
  }

  // Button Press Events
  note group Note
  {
    attr Bounds = <670,50,891,220>;
  }

  // Touch Handler Events
  note group Note1
  {
    attr Bounds = <910,50,1131,220>;
  }

  // Time Display
  note group Note2
  {
    attr Bounds = <1150,50,1370,179>;
  }

  // Chronometer State
  note group Note3
  {
    attr Bounds = <1390,51,1610,139>;
  }

  // Button Press Events
  note group Note4
  {
    attr Bounds = <670,50,891,220>;
  }
}

// This class implements an 'instrument', used to display e.g. measured values. The \
// widget is controlled by the properties @CurrentValue and @Unit.
// Alternatively the property @Outlet can refer to any other 'int32' property the \
// widget should remain synchronized with. When the referred property is modified \
// by another one, the widget is automatically notified to remain in sync with the \
// property.
// This approach follows the Model-View-Controller (MVC) programming paradigm. Here \
// the widget represents the 'View' and the property referred via 'Outlet' can be \
// seen as a part of the 'Model'.
$rect <-130,760,70,800>
$output false
class Chronometer : Templates::ValueDisplay
{
  $rect <560,-10,760,30>
  inherited property Bounds = <0,0,517,171>;

  $rect <20,20,160,60>
  object Views::Text HourText
  {
    preset Bounds = <21,0,139,171>;
    preset Alignment = Views::TextAlignment[AlignHorzAuto, AlignHorzCenter, AlignVertCenter];
    preset String = "00";
    preset Font = Clock::MediumFont;
    preset Color = #FAE9E0FF;
  }

  $rect <20,20,160,60>
  object Views::Text Dots1
  {
    preset Bounds = <139,0,168,149>;
    preset Alignment = Views::TextAlignment[AlignHorzAuto, AlignHorzCenter, AlignVertCenter];
    preset String = ":";
    preset Font = Clock::MediumFont;
    preset Color = #FAE9E0FF;
  }

  $rect <20,20,160,60>
  object Views::Text MinuteText
  {
    preset Bounds = <168,0,286,171>;
    preset Alignment = Views::TextAlignment[AlignHorzAuto, AlignHorzCenter, AlignVertCenter];
    preset String = "00";
    preset Font = Clock::MediumFont;
    preset Color = #FAE9E0FF;
  }

  $rect <20,20,160,60>
  object Views::Text Dots2
  {
    preset Bounds = <286,0,315,149>;
    preset Alignment = Views::TextAlignment[AlignHorzAuto, AlignHorzCenter, AlignVertCenter];
    preset String = ":";
    preset Font = Clock::MediumFont;
    preset Color = #FAE9E0FF;
  }

  $rect <20,20,160,60>
  object Views::Text SecondText
  {
    preset Bounds = <315,0,433,171>;
    preset Alignment = Views::TextAlignment[AlignHorzAuto, AlignHorzCenter, AlignVertCenter];
    preset String = "00";
    preset Font = Clock::MediumFont;
    preset Color = #FAE9E0FF;
  }

  $rect <20,20,160,60>
  object Views::Text CentisecondText
  {
    preset Bounds = <433,21,496,171>;
    preset Alignment = Views::TextAlignment[AlignHorzAuto, AlignHorzCenter, AlignVertCenter];
    preset String = "00";
    preset Font = Clock::LargeFont;
    preset Color = #FAE9E0FF;
  }

  $rect <570,409,770,449>
  object Core::Timer Timer
  {
    preset OnTrigger = UpdateTime;
    preset Period = 10;
    preset Enabled = false;
  }

  $rect <570,449,770,489>
  slot UpdateTime
  {
    SecondsElapsed++;
  }

  $rect <560,310,760,350>
  method void SetTime( arg int32 value )
  {
    var int32 centiseconds=value%100;
    var int32 seconds = value%6000/100;
    var int32 minutes= (value%360000)/6000;
    var int32 hours = (value%8640000)/360000;

    HourText.String=string(hours,2);
    MinuteText.String=string(minutes,2);
    SecondText.String=string(seconds,2);
    CentisecondText.String=string(centiseconds,2);

  }

  $rect <560,190,760,230>
  property int32 SecondsElapsed = 0;

  $rect <560,230,760,270>
  onset SecondsElapsed
  {
    // The value doesn't change - nothing to do.
    if ( pure SecondsElapsed == value )
      return;

    // Remember the property's new value.
    pure SecondsElapsed = value;

    if(SecondsElapsed>=21599999) Enabled=false;
    SetTime(value);


  }

  $rect <560,270,760,310>
  onget SecondsElapsed
  {
    return pure SecondsElapsed;
  }

  // The property 'OnChange' can refer to a slot method, which will receive a signal \
  // each time the user select another time. Thereupon the method's logic will be \
  // executed. In the associated slot method you can evaluate the time picker properties \
  // @Hour, @Minute and @Second.
  $rect <770,190,970,230>
  property slot OnChange = null;

  // The property 'Enabled' determines whether the component is able to react to \
  // user input events. Disabled components will never receive these events.
  // The @Enabled property is reflected in the current state of the component Core::ViewState.Enabled. \
  // This state can be evaluated in the implementation of the @UpdateViewState() \
  // method. For example, the method may show disabled components with pale colors, \
  // etc.
  // Please note, changing the enabled state of the component currently selected \
  // in the @Focus property will cause the framework to select other sibling view, \
  // which will be able to react to keyboard events.
  $rect <560,50,760,90>
  property bool Running = false;

  $rect <560,90,760,130>
  onset Running
  {
    pure Running = value;

    postsignal OnChange;
  }

  $rect <560,130,760,170>
  onget Running
  {
    return pure Running;
  }

  // Timelapse
  note group Note
  {
    attr Bounds = <560,370,780,500>;
  }

  $reorder OnSetOpacity 4
  $reorder OnGetEmbedded 4
  $reorder OnSetEmbedded 4
  $reorder OnGetAlphaBlended 4
  $reorder OnSetAlphaBlended 4
  $reorder OnGetVisible 4
  $reorder OnSetVisible 4
  $reorder DrawForeground 4
  $reorder DrawBackground 4
  $reorder GetMinimalSize 4
  $reorder FindActiveDialogByClass 4
  $reorder FindDialogByClass 4
  $reorder FindCurrentDialog 4
  $reorder IsCurrentDialog 4
  $reorder IsActiveDialog 4
  $reorder IsDialog 4
  $reorder GetIndexOfDialog 4
  $reorder GetDialogAtIndex 4
  $reorder CountDialogs 4
  $reorder SwitchToDialog 4
  $reorder DismissDialog 4
  $reorder PresentDialog 4
  $reorder ObtainFocus 4
  $reorder HasViewState 4
  $reorder LocalPosition 4
  $reorder GlobalPosition 4
  $reorder DispatchEvent 4
  $reorder BroadcastEventAtPosition 4
  $reorder BroadcastEvent 4
  $reorder UpdateLayout 4
  $reorder UpdateViewState 4
  $reorder InvalidateLayout 4
  $reorder InvalidateViewState 4
  $reorder InvalidateArea 4
  $reorder GetIndexOfView 4
  $reorder GetViewAtIndex 4
  $reorder CountViews 4
  $reorder FindViewInDirection 4
  $reorder FindViewWithinArea 4
  $reorder FindViewAtPosition 4
  $reorder FindPrevView 4
  $reorder FindNextView 4
  $reorder FindSiblingView 4
  $reorder GetContentArea 4
  $reorder FadeGroup 4
  $reorder RestackBehind 4
  $reorder RestackBack 4
  $reorder RestackTop 4
  $reorder Restack 4
  $reorder RemoveAll 4
  $reorder Remove 4
  $reorder Opacity 9
  $reorder Embedded 9
  $reorder AlphaBlended 9
  $reorder Visible 9
  $reorder HourText 9
  $reorder Dots1 9
  $reorder MinuteText 9
  $reorder Dots2 9
  $reorder Enabled 8
  $reorder SecondText 8
  $reorder CentisecondText 8
  $reorder Timer 8
  $reorder UpdateTime 8
  $reorder SetTime 8
  $reorder SecondsElapsed 8
  $reorder OnSetSecondsElapsed 8
  $reorder OnGetSecondsElapsed 8
  $reorder AddBehind 4
  $reorder Add 4
  $reorder Focus 4
  $reorder Buffered 4
  $reorder OnSetEnabled 2
}

$rect <120,339,320,379>
$output false
resource Resources::Font SmallFont
{
  attr fontname FontName = Agency FB;
  attr fontheight Height = 35;
  attr fontheightmode HeightMode = Popular;
  attr fontquality Quality = High;
  attr fontranges Ranges = 0x20-0xFF;
  attr fontaspectratio AspectRatio = 1;
  attr fontbold Bold = true;
  attr fontitalic Italic = false;
  attr fontkerning Kerning = true;
  attr fontrowdistance RowDistance;
}

$rect <-118,240,82,280>
$output false
class AlarmScreen : Core::Group
{
  $rect <690,-10,890,30>
  inherited method Init()
  {
    postsignal UpdateTime;
    TimePicker.SetTime( Clock::Time.CurrentTime.Time );
  }

  $rect <690,40,890,80>
  inherited property Bounds = rect(0,0,$ScreenSize.x,$ScreenSize.y);

  $rect <701,219,901,259>
  slot WipeUpSlot
  {
    Owner.SwitchToDialog(new Clock::ClockScreen, Effects::SlideUpCentered, null, null, null, null, null, null, null, null, false );
  }

  $rect <1160,179,1360,219>
  slot UpdateTime
  {
    var Core::Time currentTime =  Clock::Time.CurrentTime;
    Hour.String=string(currentTime.Hour/10)+string(currentTime.Hour%10)+":"+string(currentTime.Minute/10)+string(currentTime.Minute%10);
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Bounds = <0,39,640,480>;
    preset Color = #1D243858;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle1
  {
    preset Bounds = <0,439,640,480>;
    preset ColorBL = #FFFFFFFF;
    preset ColorBR = #FFFFFFFF;
    preset ColorTR = #FFFFFF53;
    preset ColorTL = #FFFFFF53;
    preset Color = #0F1E35FF;
  }

  $rect <20,20,160,60>
  object Views::Border Border
  {
    preset Bounds = <0,439,640,479>;
    preset Color = #0F1E358C;
  }

  $rect <20,20,160,60>
  object Views::Border Border1
  {
    preset Bounds = <0,0,640,80>;
    preset Color = #0F1E358C;
  }

  $rect <20,20,160,60>
  object Views::Image Image
  {
    preset Bounds = <295,430,345,480>;
    preset Bitmap = Resources::NavigationIconsMedium;
  }

  $rect <20,20,160,60>
  object Core::WipeTouchHandler WipeUp
  {
    preset Bounds = <0,430,640,479>;
    preset OnTop = WipeUpSlot;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle3
  {
    preset Bounds = <0,39,640,80>;
    preset ColorBL = #FFFFFF53;
    preset ColorBR = #FFFFFF53;
    preset ColorTR = #FFFFFFFF;
    preset ColorTL = #FFFFFFFF;
    preset Color = #0F1E35FF;
  }

  $rect <20,20,160,60>
  object Views::Text Hour
  {
    preset Bounds = <458,9,640,70>;
    preset Alignment = Views::TextAlignment[AlignHorzAuto, AlignHorzCenter, AlignVertCenter];
    preset String = "00:00";
    preset Font = Clock::LargeFont;
    preset Color = #FAE9E0FF;
  }

  $rect <20,20,160,60>
  object Clock::TimePicker TimePicker
  {
    preset Bounds = <125,128,373,325>;
    preset OnTimeChanged = null;
  }

  $rect <20,20,160,60>
  object Views::Line Line;

  $rect <20,20,160,60>
  object Views::Line Line1
  {
    preset Point2 = <507,390>;
    preset Point1 = <507,128>;
    preset Width = 3;
    preset Color = #FAE9E0FF;
  }

  $rect <930,139,1130,179>
  slot OnAddButton
  {
    var int64 currentTime=Clock::Time.CurrentTime.Time;
    var Clock::Event event=new Clock::Event;
    event.Type=Clock::EventType.Alarm;
    event.TriggerTime=currentTime-currentTime%86400+TimePicker.Hour*3600+TimePicker.Minute*60+TimePicker.Second;


    if(Clock::Device.AddEvent( event ))
    {      
      var int32 index;
      for(index=0;index<7;index++) 
      {
        event.ScheduledDays[index]=WeekButtonList.SelectedDays[index];
      }
      event.IsScheduled=Clock::Device.UpdateEvent( 0 );
      if(!event.IsScheduled && event.TriggerTime<=currentTime) 
        event.TriggerTime+=86400;
    }


  }

  $rect <1160,139,1360,179>
  object Core::SystemEventHandler TimeChangedHandler
  {
    preset OnEvent = UpdateTime;
    preset Event = Clock::Device.TimeChanged;
  }

  $rect <20,20,160,60>
  object Views::Image Image4
  {
    preset Bounds = <615,232,640,282>;
    preset Color = #FAE9E0FF;
    preset FrameNumber = 3;
    preset Bitmap = Resources::NavigationIconsSmall;
  }

  $rect <20,20,160,60>
  object Views::Image Image5
  {
    preset Bounds = <0,240,25,290>;
    preset Color = #FAE9E0FF;
    preset FrameNumber = 2;
    preset Bitmap = Resources::NavigationIconsSmall;
  }

  $rect <20,20,160,60>
  object Core::WipeTouchHandler WipeLeft
  {
    preset Bounds = <550,39,640,479>;
    preset OnLeft = WipeLeftSlot;
    preset RetargetCondition = Core::RetargetReason[WipeDown, WipeUp];
  }

  $rect <20,20,160,60>
  object Core::WipeTouchHandler WipeRight
  {
    preset Bounds = <0,40,90,478>;
    preset OnRight = WipeRightSlot;
    preset RetargetCondition = Core::RetargetReason[WipeDown, WipeUp];
  }

  $rect <20,20,160,60>
  object Clock::DefaultButton DefaultButton
  {
    preset Bounds = <540,221,615,297>;
    preset OnPress = OnAddButton;
    preset FrameNumber = 18;
    preset Bitmap = Resources::NavigationIconsLarge;
    preset IconColor = #FAE9E0FF;
    preset DefaultColor = #0F1E35FF;
    preset LabelColor = #FAE9E0FF;
  }

  $rect <20,20,160,60>
  object Clock::WeekButtonList WeekButtonList
  {
    preset Bounds = <40,325,458,384>;
  }

  $rect <701,179,901,219>
  slot WipeLeftSlot
  {
    Owner.SwitchToDialog(new Clock::ChronometerScreen, Effects::SlideLeftCentered, null, null, null, null, null, null, null, null, false );
  }

  $rect <701,139,901,179>
  slot WipeRightSlot
  {
    Owner.SwitchToDialog(new Clock::TimerScreen, Effects::SlideRightCentered, null, null, null, null, null, null, null, null, false );
  }

  // Touch Screen Events
  note group Note
  {
    attr Bounds = <690,99,911,270>;
  }

  // Button Press Events
  note group Note1
  {
    attr Bounds = <920,99,1139,190>;
  }

  // Time Display
  note group Note2
  {
    attr Bounds = <1150,99,1370,230>;
  }
}

$rect <-118,280,82,320>
$output false
class CalendarScreen : Core::Group
{
  $rect <680,-10,880,30>
  inherited method Init()
  {
    SelectedDate=Clock::Time.CurrentTime;
    TimePicker.SetTime( Clock::Time.CurrentTime.Time );
    UpdateSelectedDate();

  }

  $rect <899,-10,1097,30>
  inherited property Bounds = rect(0,0,$ScreenSize.x,$ScreenSize.y);

  $rect <680,230,880,270>
  slot WipeUpSlot
  {
    Owner.SwitchToDialog(new Clock::ClockScreen, Effects::SlideUpCentered, null, null, null, null, null, null, null, null, false );
  }

  $rect <20,20,160,60>
  object Views::Border Border
  {
    preset Bounds = <0,439,640,479>;
    preset Color = #0F1E358C;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Bounds = <0,39,640,480>;
    preset Color = #00000058;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle1
  {
    preset Bounds = <0,439,640,480>;
    preset ColorBL = #FFFFFFFF;
    preset ColorBR = #FFFFFFFF;
    preset ColorTR = #FFFFFF53;
    preset ColorTL = #FFFFFF53;
    preset Color = #0F1E35FF;
  }

  $rect <20,20,160,60>
  object Views::Image Image
  {
    preset Bounds = <295,430,345,480>;
    preset Color = #FAE9E0FF;
    preset Bitmap = Resources::NavigationIconsMedium;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle3
  {
    preset Bounds = <310,39,526,438>;
    preset ColorBR = #FFFFFF00;
    preset ColorTR = #FFFFFF00;
    preset Color = #1D24384E;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle2
  {
    preset Bounds = <0,39,311,439>;
    preset Color = #276080B6;
  }

  $rect <20,20,160,60>
  object Views::Image Image4
  {
    preset Bounds = <615,232,640,282>;
    preset Color = #FAE9E0FF;
    preset FrameNumber = 3;
    preset Bitmap = Resources::NavigationIconsSmall;
  }

  $rect <20,20,160,60>
  object Views::Image Image5
  {
    preset Bounds = <0,240,25,290>;
    preset Color = #FAE9E0FF;
    preset FrameNumber = 2;
    preset Bitmap = Resources::NavigationIconsSmall;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle4
  {
    preset Bounds = <0,39,640,343>;
    preset ColorBL = #FFFFFF00;
    preset ColorBR = #FFFFFF00;
    preset ColorTR = #FFFFFFFF;
    preset Color = #1D2438FF;
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <322,266,628,316>;
    preset Alignment = Views::TextAlignment[AlignHorzAuto, AlignHorzCenter, AlignVertTop];
    preset String = "";
    preset Font = Clock::SmallFont;
    preset Color = #FAE9E0FF;
  }

  $rect <680,50,880,90>
  property Core::Time SelectedDate;

  $rect <899,50,1099,90>
  onset SelectedDate
  {
    // The value doesn't change - nothing to do.
    if ( pure SelectedDate == value )
      return;

    // Remember the property's new value.
    pure SelectedDate = value;
    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <900,190,1100,230>
  slot OnSelectedCalendar
  {
    var Core::Time selected=MonthList.SelectedDate;

    SelectedDate=Clock::Time.Initialize2( selected.Year, selected.Month, selected.Day, TimePicker.Hour, TimePicker.Minute, TimePicker.Second );

    UpdateSelectedDate();
  }

  $rect <900,230,1100,270>
  method void UpdateSelectedDate()
  {
    Text.String=string(SelectedDate.Year)+" "+ SelectedDate.getMonthName(SelectedDate.Month,true)+" "+string(SelectedDate.Day,2)+" "+string(SelectedDate.Hour,2)+":"+string(SelectedDate.Minute,2);

    AddButton.Enabled=IsValidSelection(); 
  }

  $rect <900,270,1100,310>
  method bool IsValidSelection()
  {
    if(SelectedDate.Time<=Clock::Time.CurrentTime.Time)   
      return false;
    else 
      return true;
  }

  $rect <900,150,1100,190>
  slot OnSelectedTime
  {
    SelectedDate=Clock::Time.Initialize2( SelectedDate.Year, SelectedDate.Month, SelectedDate.Day, TimePicker.Hour, TimePicker.Minute, TimePicker.Second );

    UpdateSelectedDate();
  }

  $rect <1121,150,1321,190>
  slot OnButton
  {
    var Clock::Event event=new Clock::Event;

    event.Type=Clock::EventType.Calendar;
    event.TriggerTime=SelectedDate.Time;
    event.IsScheduled=false;

    Clock::Device.AddEvent( event );

  }

  $rect <20,20,160,60>
  object Clock::DefaultButton AddButton
  {
    preset Bounds = <437,330,512,380>;
    preset OnPress = OnButton;
    preset FrameNumber = 18;
    preset Bitmap = Resources::NavigationIconsMedium;
    preset IconColor = #FAE9E0FF;
    preset DefaultColor = #0F1E35FF;
    preset LabelColor = #FAE9E0FF;
  }

  $rect <20,20,160,60>
  object Core::WipeTouchHandler WipeUp
  {
    preset Bounds = <0,430,640,479>;
    preset OnTop = WipeUpSlot;
  }

  $rect <20,20,160,60>
  object Core::WipeTouchHandler WipeLeft
  {
    preset Bounds = <550,43,640,479>;
    preset OnLeft = WipeLeftSlot;
    preset RetargetCondition = Core::RetargetReason[WipeDown, WipeUp];
  }

  $rect <20,20,160,60>
  object Core::WipeTouchHandler WipeRight
  {
    preset Bounds = <0,141,90,478>;
    preset OnRight = WipeRightSlot;
    preset RetargetCondition = Core::RetargetReason[WipeDown, WipeUp];
  }

  $rect <20,20,160,60>
  object Clock::MonthList MonthList
  {
    preset Bounds = <0,39,311,400>;
    preset OnSelected = OnSelectedCalendar;
  }

  $rect <20,20,160,60>
  object Clock::TimePicker TimePicker
  {
    preset Bounds = <350,43,598,240>;
    preset OnTimeChanged = OnSelectedTime;
    preset TimeColor = #FAE9E0FF;
  }

  $rect <680,190,880,230>
  slot WipeLeftSlot
  {
    Owner.SwitchToDialog(new Clock::TimerScreen, Effects::SlideLeftCentered, null, null, null, null, null, null, null, null, false );
  }

  $rect <680,150,880,190>
  slot WipeRightSlot
  {
    Owner.SwitchToDialog(new Clock::ChronometerScreen, Effects::SlideRightCentered, null, null, null, null, null, null, null, null, false );
  }

  // Touch Screen Events
  note group Note
  {
    attr Bounds = <670,110,890,280>;
  }

  // Calendar Date Selection
  note group Note1
  {
    attr Bounds = <890,110,1110,320>;
  }

  // Button Press Events
  note group Note2
  {
    attr Bounds = <1111,110,1331,200>;
  }
}

// This class implements a 'radio button' widget. When the user presses the button, \
// the current value of the button represented by the property @Selected is set and \
// a signal is sent to the slot method stored in the property @OnSelect. Once selected, \
// the radio button remains in this state until the property @Selected is set to \
// the value 'false' (e.g. in reaction to another radio button selection).
// Alternatively the property @Outlet can refer to any other 'int32' property the \
// widget should remain synchronized with. When the user selects the radio button, \
// the affected property is automatically set to the value @OutletSelector. On the \
// other hand, when the referred property is modified by another one, the radio button \
// is automatically notified to remain in sync with the property.
// This approach follows the Model-View-Controller (MVC) programming paradigm. Here \
// the radio button represents the 'View' and 'Controller' and the property referred \
// via 'Outlet' can be seen as a part of the 'Model'.
$rect <100,470,300,510>
$output false
class WeekButtonList : Templates::List
{
  $rect <440,0,640,40>
  inherited property Bounds = <0,0,418,59>;

  $rect <440,50,640,90>
  array bool SelectedDays[ 7 ] =
  (
    Default[0] = false;
    Default[1] = false;
    Default[2] = false;
    Default[3] = false;
    Default[4] = false;
    Default[5] = false;
    Default[6] = false;
  );

  $rect <450,140,650,180>
  slot OnSelect
  {
    var Clock::WeekButton selectedDay = (Clock::WeekButton)sender;

    if(selectedDay.WeekDay< 0 ||  selectedDay.WeekDay> 6)
      return;

    SelectedDays[selectedDay.WeekDay]=true;
  }

  $rect <450,180,650,220>
  slot OnDeselect
  {
    var Clock::WeekButton selectedDay = (Clock::WeekButton)sender;

    SelectedDays[selectedDay.WeekDay]=false;
  }

  $rect <20,20,160,60>
  object Core::HorizontalList HorizontalList
  {
    preset Bounds = <0,0,418,59>;
    preset OnLoadItem = OnLoadItem;
    preset ItemWidth = 60;
    preset NoOfItems = 10;
    preset ItemClass = Clock::WeekButton;
  }

  // This method is called by 'HorizontalList' every time the list loads or updates \
  // an item.
  $rect <680,140,880,180>
  slot OnLoadItem
  {
    /*

      Hint:

      - The code below demonstrates a simple usage of the list component.

      - The list component creates and manages automatically view item instances of
        the class specified in its property 'ItemClass'. In this example it is the
        class 'Views::Image'.

      - When you change the 'ItemClass' property you will also need to replace
        accordingly all 'Views::Image' occurrences in the below code.

      - You will also need to adapt the initialization of the 'itemView'.

    */

    // Get the number of the item to load. The list component takes care of the
    // creation of the corresponding item view. Just access it ...
    var int32        itemNo   = HorizontalList.Item;
    var Clock::WeekButton itemView = (Clock::WeekButton)HorizontalList.View;

    // The implementation of this slot method does not match the item class
    // specified in the associated list component. Or the slot method is not
    // called in context of the OnLoadItem list operation. 
    if ( itemView == null )
      return;

    // Configure the item view ...
    itemView.WeekDay=itemNo;
    itemView.OnDeselected=OnDeselect;
    itemView.OnSelected=OnSelect;

    // Ensure that the item has correct size. The position of the item will be
    // managed by the list component.
    itemView.Bounds.size = point( HorizontalList.ItemWidth, HorizontalList.Bounds.h );
  }

  // Button Press Events
  note group Note
  {
    attr Bounds = <440,100,660,230>;
  }

  // List Management
  note group Note1
  {
    attr Bounds = <670,100,890,190>;
  }

  $reorder SelectedDays 2
  $reorder OnSelect 2
  $reorder OnDeselect 2
  $reorder HorizontalList 2
}

// This class implements a 'push button' widget. When the user presses the button, \
// a signal is sent to the slot method stored in its @OnActivate property.
$rect <100,510,299,550>
$output false
class WeekButton : WidgetSet::ToggleButton
{
  $rect <80,-10,280,30>
  inherited property Bounds = <0,0,60,60>;

  $rect <80,40,280,80>
  inherited method UpdateViewState()
  {
    super(aState);

    var bool isChecked  = Checked;

    if(isChecked)
      Caption.Color=#8FFFF5FF;
    else
      Caption.Color=#FFFFFFFF;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Bounds = <-2,0,60,59>;
    preset Color = #4D578428;
    preset Visible = true;
  }

  $rect <20,20,160,60>
  object Views::Bevel Bevel
  {
    preset Bounds = <0,0,60,59>;
    preset Width = 4;
    preset ColorL = #1D243828;
    preset ColorR = #1D243881;
    preset ColorB = #1D243881;
    preset ColorT = #1D243828;
  }

  $rect <20,20,160,60>
  object Views::Text Caption
  {
    preset Bounds = <5,0,53,59>;
    preset String = "Sun";
    preset Font = Clock::SmallFont;
    preset Color = #FAE9E0FF;
  }

  $rect <81,90,281,130>
  property int32 WeekDay;

  $rect <81,130,281,170>
  onset WeekDay
  {
    // The value doesn't change - nothing to do.
    if ( pure WeekDay == value )
      return;

    // Remember the property's new value.
    pure WeekDay = value;

    Caption.String=Clock::Time.getDayOfWeekName( value, true );
  }

  $rect <81,170,281,210>
  onget WeekDay
  {
    return pure WeekDay;
  }

  $rect <290,90,490,130>
  property slot OnSelected;

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler SimpleTouchHandler
  {
    preset Point4 = <4,0>;
    preset Point3 = <53,0>;
    preset Point2 = <53,59>;
    preset Point1 = <4,59>;
    preset OnPress = OnPressed;
  }

  $rect <90,259,290,299>
  slot OnPressed
  {
    Checked = !Checked;

    if ( Checked ) 
      postsignal OnSelected;
    else           
      postsignal OnDeselected;

  }

  $rect <290,130,490,170>
  property slot OnDeselected;

  $rect <20,20,160,60>
  object Views::Line Line
  {
    preset Point2 = <59,59>;
    preset Point1 = <0,59>;
    preset Width = 3;
    preset Color = #FAE9E0FF;
  }

  // Touch Screen Events
  note group Note3
  {
    attr Bounds = <79,219,300,310>;
  }
}

$rect <580,219,769,259>
$output false
autoobject Core::Time Time;

// This class implements the item component for the Clock::ListBox widget. You will \
// probably never need to directly instantiate and control this item component.
$rect <-130,499,70,539>
$output false
class WeekItem : Templates::ListItem
{
  $rect <350,0,550,40>
  inherited property Bounds = <0,0,315,40>;

  $rect <350,200,550,240>
  method void FillButtons( arg Core::Time time )
  {
    var Core::TimeSpan span=Clock::TimeSpan.Initialize2( 1, 0, 0, 0 );
    var int32 index;

    for(index=0;index<7;index++)
      { 
        Days[index]=time;
        time=time.Add(span);  
      }

    HorizontalList.InvalidateItems( 0, 6 );
                            
  }

  $rect <20,20,160,60>
  object Core::HorizontalList HorizontalList
  {
    preset Bounds = <0,0,315,40>;
    preset OnLoadItem = OnLoadItem;
    preset ItemWidth = 45;
    preset NoOfItems = 7;
    preset ItemClass = Clock::DayButton;
  }

  // This method is called by 'HorizontalList' every time the list loads or updates \
  // an item.
  $rect <360,140,560,180>
  slot OnLoadItem
  {
    var int32        itemNo   = HorizontalList.Item;
    var Clock::DayButton itemView = (Clock::DayButton)HorizontalList.View;
     
    if ( itemView == null )
      return;

    itemView.Date=Days[itemNo];  
    itemView.OnSelected=ItemSelected;

    itemView.Bounds.size = point( HorizontalList.ItemWidth, HorizontalList.Bounds.h );
  }

  $rect <560,50,760,90>
  array Core::Time Days[ 7 ] =
  (
    Default[0] = Clock::Time;
    Default[1] = Clock::Time;
    Default[2] = Clock::Time;
    Default[3] = Clock::Time;
    Default[4] = Clock::Time;
    Default[5] = Clock::Time;
    Default[6] = Clock::Time;
  );

  $rect <350,240,550,280>
  method Core::Time GetDate( arg int32 index )
  {
    return Days[index];
  }

  // The property 'Bounds' defines the position and the size of the view in the coordinates \
  // of the corresponding @Owner.
  $rect <350,50,550,90>
  property slot OnSelected = null;

  $rect <590,140,790,180>
  slot ItemSelected
  {
    var Clock::DayButton button=(Clock::DayButton)sender;

    Selected=button.Date;

    postsignal OnSelected;
  }

  $rect <1280,10,1480,50>
  property Core::Time Selected = null;

  // List Management
  note group Note
  {
    attr Bounds = <350,100,570,190>;
  }

  // Day Button Press Event
  note group Note1
  {
    attr Bounds = <580,100,800,190>;
  }
}

// This class implements a 'push button' widget. When the user presses the button, \
// a signal is sent to the slot method stored in its @OnActivate property.
$rect <-130,539,70,579>
$output false
class DayButton : Templates::PushButton
{
  $rect <80,-10,280,30>
  inherited property Bounds = <0,0,45,40>;

  $rect <290,-10,490,30>
  inherited method UpdateViewState()
  {
    super(aState);

    var bool isEnabled  = aState.contains( Core::ViewState[ Enabled ]);

    if(isEnabled)
    {
      SimpleTouchHandler.Enabled=true;
      Rectangle.Visible=false;
      
      var Core::Time current=Clock::Time.CurrentTime;

      if(Date.Time/86400==current.Time/86400) 
        Caption.Color=#67DCFFFF;
      else 
        Caption.Color=#FAE9E0FF;
    }
    else
    {
      SimpleTouchHandler.Enabled=false;
      Rectangle.Visible=true;

      Caption.Color=#404D6344;
    }
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Bounds = <-2,0,43,40>;
    preset Color = #1D243828;
    preset Visible = false;
  }

  $rect <20,20,160,60>
  object Views::Text Caption
  {
    preset Bounds = <-2,0,43,40>;
    preset String = " ";
    preset Font = Clock::SmallFont;
    preset Color = #FAE9E0FF;
  }

  $rect <80,50,280,90>
  property Core::Time Date = Clock::Time;

  $rect <80,90,280,130>
  onset Date
  {
    if ( pure Date == value )
      return;

    pure Date = value;

    Caption.String=string(value.Day,2);

    if(value.Month==Clock::CalendarTime.Month)
      Enabled=true;
    else
      Enabled=false;

  }

  $rect <80,130,280,170>
  onget Date
  {
    return pure Date;
  }

  $rect <290,50,490,90>
  property slot OnSelected;

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler SimpleTouchHandler
  {
    preset Point4 = <5,4>;
    preset Point3 = <33,4>;
    preset Point2 = <33,36>;
    preset Point1 = <5,36>;
    preset OnLeave = null;
    preset OnRelease = OnReleased;
    preset OnPress = OnPressed;
    preset RetargetCondition = Core::RetargetReason[];
  }

  $rect <90,230,290,270>
  slot OnPressed
  {
    Rectangle.Visible=true;
    postsignal OnSelected;

  }

  $rect <20,20,160,60>
  object Views::Line Line
  {
    preset Point2 = <45,40>;
    preset Point1 = <-4,40>;
    preset Width = 3;
    preset Color = #FAE9E0FF;
  }

  $rect <20,20,160,60>
  object Views::Line Line1
  {
    preset Point2 = <45,0>;
    preset Point1 = <-4,0>;
    preset Width = 3;
  }

  // Touch Handler Events
  note group Note
  {
    attr Bounds = <80,190,300,320>;
  }

  $rect <90,270,290,310>
  slot OnReleased
  {
    Rectangle.Visible=false;
  }
}

// This class implements the Clock::ListBox widget. This widget is intended to display \
// a list of options and permit the user to select the desired option. Selecting \
// the option sends a signal to the slot method stored in the property @OnSelect.
// Alternatively the property @Outlet can refer to any other 'int32' property the \
// widget should remain synchronized with. When the user selects an option, the affected \
// property is automatically updated to reflect the number of the selected option. \
// On the other hand, when the referred property is modified by another one, the \
// ListBox is automatically notified to remain in sync with the property.
// The total number of available ListBox items (the number of options) is determined \
// by the property @NoOfItems. Which option is actually selected is controlled by \
// the property @SelectedItem.
// The items are loaded dynamically at the runtime. For this purpose a slot method \
// has to be implemented and assigned to the @OnLoadItem property. The ListBox will \
// invoke the slot method automatically each time it needs an item to be loaded. \
// Within the slot method the implementation can access and initialize the affected \
// item by using the variable @View.
// In order to trigger the list to reload one or more items, invoke the method @InvalidateItems(). \
// The list box will thereupon schedule the necessary loading steps automatically.
$rect <-130,459,70,499>
$output false
class MonthList : Templates::List
{
  $rect <370,30,570,70>
  inherited method Init()
  {
    Clock::CalendarTime.Time = Clock::Time.CurrentTime.Time;
    Clock::CalendarTime.Day=1;


    Month=Clock::CalendarTime.Month;
    Year=Clock::CalendarTime.Year;


  }

  $rect <370,-10,570,30>
  inherited property Bounds = <0,0,311,361>;

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Bounds = <0,0,311,121>;
    preset Color = #0F1E3528;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle1
  {
    preset Bounds = <0,0,311,44>;
    preset Color = #0F1E3528;
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <-1,91,44,121>;
    preset String = "Su";
    preset Font = Clock::SmallFont;
    preset Color = #FAE9E0FF;
  }

  $rect <20,20,160,60>
  object Views::Text Text1
  {
    preset Bounds = <44,91,89,121>;
    preset String = "M";
    preset Font = Clock::SmallFont;
    preset Color = #FAE9E0FF;
  }

  $rect <20,20,160,60>
  object Views::Text Text2
  {
    preset Bounds = <89,91,134,121>;
    preset String = "Tu";
    preset Font = Clock::SmallFont;
    preset Color = #FAE9E0FF;
  }

  $rect <20,20,160,60>
  object Views::Text Text3
  {
    preset Bounds = <134,91,179,121>;
    preset String = "W";
    preset Font = Clock::SmallFont;
    preset Color = #FAE9E0FF;
  }

  $rect <20,20,160,60>
  object Views::Text Text4
  {
    preset Bounds = <179,91,224,121>;
    preset String = "Th";
    preset Font = Clock::SmallFont;
    preset Color = #FAE9E0FF;
  }

  $rect <20,20,160,60>
  object Views::Text Text5
  {
    preset Bounds = <224,91,269,121>;
    preset String = "F";
    preset Font = Clock::SmallFont;
    preset Color = #FAE9E0FF;
  }

  $rect <20,20,160,60>
  object Views::Text Text6
  {
    preset Bounds = <269,91,314,121>;
    preset String = "Sa";
    preset Font = Clock::SmallFont;
    preset Color = #FAE9E0FF;
  }

  $rect <20,20,160,60>
  object Views::Image Image
  {
    preset Bounds = <0,0,50,44>;
    preset Color = #FAE9E0FF;
    preset FrameNumber = 2;
    preset Bitmap = Resources::NavigationIconsMedium;
  }

  $rect <20,20,160,60>
  object Views::Image Image1
  {
    preset Bounds = <261,0,311,44>;
    preset Color = #FAE9E0FF;
    preset FrameNumber = 3;
    preset Bitmap = Resources::NavigationIconsMedium;
  }

  $rect <20,20,160,60>
  object Core::VerticalList VerticalList
  {
    preset Bounds = <-1,121,311,361>;
    preset OnLoadItem = OnLoadItem;
    preset Endless = false;
    preset SlideHandler = null;
    preset ScrollOffset = 0;
    preset ItemHeight = 40;
    preset NoOfItems = 6;
    preset ItemClass = Clock::WeekItem;
  }

  // This method is called by 'VerticalList1' every time the list loads or updates \
  // an item.
  $rect <380,270,580,310>
  slot OnLoadItem
  {
    /*

      Hint:

      - The code below demonstrates a simple usage of the list component.

      - The list component creates and manages automatically view item instances of
        the class specified in its property 'ItemClass'. In this example it is the
        class 'Views::Text'.

      - When you change the 'ItemClass' property you will also need to replace
        accordingly all 'Views::Text' occurrences in the below code.

      - You will also need to adapt the initialization of the 'itemView'.

    */

    // Get the number of the item to load. The list component takes care of the
    // creation of the corresponding item view. Just access it ...
    var int32       itemNo   = VerticalList.Item;
    var Clock::WeekItem itemView = (Clock::WeekItem)VerticalList.View;

    // The implementation of this slot method does not match the item class
    // specified in the associated list component. Or the slot method is not
    // called in context of the OnLoadItem list operation. 
    if ( itemView == null )
      return;

    // Configure the item view ...                                                     
    itemView.FillButtons(FitToDayOfWeek(Clock::CalendarTime).Add( Clock::TimeSpan.Initialize2( 7*itemNo,0,0,0 )));
    itemView.OnSelected=ItemSelected;
    // Ensure that the item has correct size. The position of the item will be
    // managed by the list component.
    itemView.Bounds.size = point( VerticalList.Bounds.w, VerticalList.ItemHeight );
  }

  $rect <370,411,570,451>
  method Core::Time FitToDayOfWeek( arg Core::Time time )
  {
    return time.Subtract( Clock::TimeSpan.Initialize2( time.DayOfWeek, 0, 0, 0 ) );
  }

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler Next
  {
    preset Point4 = <156,0>;
    preset Point3 = <312,0>;
    preset Point2 = <312,44>;
    preset Point1 = <156,44>;
    preset OnDrag = null;
    preset OnEnter = null;
    preset OnPress = OnNext;
    preset RetargetOffset = 8;
    preset RetargetCondition = Core::RetargetReason[];
  }

  $rect <610,270,810,310>
  slot OnNext
  {
    if(Month==12 && Year==9999) return;
    Month++;

    UpdateCalendarTime();

    VerticalList.InvalidateItems( 0, 5 );
  }

  $rect <370,90,570,130>
  property int32 Month;

  $rect <370,130,570,170>
  onset Month
  {
    // The value doesn't change - nothing to do.
    if ( pure Month == value )
      return;

    // Remember the property's new value.

    pure Month = value;
    if(Month>12) 
    {
      Month=1;
      Year++;
    }
    if(Month<1)
    {
      Month=12;
      Year--;
    }

    MonthList.ScrollOffset=-157*(Month-1);

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <370,170,570,210>
  onget Month
  {
    return pure Month;
  }

  $rect <580,90,780,130>
  property int32 Year;

  $rect <580,130,780,170>
  onset Year
  {
    // The value doesn't change - nothing to do.
    if ( pure Year == value )
      return;

    // Remember the property's new value.
    pure Year = value;

    YearList.ScrollOffset=-157*(Year-1970);

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <580,170,780,210>
  onget Year
  {
    return pure Year;
  }

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler Prev
  {
    preset Point4 = <0,0>;
    preset Point3 = <156,0>;
    preset Point2 = <156,44>;
    preset Point1 = <0,44>;
    preset OnDrag = null;
    preset OnHold = null;
    preset OnPress = OnPrev;
    preset RetargetDelay = 1000;
    preset RetargetOffset = 8;
    preset RetargetCondition = Core::RetargetReason[WipeRight];
  }

  $rect <610,310,810,350>
  slot OnPrev
  {
    if(Month==1 && Year==1970) return;
    Month--;

    UpdateCalendarTime();

    VerticalList.InvalidateItems( 0, 5 );
  }

  // The property 'Bounds' defines the position and the size of the view in the coordinates \
  // of the corresponding @Owner.
  $rect <790,130,990,170>
  property slot OnSelected = null;

  $rect <839,310,1039,350>
  slot ItemSelected
  {
    var Clock::WeekItem item =(Clock::WeekItem)sender;
    SelectedDate=item.Selected;
    postsignal OnSelected;
  }

  $rect <790,90,990,130>
  property Core::Time SelectedDate = null;

  $rect <20,20,160,60>
  object Core::HorizontalList YearList
  {
    preset Bounds = <-2,44,155,91>;
    preset OnLoadItem = OnLoadYearItem;
    preset SlideHandler = YearSlideHandler;
    preset ItemWidth = 157;
    preset NoOfItems = 10000;
    preset ItemClass = Views::Text;
  }

  // This method is called by 'HorizontalList' every time the list loads or updates \
  // an item.
  $rect <380,310,580,350>
  slot OnLoadYearItem
  {
    /*

      Hint:

      - The code below demonstrates a simple usage of the list component.

      - The list component creates and manages automatically view item instances of
        the class specified in its property 'ItemClass'. In this example it is the
        class 'Views::Image'.

      - When you change the 'ItemClass' property you will also need to replace
        accordingly all 'Views::Image' occurrences in the below code.

      - You will also need to adapt the initialization of the 'itemView'.

    */

    // Get the number of the item to load. The list component takes care of the
    // creation of the corresponding item view. Just access it ...
    var int32        itemNo   = YearList.Item;
    var Views::Text itemView = (Views::Text)YearList.View;

    // The implementation of this slot method does not match the item class
    // specified in the associated list component. Or the slot method is not
    // called in context of the OnLoadItem list operation. 
    if ( itemView == null )
      return;

    itemView.String=string(1970+itemNo);
    itemView.Color=#FAE9E0FF;
    itemView.Font=Clock::SmallFont;

    // Ensure that the item has correct size. The position of the item will be
    // managed by the list component.
    itemView.Bounds.size = point( YearList.ItemWidth, YearList.Bounds.h );
  }

  $rect <20,20,160,60>
  object Core::HorizontalList MonthList
  {
    preset Bounds = <155,44,310,91>;
    preset OnLoadItem = OnLoadMonthItem;
    preset Endless = true;
    preset SlideHandler = MonthSlideHandler;
    preset ItemWidth = 157;
    preset NoOfItems = 12;
    preset ItemClass = Views::Text;
  }

  // This method is called by 'HorizontalList' every time the list loads or updates \
  // an item.
  $rect <380,350,580,390>
  slot OnLoadMonthItem
  {
    /*

      Hint:

      - The code below demonstrates a simple usage of the list component.

      - The list component creates and manages automatically view item instances of
        the class specified in its property 'ItemClass'. In this example it is the
        class 'Views::Image'.

      - When you change the 'ItemClass' property you will also need to replace
        accordingly all 'Views::Image' occurrences in the below code.

      - You will also need to adapt the initialization of the 'itemView'.

    */

    // Get the number of the item to load. The list component takes care of the
    // creation of the corresponding item view. Just access it ...
    var int32        itemNo   = MonthList.Item;
    var Views::Text itemView = (Views::Text)MonthList.View;


    if ( itemView == null )
      return;

    itemView.String=Clock::Time.getMonthName(itemNo+1,true);
    itemView.Color=#FAE9E0FF;
    itemView.Font=Clock::SmallFont;

    // Ensure that the item has correct size. The position of the item will be
    // managed by the list component.
    itemView.Bounds.size = point( YearList.ItemWidth, YearList.Bounds.h );
  }

  $rect <20,20,160,60>
  object Core::SlideTouchHandler YearSlideHandler
  {
    preset Bounds = <1,44,156,91>;
    preset MinOffset = <157,0>;
    preset OnEnd = OnGetYearMonthItem;
    preset SnapNext = <157,0>;
  }

  $rect <20,20,160,60>
  object Core::SlideTouchHandler MonthSlideHandler
  {
    preset Bounds = <156,44,311,91>;
    preset MinOffset = <157,0>;
    preset OnEnd = OnGetYearMonthItem;
    preset SnapNext = <157,0>;
  }

  $rect <839,270,1039,310>
  slot OnGetYearMonthItem
  {
    Year = 1970+YearList.GetItemAtPosition( <76,67> );
    Month = MonthList.GetItemAtPosition( <233,67> ) + 1;

    UpdateCalendarTime();

    VerticalList.InvalidateItems( 0, 5 );
  }

  $rect <20,20,160,60>
  object Views::Bevel Bevel
  {
    preset Bounds = <155,0,311,44>;
    preset Width = 2;
    preset ColorL = #FFFFFF3A;
    preset ColorR = #FFFFFF72;
    preset ColorB = #FFFFFF72;
    preset ColorT = #FFFFFF3A;
  }

  $rect <20,20,160,60>
  object Views::Bevel Bevel1
  {
    preset Bounds = <0,0,155,44>;
    preset Width = 2;
    preset ColorL = #FFFFFF3A;
    preset ColorR = #FFFFFF72;
    preset ColorB = #FFFFFF72;
    preset ColorT = #FFFFFF3A;
  }

  $rect <370,450,570,490>
  method void UpdateCalendarTime()
  {
    Clock::CalendarTime.Month=Month;
    Clock::CalendarTime.Year=Year;
  }

  // List Management
  note group Note
  {
    attr Bounds = <370,230,590,400>;
  }

  // Button Press Events
  note group Note1
  {
    attr Bounds = <599,230,820,359>;
  }

  // Calendar Date Selection
  note group Note2
  {
    attr Bounds = <830,230,1051,359>;
  }
}

$rect <580,259,770,299>
$output false
autoobject Core::TimeSpan TimeSpan;

$rect <580,299,769,339>
$output false
autoobject Core::Time CalendarTime;

// Screens
note group Note
{
  attr Bounds = <-139,0,99,390>;
}

$rect <99,640,299,680>
$output false
class EventItemComponent : Core::Group
{
  $rect <0,119,200,159>
  inherited property Bounds = rect(0,0,$ScreenSize.x,100);

  $rect <0,159,200,199>
  inherited property Visible = true;

  $rect <0,369,200,409>
  property Resources::Bitmap Icon;

  $rect <0,409,200,449>
  onset Icon
  {
    // The value doesn't change - nothing to do.
    if ( pure Icon == value )
      return;

    // Remember the property's new value.
    pure Icon = value;

    Image.Bitmap=value;
    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <0,449,200,489>
  onget Icon
  {
    return pure Icon;
  }

  $rect <210,369,410,409>
  property string Caption;

  $rect <210,409,410,449>
  onset Caption
  {
    // The value doesn't change - nothing to do.
    if ( pure Caption == value )
      return;

    // Remember the property's new value.
    pure Caption = value;

    Text.String=value;
  }

  $rect <210,449,410,489>
  onget Caption
  {
    return pure Caption;
  }

  $rect <0,220,200,260>
  property int64 TriggerTime;

  $rect <0,260,200,300>
  onset TriggerTime
  {
    // The value doesn't change - nothing to do.
    if ( pure TriggerTime == value )
      return;

    // Remember the property's new value.
    pure TriggerTime = value;

    Text1.String=Clock::Time.Initialize( TriggerTime ).String;
    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <0,300,200,340>
  onget TriggerTime
  {
    return pure TriggerTime;
  }

  $rect <20,20,160,60>
  object Core::Outline Outline
  {
    preset Bounds = <0,0,640,100>;
    preset SlideHandler = SlideTouchHandler;
    preset ScrollOffset = <0,0>;
    preset Formation = Core::Formation.None;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle1
  {
    preset Bounds = <0,0,502,100>;
    preset ColorBR = #FFFFFF00;
    preset ColorTR = #FFFFFF00;
    preset Color = #2760807B;
    preset Embedded = true;
  }

  $rect <20,20,160,60>
  object Views::Image Image
  {
    preset Bounds = <0,0,100,100>;
    preset Color = #FAE9E0FF;
    preset Bitmap = Resources::DefaultBitmap;
    preset Embedded = true;
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <100,0,640,50>;
    preset String = "Caption";
    preset Font = Clock::SmallFont;
    preset Color = #FAE9E0FF;
    preset Embedded = true;
  }

  $rect <20,20,160,60>
  object Views::Text Text1
  {
    preset Bounds = <100,50,640,100>;
    preset Alignment = Views::TextAlignment[AlignHorzAuto, AlignHorzCenter, AlignVertCenter];
    preset String = "Caption";
    preset Font = Clock::SmallFont;
    preset Color = #FAE9E0FF;
    preset Embedded = true;
  }

  $rect <420,369,620,409>
  property int32 ImageFrame;

  $rect <420,409,620,449>
  onset ImageFrame
  {
    // The value doesn't change - nothing to do.
    if ( pure ImageFrame == value )
      return;

    // Remember the property's new value.
    pure ImageFrame = value;

    Image.FrameNumber=ImageFrame;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <420,449,620,489>
  onget ImageFrame
  {
    return pure ImageFrame;
  }

  $rect <210,220,410,260>
  property int32 Index;

  $rect <210,260,410,300>
  onset Index
  {
    // The value doesn't change - nothing to do.
    if ( pure Index == value )
      return;

    // Remember the property's new value.
    pure Index = value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <210,300,410,340>
  onget Index
  {
    return pure Index;
  }

  $rect <20,20,160,60>
  object Clock::SlideTouchHandler SlideTouchHandler
  {
    preset Bounds = <0,0,640,100>;
    preset MaxOffset = <0,0>;
    preset MinOffset = <0,0>;
    preset Offset = <0,0>;
    preset OnSlide = OnSlide;
    preset OnEnd = OnEndSlider;
    preset OnStart = null;
    preset SlideVert = false;
    preset RubberBandScrolling = true;
  }

  $rect <10,589,210,629>
  slot OnEndSlider
  {
    if(SlideTouchHandler.Offset.x>SlideTouchHandler.Bounds.w/2)
      {
        Clock::Device.RemoveEvent( Index );
      }  
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Bounds = <0,0,0,100>;
    preset Color = #4FA8C300;
  }

  $rect <10,550,210,590>
  slot OnSlide
  {
    Rectangle.Bounds.w=SlideTouchHandler.Offset.x;
    Image1.Bounds.w=SlideTouchHandler.Offset.x;
    var int32 value=(SlideTouchHandler.Offset.x<=0)?0:SlideTouchHandler.Offset.x*255/(SlideTouchHandler.Bounds.w/2);
    Rectangle.Color.alpha=uint8(value>255?255:value);
    Image1.Opacity=uint8(value>255?255:value);


  }

  $rect <20,20,160,60>
  object Views::Image Image1
  {
    preset Bounds = <0,0,0,100>;
    preset Color = #FAE9E0FF;
    preset Alignment = Views::ImageAlignment[AlignHorzLeft, AlignVertCenter];
    preset FrameNumber = 4;
    preset Bitmap = Resources::SymbolIconsExtraLarge;
    preset Opacity = 0;
  }

  $rect <0,660,200,700>
  method void Reset()
  {
    SlideTouchHandler.Offset=<0,0>;
    Outline.ScrollOffset=<0,0>;
    Image1.Opacity=0;
    Image1.Bounds.w=0;
    Rectangle.Color=#A35C6E00;
    Rectangle.Bounds.w=0;
  }

  // Touch Handler Events
  note group Note
  {
    attr Bounds = <0,510,220,640>;
  }
}

$rect <-118,320,82,360>
$output false
class RunningEvents : Core::Group
{
  $rect <700,130,900,170>
  inherited property Bounds = <0,0,640,522>;

  $rect <710,370,910,410>
  slot WipeUpSlot
  {
    var Clock::Base owner=(Clock::Base) Owner;
    owner.SlideUp.Enabled=true;
    owner.PresentDialog(new Clock::ClockScreen, Effects::SlideUpCentered, null, null, null, null, null, null, null, false );

  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Bounds = <0,0,640,480>;
    preset Color = #1D243858;
    preset Visible = true;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle1
  {
    preset Bounds = <0,439,640,480>;
    preset ColorBL = #0F1E35FF;
    preset ColorBR = #0F1E35FF;
    preset ColorTR = #0F1E3553;
    preset ColorTL = #0F1E3553;
  }

  $rect <20,20,160,60>
  object Views::Image Image
  {
    preset Bounds = <295,430,345,480>;
    preset Color = #ecdfcfFF;
    preset Bitmap = Resources::NavigationIconsMedium;
    preset Visible = true;
  }

  $rect <20,20,160,60>
  object Core::WipeTouchHandler WipeUp
  {
    preset Bounds = <0,430,640,479>;
    preset OnTop = WipeUpSlot;
    preset Enabled = true;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle2
  {
    preset Bounds = <0,480,640,521>;
    preset ColorBL = #FFFFFFFF;
    preset ColorBR = #FFFFFFFF;
    preset ColorTR = #FFFFFFFF;
    preset ColorTL = #FFFFFFFF;
    preset Color = #0F1E35FF;
  }

  $rect <20,20,160,60>
  object Core::HorizontalList HorizontalList
  {
    preset Bounds = <0,480,640,522>;
    preset OnLoadItem = OnLoadHorizontalList;
    preset ItemWidth = 60;
    preset NoOfItems = 0;
    preset ItemClass = Views::Image;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle3
  {
    preset Bounds = <0,480,480,522>;
    preset ColorBL = #FFFFFF00;
    preset ColorBR = #FFFFFFFF;
    preset ColorTR = #FFFFFFFF;
    preset ColorTL = #FFFFFF00;
    preset Color = #0F1E35FF;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle4
  {
    preset Bounds = <480,480,640,522>;
    preset ColorBL = #FFFFFFFF;
    preset ColorBR = #FFFFFFFF;
    preset ColorTR = #FFFFFFFF;
    preset ColorTL = #FFFFFFFF;
    preset Color = #0F1E35FF;
  }

  // This method is called by 'HorizontalList' every time the list loads or updates \
  // an item.
  $rect <710,230,910,270>
  slot OnLoadHorizontalList
  {
    var int32        itemNo   = HorizontalList.Item;
    var Views::Image itemView = (Views::Image)HorizontalList.View;

    if ( itemView == null )
      return;

    var Clock::Event event= Clock::Device.GetEvent( itemNo );

    itemView.Bitmap=Clock::IconsSmall;

    switch(event.Type)
    {
      case Clock::EventType.Alarm:
        itemView.FrameNumber=2;
      case Clock::EventType.Calendar:
        itemView.FrameNumber=3;
      default:;
    }


    itemView.Bounds.size = point( HorizontalList.ItemWidth, HorizontalList.Bounds.h );
  }

  $rect <20,20,160,60>
  object Core::VerticalList VerticalList
  {
    preset Bounds = <0,0,640,430>;
    preset OnLoadItem = OnLoadVerticalList;
    preset SlideHandler = SlideTouchHandler;
    preset ItemHeight = 110;
    preset NoOfItems = 0;
    preset ItemClass = Clock::EventItemComponent;
  }

  $rect <20,20,160,60>
  object Core::SlideTouchHandler SlideTouchHandler
  {
    preset Bounds = <0,0,640,430>;
    preset SlideHorz = false;
    preset RetargetCondition = Core::RetargetReason[WipeRight];
    preset Enabled = true;
  }

  // This method is called by 'VerticalList' every time the list loads or updates \
  // an item.
  $rect <710,270,910,310>
  slot OnLoadVerticalList
  {
    var int32       itemNo   = VerticalList.Item;
    var Clock::EventItemComponent itemView = (Clock::EventItemComponent)VerticalList.View;

    if ( itemView == null )
      return;

    // Configure the item view ...

    var Clock::Event event= Clock::Device.GetEvent( itemNo );

    itemView.Reset();
    itemView.Icon=Clock::IconsLarge;
    itemView.TriggerTime=event.TriggerTime+event.Snooze;
    itemView.Index=itemNo;                

    switch(event.Type)
    {
      case Clock::EventType.Alarm:
      {
        itemView.Caption="Alarm Event";
        if(event.IsScheduled) itemView.Caption+=" [Scheduled]";
        itemView.ImageFrame=2;
      }
      case Clock::EventType.Calendar:
      {
        itemView.Caption="Calendar Event";
        itemView.ImageFrame=3;
      }
      default:;
    }

    if(event.Snooze>0) itemView.Caption+=" [Reminder]";

    itemView.Bounds.size = point( VerticalList.Bounds.w, VerticalList.ItemHeight );
  }

  $rect <960,230,1160,270>
  object Core::SystemEventHandler SystemEventHandler
  {
    preset OnEvent = onEvent;
    preset Event = Clock::Device.EventChanged;
  }

  // This slot method is executed when the associated system event handler 'SystemEventHandler' \
  // receives an event.
  $rect <960,270,1160,310>
  slot onEvent
  {
    var int32 eventNo=Clock::Device.GetEventsCount();
    VerticalList.NoOfItems=eventNo;
    HorizontalList.NoOfItems=eventNo;

    VerticalList.InvalidateItems( 0, VerticalList.NoOfItems );
    HorizontalList.InvalidateItems( 0, HorizontalList.NoOfItems );

  }

  $rect <20,20,160,60>
  object Views::Border Border
  {
    preset Bounds = <0,439,640,479>;
    preset Color = #0F1E358C;
  }

  // Time Event Change Handler
  note group Note
  {
    attr Bounds = <930,190,1190,320>;
  }

  // List Management
  note group Note1
  {
    attr Bounds = <700,190,920,320>;
  }

  // Touch Handler Events
  note group Note2
  {
    attr Bounds = <700,330,919,420>;
  }

  $reorder UpdateViewState 1
  $reorder InvalidateLayout 1
  $reorder InvalidateViewState 1
  $reorder InvalidateArea 1
  $reorder GetIndexOfView 1
  $reorder GetViewAtIndex 1
  $reorder CountViews 1
  $reorder FindViewInDirection 1
  $reorder FindViewWithinArea 1
  $reorder FindViewAtPosition 1
  $reorder FindPrevView 1
  $reorder FindNextView 1
  $reorder FindSiblingView 1
  $reorder GetContentArea 1
  $reorder FadeGroup 1
  $reorder RestackBehind 1
  $reorder RestackBack 1
  $reorder RestackTop 1
  $reorder Restack 1
  $reorder RemoveAll 1
  $reorder Remove 1
  $reorder AddBehind 1
  $reorder Add 1
  $reorder Focus 1
  $reorder Buffered 1
  $reorder Enabled 1
  $reorder Opacity 1
  $reorder Embedded 1
  $reorder AlphaBlended 1
  $reorder Visible 1
  $reorder WipeUpSlot 1
  $reorder Rectangle 1
  $reorder Rectangle1 1
  $reorder Image 1
  $reorder WipeUp 1
}

$rect <350,259,550,299>
$output false
resource Resources::Bitmap IconsLarge
{
  attr bitmapfile FileName = .\Resources\IconsLarge.png;
  attr bitmapdithering Dithering = Auto;
  attr framesize FrameSize = <100,100>;
  attr framedelay FrameDelay;
  attr bitmapformat Format = Alpha8;
  attr bitmapmode Mode = Default;
}

$rect <350,299,550,339>
$output false
resource Resources::Bitmap IconsSmall
{
  attr bitmapfile FileName = .\Resources\IconsSmall.png;
  attr bitmapdithering Dithering = Auto;
  attr framesize FrameSize = <40,40>;
  attr framedelay FrameDelay;
  attr bitmapformat Format = Alpha8;
  attr bitmapmode Mode = Default;
}

$rect <320,78,520,118>
$output false
class Event
{
  $rect <180,70,380,110>
  property int64 TriggerTime;

  $rect <180,110,380,150>
  onset TriggerTime
  {
    // The value doesn't change - nothing to do.
    if ( pure TriggerTime == value )
      return;

    // Remember the property's new value.
    pure TriggerTime = value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <180,150,380,190>
  onget TriggerTime
  {
    return pure TriggerTime;
  }

  $rect <390,70,590,110>
  array bool ScheduledDays[ 7 ] =
  (
    Default[0] = false;
    Default[1] = false;
    Default[2] = false;
    Default[3] = false;
    Default[4] = false;
    Default[5] = false;
    Default[6] = false;
  );

  $rect <600,70,800,110>
  property Clock::EventType Type;

  $rect <600,110,800,150>
  onset Type
  {
    // The value doesn't change - nothing to do.
    if ( pure Type == value )
      return;

    // Remember the property's new value.
    pure Type = value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <600,150,800,190>
  onget Type
  {
    return pure Type;
  }

  $rect <180,230,380,270>
  method bool IsTriggered( arg int64 currentTime )
  {
    if(TriggerTime + Snooze==currentTime) return true;
    return false;
  }

  $rect <180,270,380,310>
  method bool IsExpired( arg int64 currentTime )
  {
    if(TriggerTime + Snooze<=currentTime) return !IsScheduled;
    return false;
  }

  $rect <810,70,1010,110>
  property int64 Snooze = 0;

  $rect <810,110,1010,150>
  onset Snooze
  {
    // The value doesn't change - nothing to do.
    if ( pure Snooze == value )
      return;


    // Remember the property's new value.
    pure Snooze = value;

    Clock::Device.EventChanged.Trigger( null, null );
    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <810,150,1010,190>
  onget Snooze
  {
    return pure Snooze;
  }

  $rect <390,110,590,150>
  property bool IsScheduled;

  $rect <390,150,590,190>
  onset IsScheduled
  {
    // The value doesn't change - nothing to do.
    if ( pure IsScheduled == value )
      return;

    // Remember the property's new value.
    pure IsScheduled = value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <390,190,590,230>
  onget IsScheduled
  {
    return pure IsScheduled;
  }
}

$rect <320,118,520,158>
$output false
enum EventType
{
  $rect <10,10,210,50>
  item Alarm;

  $rect <220,10,420,50>
  item Calendar;
}

$rect <120,118,320,158>
vclass DeviceSimulation : Clock::DeviceClass
{
  $rect <240,50,430,90>
  inherited method GetEventsCount()
  {
    var int32 result=0;
    while(Events[result]!=null)
     result++;

    return result;
  }

  $rect <240,90,429,130>
  inherited method GetEvent()
  {
    return Events[index];
  }

  $rect <39,90,239,130>
  inherited method AddEvent()
  {
    var int32 eventNo=GetEventsCount();
    if(eventNo>=Events.size)
      return false;

    for(;eventNo>0;eventNo--)
      Events[eventNo]=Events[eventNo-1];
    Events[0]=event;

    EventChanged.Trigger( null, null );
    return true;


  }

  $rect <39,50,239,90>
  inherited method RemoveEvent()
  {
    if(index<0 || index>GetEventsCount()-1) return false;
    var int32 eventNo=GetEventsCount();

    for(;index<eventNo;index++)
      {
      Events[index]=(index==Events.size-1)?null:Events[index+1];
      }

    EventChanged.Trigger( null, null );
    return true;
  }

  $rect <40,130,240,170>
  inherited method UpdateEvent()
  {
    var Clock::Event event=Clock::Device.GetEvent( index );
    var int32 currentDayOfWeek=Clock::Time.Initialize( event.TriggerTime ).DayOfWeek;
    var int64 currentTime=Clock::Time.CurrentTime.Time;
    var int64 i=event.TriggerTime ;
    do
    {
      if(event.ScheduledDays[(currentDayOfWeek+int32(i-event.TriggerTime )/86400)%7]==true && i>currentTime) 
       {
          event.TriggerTime=i;
          Clock::Device.EventChanged.Trigger( null, null );
          return true; 
       }
      i+=86400;
    }while(i<=event.TriggerTime+7*86400);
    return false;
  }

  $rect <20,-80,220,-40>
  array Clock::Event Events[ 32 ];

  // Event Access and Modification
  note group Note2
  {
    attr Bounds = <20,10,450,180>;
  }

  $reorder GetEventsCount 1
  $reorder GetEvent 1
  $reorder AddEvent 1
  $reorder RemoveEvent 1
}

// Device
note group Note2
{
  attr Bounds = <110,-2,529,169>;
}

// This component implements a generic alert.
$rect <99,680,299,720>
$output false
class Alert : Templates::Panel
{
  $rect <688,-19,888,21>
  inherited method Init()
  {
    Int32Effect.Enabled=true;
  }

  $rect <688,21,888,61>
  inherited property Bounds = <0,0,640,480>;

  $rect <697,361,897,401>
  onset OnButton1
  {
    // The value doesn't change - nothing to do.
    if ( pure OnButton1 == value )
      return;

    // Remember the property's new value.
    pure OnButton1 = value;

  }

  $rect <697,321,897,361>
  onset Button1Label
  {
    // The value doesn't change - nothing to do.
    if ( pure Button1Label == value )
      return;

    // Remember the property's new value.
    pure Button1Label = value;

    // ... and update the text displayed in the alert
    PushButton1.Label = value;

  }

  $rect <899,489,1099,529>
  onset Message
  {
    // The value doesn't change - nothing to do.
    if ( pure Message == value )
      return;

    // Remember the property's new value.
    pure Message = value;

    // ... and update the text displayed in the alert
    MessageText.String = value;

  }

  $rect <899,449,1099,489>
  onset Caption
  {
    // The value doesn't change - nothing to do.
    if ( pure Caption == value )
      return;

    // Remember the property's new value.
    pure Caption = value;

    // ... and update the text displayed in the alert
    CaptionText.String = value;

  }

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler SimpleTouchHandler
  {
    preset Point4 = <0,-1>;
    preset Point3 = <640,0>;
    preset Point2 = <640,480>;
    preset Point1 = <0,480>;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Background
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <86,150,551,327>;
    preset ColorBL = #FFFFFFD7;
    preset ColorBR = #FFFFFFD7;
    preset ColorTR = #FFFFFF7B;
    preset ColorTL = #FFFFFF7B;
    preset Color = #4FA8C3FF;
  }

  $rect <20,20,160,60>
  object Views::Border Border
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <86,150,551,327>;
    preset Width = 3;
    preset Color = #276080FF;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Bounds = <86,152,551,230>;
    preset Color = #276080FF;
  }

  $rect <20,20,160,60>
  object Views::Text MessageText
  {
    preset Bounds = <86,230,551,280>;
    preset WrapText = true;
    preset Alignment = Views::TextAlignment[AlignHorzAuto, AlignHorzCenter, AlignVertCenter];
    preset String = "Message";
    preset Font = Resources::FontMedium;
    preset Color = #FAE9E0FF;
  }

  $rect <20,20,160,60>
  object Views::Text CaptionText
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToRight, AlignToTop, ResizeHorz];
    preset Bounds = <160,166,536,216>;
    preset String = "Caption";
    preset Font = Resources::FontLarge;
    preset Color = #FAE9E0FF;
  }

  // The property 'OnButton1' can store a slot method to signal when the user activates \
  // the first push button.
  $rect <697,281,897,321>
  property slot OnButton1 = null;

  // The property 'Button1Label' stores the text to display in the first push button.
  $rect <697,241,897,281>
  property string Button1Label = "Ok";

  // The property 'Message' stores the text to display in the message area of the \
  // alert.
  $rect <699,492,899,532>
  property string Message = "Caption";

  // The property 'Caption' stores the text to display in the header of the alert. 
  $rect <699,452,899,492>
  property string Caption = "Caption";

  $rect <899,531,1099,571>
  onset Icon
  {
    // The value doesn't change - nothing to do.
    if ( pure Icon == value )
      return;

    // Remember the property's new value.
    pure Icon = value;

    // ... and update the text displayed in the alert
    Image.Bitmap = value;

  }

  // The property 'Caption' stores the text to display in the header of the alert. 
  $rect <699,530,899,570>
  property Resources::Bitmap Icon = Resources::DefaultBitmap;

  $rect <20,20,160,60>
  object Views::Image Image
  {
    preset Bounds = <100,161,160,221>;
    preset Color = #FAE9E0FF;
    preset Bitmap = Resources::DefaultBitmap;
  }

  $rect <699,672,899,712>
  object Effects::Int32Effect Int32Effect
  {
    preset OnFinished = OnFinished;
    preset OnAnimate = OnAnimate;
    preset NoOfCycles = 1;
    preset CycleDuration = 300000;
    preset InitialDelay = 0;
    preset Enabled = true;
    preset Value2 = 300;
  }

  $rect <699,712,899,752>
  slot OnFinished
  {
    postsignal OnIgnored;
  }

  $rect <699,752,899,792>
  slot OnAnimate
  {
    Message="-"+string(Int32Effect.Value/3600,2)+":"+string(Int32Effect.Value/60,2)+":"+string(Int32Effect.Value%60,2);
  }

  $rect <1159,242,1359,282>
  slot OnButton1Press
  {
    postsignal OnButton1;
  }

  $rect <1109,111,1309,151>
  onset OnIgnored
  {
    // The value doesn't change - nothing to do.
    if ( pure OnIgnored == value )
      return;

    // Remember the property's new value.
    pure OnIgnored = value;

  }

  // The property 'OnButton1' can store a slot method to signal when the user activates \
  // the first push button.
  $rect <1109,71,1309,111>
  property slot OnIgnored = null;

  $rect <688,71,888,111>
  property int32 Index;

  $rect <688,111,888,151>
  onset Index
  {
    if ( pure Index == value )
      return;

    pure Index = value;

  }

  $rect <688,151,888,191>
  onget Index
  {
    return pure Index;
  }

  $rect <699,570,899,610>
  property int32 IconFrame;

  $rect <899,571,1099,611>
  onset IconFrame
  {
    // The value doesn't change - nothing to do.
    if ( pure IconFrame == value )
      return;

    // Remember the property's new value.
    pure IconFrame = value;
    Image.FrameNumber=value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <20,20,160,60>
  object Clock::DefaultButton PushButton1
  {
    preset Bounds = <176,280,309,316>;
    preset OnPress = OnButton1Press;
    preset IconColor = #FAE9E0FF;
    preset DefaultColor = #276080FF;
    preset LabelColor = #FAE9E0FF;
    preset Label = "OK";
    preset Font = Resources::FontMedium;
  }

  $rect <20,20,160,60>
  object Clock::DefaultButton PushButton2
  {
    preset Bounds = <328,280,461,316>;
    preset OnPress = OnButton2Press;
    preset IconColor = #FAE9E0FF;
    preset DefaultColor = #276080FF;
    preset LabelColor = #FAE9E0FF;
    preset Label = "Snooze";
    preset Font = Resources::FontMedium;
  }

  $rect <926,362,1126,402>
  onset OnButton2
  {
    // The value doesn't change - nothing to do.
    if ( pure OnButton2 == value )
      return;

    // Remember the property's new value.
    pure OnButton2 = value;

  }

  $rect <926,322,1126,362>
  onset Button2Label
  {
    // The value doesn't change - nothing to do.
    if ( pure Button2Label == value )
      return;

    // Remember the property's new value.
    pure Button2Label = value;

    // ... and update the text displayed in the alert
    PushButton1.Label = value;

  }

  // The property 'OnButton1' can store a slot method to signal when the user activates \
  // the first push button.
  $rect <926,282,1126,322>
  property slot OnButton2 = null;

  // The property 'Button1Label' stores the text to display in the first push button.
  $rect <926,242,1126,282>
  property string Button2Label = "Snooze";

  $rect <1159,282,1359,322>
  slot OnButton2Press
  {
    postsignal OnButton2;
  }

  $rect <898,71,1098,111>
  property Clock::Event Sender;

  $rect <898,111,1098,151>
  onset Sender
  {
    if ( pure Sender == value )
      return;

    pure Sender = value;

  }

  $rect <898,151,1098,191>
  onget Sender
  {
    return pure Sender;
  }

  // Aspect
  note group Note
  {
    attr Bounds = <688,410,1109,621>;
  }

  // Button1
  note group Note2
  {
    attr Bounds = <688,202,909,411>;
  }

  // Button2
  note group Note3
  {
    attr Bounds = <917,202,1138,411>;
  }

  // Button Press Events
  note group Note4
  {
    attr Bounds = <1148,203,1369,331>;
  }

  // Countdown Animation
  note group Note5
  {
    attr Bounds = <688,632,909,801>;
  }
}

$rect <350,339,550,379>
$output false
resource Resources::Bitmap IconsMedium
{
  attr bitmapfile FileName = .\Resources\IconsMedium.png;
  attr bitmapdithering Dithering = Auto;
  attr framesize FrameSize = <60,60>;
  attr framedelay FrameDelay;
  attr bitmapformat Format = Alpha8;
  attr bitmapmode Mode = Default;
}

// This class implements a 'push button' widget. When the user presses the button, \
// a signal is sent to the slot method stored in its @OnActivate property.
$rect <-130,899,70,939>
$output false
class FunctionalitiesButton : Templates::PushButton
{
  $rect <120,0,320,40>
  inherited property Bounds = <0,0,100,100>;

  // This internal slot method is called when the user releases the touch screen \
  // after touching the button's area. This activates the button.
  $rect <130,430,330,470>
  slot onReleaseTouch
  {
    postsignal OnRelease;
    FillPath2.Visible=false;
  }

  // This internal slot method is called when the user touches the button's area.
  $rect <130,390,330,430>
  slot onPressTouch
  {
    postsignal OnPress;
    FillPath2.Visible=true;
  }

  // The property 'OnActivate' can refer to a slot method, which will receive a signal \
  // as soon as the user has activated the button. Thereupon the method's logic will \
  // be executed.
  $rect <320,60,520,100>
  property slot OnPress = null;

  $rect <360,200,560,240>
  property int32 FrameNumber = 0;

  $rect <560,200,760,240>
  onset FrameNumber
  {
    // The value doesn't change - nothing to do.
    if ( pure FrameNumber == value )
      return;

    // Remember the property's new value.
    pure FrameNumber = value;

    Image.FrameNumber=value;
    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <360,160,560,200>
  property Resources::Bitmap Bitmap = Resources::DefaultBitmap;

  $rect <560,160,760,200>
  onset Bitmap
  {
    // The value doesn't change - nothing to do.
    if ( pure Bitmap == value )
      return;

    // Remember the property's new value.
    pure Bitmap = value;

    Image.Bitmap=value;
    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  // The property 'OnActivate' can refer to a slot method, which will receive a signal \
  // as soon as the user has activated the button. Thereupon the method's logic will \
  // be executed.
  $rect <120,60,320,100>
  property slot OnRelease = null;

  $rect <360,240,560,280>
  property color IconColor = #FFFFFFFF;

  $rect <560,240,760,280>
  onset IconColor
  {
    // The value doesn't change - nothing to do.
    if ( pure IconColor == value )
      return;

    // Remember the property's new value.
    pure IconColor = value;

    Image.Color=IconColor;
    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <130,160,330,200>
  property color Color = #FFFFFFFF;

  $rect <130,240,330,280>
  onset Color
  {
    // The value doesn't change - nothing to do.
    if ( pure Color == value )
      return;

    // Remember the property's new value.
    pure Color = value;

    FillPath1.ColorBL=value;
    FillPath1.ColorTR=value;
    FillPath1.ColorTL=value;
    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <130,200,330,240>
  property color ShadowColor = #FFFFFFFF;

  $rect <130,280,330,320>
  onset ShadowColor
  {
    // The value doesn't change - nothing to do.
    if ( pure ShadowColor == value )
      return;

    // Remember the property's new value.
    pure ShadowColor = value;

    FillPath.Color=value;
    FillPath1.ColorBR=value;
    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <20,20,160,60>
  object Views::FillPath FillPath
  {
    preset Bounds = <0,0,100,100>;
    preset Color = #0F1E35FF;
    preset Offset = <50,50>;
    preset FillRule = Graphics::FillRule.EvenOdd;
    preset Path = ArcPath;
  }

  $rect <120,500,320,540>
  object Graphics::ArcPath ArcPath
  {
    preset EndAngle = 360;
    preset Radius = 50;
    preset Style = Graphics::ArcStyle.Pie;
  }

  $rect <120,540,320,580>
  object Graphics::ArcPath ArcPath1
  {
    preset EndAngle = 360;
    preset InnerRadius = 30;
    preset Radius = 49;
    preset Style = Graphics::ArcStyle.Pie;
  }

  $rect <20,20,160,60>
  object Views::FillPath FillPath1
  {
    preset Bounds = <0,0,100,100>;
    preset ColorBR = #0F1E35FF;
    preset Color = #FFFFFFFF;
    preset Offset = <50,50>;
    preset FillRule = Graphics::FillRule.EvenOdd;
    preset Path = ArcPath1;
  }

  $rect <20,20,160,60>
  object Views::Image Image
  {
    preset Bounds = <0,2,100,100>;
    preset Bitmap = Resources::DefaultBitmap;
  }

  $rect <20,20,160,60>
  object Views::FillPath FillPath2
  {
    preset Bounds = <0,0,100,100>;
    preset Color = #0000003A;
    preset Offset = <50,50>;
    preset FillRule = Graphics::FillRule.EvenOdd;
    preset Path = ArcPath;
    preset Visible = false;
  }

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler SimpleTouchHandler
  {
    preset Point4 = <11,11>;
    preset Point3 = <91,11>;
    preset Point2 = <91,91>;
    preset Point1 = <11,91>;
    preset OnRelease = onReleaseTouch;
    preset OnPress = onPressTouch;
  }

  // Touch Handler Events
  note group Note
  {
    attr Bounds = <120,350,340,480>;
  }

  // Icon
  note group Note1
  {
    attr Bounds = <350,120,770,290>;
  }

  // Button color
  note group Note2
  {
    attr Bounds = <120,120,340,330>;
  }
}

// This class implements a 'push button' widget. When the user presses the button, \
// a signal is sent to the slot method stored in its @OnActivate property.
$rect <-130,859,70,899>
$output false
class DefaultButton : Templates::PushButton
{
  $rect <120,-10,320,30>
  inherited property Bounds = <0,0,100,100>;

  $rect <119,39,319,79>
  inherited method UpdateViewState()
  {
    super( aState );

    var bool isEnabled  = aState.contains( Core::ViewState[ Enabled ]);
    var bool isPressed  = TouchHandler.Down && TouchHandler.Inside;

    if(isEnabled)
    {
      CurrentColor=DefaultColor;
      TouchHandler.Enabled=true;
    }
    else
    {
      CurrentColor=#6F7586FF;
      TouchHandler.Enabled=false;
    }

    if(isPressed)
    {
      Rectangle2.Visible=true;
    }
    else
    {
      Rectangle2.Visible=false;
    }
  }

  // This internal slot method is called when the user touches the button's area.
  $rect <130,480,330,520>
  slot OnPressTouch
  {
    postsignal OnPress;
  }

  // The property 'OnActivate' can refer to a slot method, which will receive a signal \
  // as soon as the user has activated the button. Thereupon the method's logic will \
  // be executed.
  $rect <119,89,319,129>
  property slot OnPress = null;

  $rect <360,219,560,259>
  property int32 FrameNumber = 0;

  $rect <360,339,560,379>
  onset FrameNumber
  {
    // The value doesn't change - nothing to do.
    if ( pure FrameNumber == value )
      return;

    // Remember the property's new value.
    pure FrameNumber = value;

    Image.FrameNumber=value;
    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <360,179,560,219>
  property Resources::Bitmap Bitmap = Resources::DefaultBitmap;

  $rect <360,299,560,339>
  onset Bitmap
  {
    // The value doesn't change - nothing to do.
    if ( pure Bitmap == value )
      return;

    // Remember the property's new value.
    pure Bitmap = value;

    Image.Bitmap=value;
    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <360,259,560,299>
  property color IconColor = #FFFFFFFF;

  $rect <360,379,560,419>
  onset IconColor
  {
    // The value doesn't change - nothing to do.
    if ( pure IconColor == value )
      return;

    // Remember the property's new value.
    pure IconColor = value;

    Image.Color=IconColor;
    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <591,179,790,219>
  property color DefaultColor;

  $rect <591,258,790,298>
  onset DefaultColor
  {
    // The value doesn't change - nothing to do.
    if ( pure DefaultColor == value )
      return;

    // Remember the property's new value.
    pure DefaultColor = value;

    CurrentColor=DefaultColor;
    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <129,219,329,259>
  property color LabelColor = #FFFFFFFF;

  $rect <130,339,330,379>
  onset LabelColor
  {
    // The value doesn't change - nothing to do.
    if ( pure LabelColor == value )
      return;

    // Remember the property's new value.
    pure LabelColor = value;

    Text.Color=LabelColor;
    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <129,179,329,219>
  property string Label;

  $rect <130,299,330,339>
  onset Label
  {
    // The value doesn't change - nothing to do.
    if ( pure Label == value )
      return;

    // Remember the property's new value.
    pure Label = value;

    Text.String=Label;
    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <129,259,329,299>
  property Resources::Font Font;

  $rect <130,379,330,419>
  onset Font
  {
    // The value doesn't change - nothing to do.
    if ( pure Font == value )
      return;

    // Remember the property's new value.
    pure Font = value;

    Text.Font=Font;
    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,1,100,101>;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle1
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,1,100,101>;
    preset ColorBL = #FFFFFF86;
    preset ColorBR = #FFFFFF86;
    preset ColorTR = #FFFFFF00;
    preset ColorTL = #FFFFFF00;
    preset Color = #DCDCDCFF;
  }

  $rect <20,20,160,60>
  object Views::Image Image
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,2,100,100>;
    preset Alignment = Views::ImageAlignment[AlignHorzCenter, AlignVertCenter];
    preset Bitmap = null;
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,0,100,100>;
    preset Alignment = Views::TextAlignment[AlignHorzAuto, AlignHorzCenter, AlignVertCenter];
    preset String = "";
    preset Font = Resources::DefaultFont;
  }

  $rect <591,219,790,259>
  property color CurrentColor;

  $rect <591,298,790,338>
  onset CurrentColor
  {
    // The value doesn't change - nothing to do.
    if ( pure CurrentColor == value )
      return;

    // Remember the property's new value.
    pure CurrentColor = value;

    Rectangle.Color=value;
    Rectangle1.Color=value-#23232300;
    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle2
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,2,100,102>;
    preset Color = #0000003A;
    preset Visible = false;
  }

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler TouchHandler
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Point4 = <0,2>;
    preset Point3 = <100,2>;
    preset Point2 = <100,100>;
    preset Point1 = <0,100>;
    preset OnPress = OnPressTouch;
    preset RetargetCondition = Core::RetargetReason[WipeDown, WipeLeft, WipeRight, WipeUp];
  }

  // Button Color
  note group Note
  {
    attr Bounds = <580,139,800,349>;
  }

  // Button Icon
  note group Note1
  {
    attr Bounds = <350,139,569,429>;
  }

  // Button Label
  note group Note2
  {
    attr Bounds = <119,139,340,429>;
  }

  // Touch Screen Events
  note group Note3
  {
    attr Bounds = <119,439,340,530>;
  }
}

$rect <580,339,779,379>
$output false
class SlideTouchHandler : Core::SlideTouchHandler
{
  $rect <10,10,160,50>
  inherited slot timerSlot
  {
    // Receiving a pending signal after the animation was stopped. Ignore it
    if ( timer == null )
      return;

    var float timeX       = float( timer.Time - startTimeX ) * 0.001;
    var float timeY       = float( timer.Time - startTimeY ) * 0.001;
    var float timeX2      = timeX * timeX;
    var float timeY2      = timeY * timeY;
    var float newSpeedX   = accelerationX * timeX + speedX;
    var float newSpeedY   = accelerationY * timeY + speedY;
    var point newOffset   = point( int32( accelerationX * 0.5 * timeX2 + speedX * timeX + startX ),
                                   int32( accelerationY * 0.5 * timeY2 + speedY * timeY + startY ));
    var float parkingTime = float( RubberBandEffectDuration ) * 0.001;

    // 'Rubber band' effect for the horizontal movement. Stop it as soon as the end position has
    // been reached
    if ( parkingX && ( timeX >= parkingTime ))
    {
      newOffset.x   = endX;
      speedX        = 0.0;
      accelerationX = 0.0;
      startX        = float( newOffset.x );
      parkingX      = false;
    }

    // 'Rubber band' effect in horizontal direction? Calculate the next position by using a
    // fast-in - ease-out timing
    else if ( parkingX )
    {
      var float f = 1.0 - math_pow( 1.0 - ( timeX / parkingTime ), RubberBandEffectElasticity ) ;
      newOffset.x = int32( startX + ( float( endX ) - startX ) * f );
    }


    // 'Rubber band' effect for the vertical movement. Stop it as soon as the end position has
    // been reached
    if ( parkingY && ( timeY >= parkingTime ))
    {
      newOffset.y   = endY;
      speedY        = 0.0;
      accelerationY = 0.0;
      startY        = float( newOffset.y );
      parkingY      = false;
    }

    // 'Rubber band' effect in horizontal direction? Calculate the next position by using a
    // fast-in - ease-out timing
    else if ( parkingY )
    {
      var float f = 1.0 - math_pow( 1.0 - ( timeY / parkingTime ), RubberBandEffectElasticity ) ;
      newOffset.y = int32( startY + ( float( endY ) - startY ) * f );
    }

    // Inverting the animation direction? This will stop the animation
    if ((( speedX > 0.0 ) && ( newSpeedX < 0.0 )) || ( speedX < 0.0 ) && ( newSpeedX > 0.0 ))
    {
      newSpeedX   = 0.0;
      newOffset.x = Offset.x;
    }

    // Inverting the animation direction? This will stop the animation
    if ((( speedY > 0.0 ) && ( newSpeedY < 0.0 )) || ( speedY < 0.0 ) && ( newSpeedY > 0.0 ))
    {
      newSpeedY   = 0.0;
      newOffset.y = Offset.y;
    }

    // Content outside the boundary area -> activate the 'rubber band' effect.
    if ( !parkingX && ( newOffset.x < MinOffset.x ))
    {
      startX        = newOffset.x;
      endX          = MinOffset.x;
      startTimeX    = timer.Time;
      parkingX      = true;
    }

    // Content outside the boundary area -> activate the 'rubber band' effect.
    else if ( !parkingX && ( newOffset.x > Bounds.w/2 ) && ( newOffset.x < Bounds.w ))
    {
      startX        = newOffset.x;
      endX          = Bounds.w;
      startTimeX    = timer.Time;
      parkingX      = true;
    }
    else if ( !parkingX && ( newOffset.x > MaxOffset.x ))
    {
      startX        = newOffset.x;
      endX          = MaxOffset.x;
      startTimeX    = timer.Time;
      parkingX      = true;
    }

    // Content outside the boundary area -> activate the 'rubber band' effect.
    if ( !parkingY && ( newOffset.y < MinOffset.y ))
    {
      startY        = newOffset.y;
      endY          = MinOffset.y;
      startTimeY    = timer.Time;
      parkingY      = true;
    }

    // Content outside the boundary area -> activate the 'rubber band' effect.
    else if ( !parkingY && ( newOffset.y > MaxOffset.y ))
    {
      startY        = newOffset.y;
      endY          = MaxOffset.y;
      startTimeY    = timer.Time;
      parkingY      = true;
    }

    // If the animation speed fall below 20 px/sec stop the animation in 
    // this direction. 
    if ( !parkingX && ( speedX != 0.0 ) && ( newSpeedX > -20.0 ) && ( newSpeedX < 20.0 ))
    {
      // Reach the predetermined final position
      newOffset.x   = endX;
      speedX        = 0.0;
      accelerationX = 0.0;
      startX        = float( newOffset.x );
    }

    // If the animation speed fall below 20 px/sec stop the animation in 
    // this direction. 
    if ( !parkingY && ( speedY != 0.0 ) && ( newSpeedY > -20.0 ) && ( newSpeedY < 20.0 ))
    {
      // Reach the predetermined final position
      newOffset.y   = endY;
      speedY        = 0.0;
      accelerationY = 0.0;
      startY        = float( newOffset.y );
    }

    if(newOffset.x>=Bounds.w)
    {
      stopAnimation();
      Sliding = false;
      signal privateOnEnd;
      signal OnEnd;
    }

    // At fin drive the owner to adapt the scroll position
    if ( newOffset != Offset )
    {
      Delta  = newOffset - Offset;
      Offset = newOffset;

      signal privateOnSlide;
      signal OnSlide;
    }

    // The animation is done
    if (( speedX == 0.0 ) && ( speedY == 0.0 ) && !parkingX && !parkingY )
    {
      stopAnimation();
      Sliding = false;
      signal privateOnEnd;
      signal OnEnd;
    }
  }
}

$rect <350,219,550,259>
$output false
resource Resources::Bitmap BackgroundImg
{
  attr bitmapfile FileName = .\Resources\BackgroundImg.jpg;
  attr bitmapdithering Dithering = Auto;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapformat Format = Native;
  attr bitmapmode Mode = Default;
}

// Fonts
note group Note3
{
  attr Bounds = <110,179,329,389>;
}

// Bitmaps
note group Note4
{
  attr Bounds = <340,179,559,389>;
}

// Utilities
note group Note5
{
  attr Bounds = <569,179,780,389>;
}

// Calendar Items
note group Note6
{
  attr Bounds = <-139,400,81,590>;
}

// Alarm Schedule Day Selection Items
note group Note7
{
  attr Bounds = <90,400,310,560>;
}

// Time Display Items
note group Note8
{
  attr Bounds = <-141,600,80,810>;
}

// Time Event Items
note group Note9
{
  attr Bounds = <90,600,310,730>;
}

// Simple Buttons
note group Note1
{
  attr Bounds = <-139,819,80,950>;
}
