$version 11.00

$rect <80,70,280,110>
$output false
class Base : Core::Group
{
  $rect <20,550,220,590>
  inherited method Init()
  {
    Bounds.size = $ScreenSize;
    this.Background.Bounds.size=$ScreenSize;

    PresentDialog( new Clock::ClockScreen, null, null, null, null, null, null, null, null, false );
  }

  $rect <20,500,220,540>
  inherited property Bounds = <0,0,300,200>;

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Bounds = <0,0,640,480>;
    preset ColorTR = #FFFFFFFF;
    preset Color = #6CC4B2FF;
  }

  $rect <20,20,160,60>
  object Views::Image Background
  {
    preset Bounds = <0,0,640,480>;
    preset Color = #705EEBFF;
    preset Bitmap = Clock::Background;
  }
}

$rect <80,110,280,150>
$output false
class ClockScreen : Core::Group
{
  $rect <0,500,200,540>
  inherited method Init()
  {
    postsignal UpdateTime;
  }

  $rect <660,-10,860,30>
  inherited property Bounds = rect(0,0,$ScreenSize.x,$ScreenSize.y);

  $rect <20,20,160,60>
  object Clock::PlainClock PlainClock
  {
    preset Bounds = <0,67,384,441>;
    preset Opacity = 255;
    preset Color = #7CCCC2FF;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Bounds = <0,39,640,80>;
    preset ColorBL = #4D578453;
    preset ColorBR = #4D578453;
    preset ColorTR = #4D5784FF;
    preset ColorTL = #4D5784FF;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle1
  {
    preset Bounds = <0,439,640,480>;
    preset ColorBL = #4D5784FF;
    preset ColorBR = #4D5784FF;
    preset ColorTR = #4D578453;
    preset ColorTL = #4D578453;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle2
  {
    preset Bounds = <0,0,640,41>;
    preset ColorBL = #4D5784FF;
    preset ColorBR = #4D5784FF;
    preset ColorTR = #4D5784FF;
    preset ColorTL = #4D5784FF;
    preset Color = #FFFFFFFF;
  }

  $rect <20,20,160,60>
  object Views::Image Image
  {
    preset Bounds = <295,430,345,480>;
    preset Bitmap = Resources::NavigationIconsMedium;
  }

  $rect <20,20,160,60>
  object Views::Image Image1
  {
    preset Bounds = <295,39,345,89>;
    preset Orientation = Views::Orientation.Rotated_180;
    preset Bitmap = Resources::NavigationIconsMedium;
  }

  $rect <20,20,160,60>
  object Core::WipeTouchHandler WipeDown
  {
    preset Bounds = <0,0,640,108>;
    preset OnBottom = WipeDownSlot;
  }

  $rect <20,20,160,60>
  object Core::WipeTouchHandler WipeUp
  {
    preset Bounds = <0,403,640,479>;
    preset OnTop = WipeUpSlot;
  }

  $rect <20,20,160,60>
  object Views::Line Line
  {
    preset Point2 = <384,403>;
    preset Point1 = <384,108>;
    preset Width = 2;
  }

  $rect <20,20,160,60>
  object Views::Line Line1
  {
    preset Point2 = <413,240>;
    preset Point1 = <614,240>;
    preset Width = 1;
  }

  $rect <20,20,160,60>
  object Views::Text DayMonth
  {
    preset Bounds = <413,108,614,223>;
    preset WrapText = true;
    preset String = "Mon, July 32";
    preset Font = Resources::FontLarge;
  }

  $rect <20,20,160,60>
  object Views::Text Year
  {
    preset Bounds = <413,255,614,318>;
    preset WrapText = true;
    preset String = "Year";
    preset Font = Resources::FontExtraLarge;
  }

  $rect <0,570,200,610>
  object Core::Timer Timer
  {
    preset OnTrigger = UpdateTime;
    preset Period = 100;
    preset Enabled = true;
  }

  $rect <210,500,410,540>
  slot UpdateTime
  {
    var Core::Time currentTime =  Clock::Time.CurrentTime;

    Second.String=string(currentTime.Second/10)+ string(currentTime.Second%10);
    Hour.String=string(currentTime.Hour/10)+string(currentTime.Hour%10);
    Hour.String=string(currentTime.Minute/10)+string(currentTime.Minute%10);
    DayMonth.String=currentTime.getDayOfWeekName( currentTime.DayOfWeek, false ) + "\n" + currentTime.getMonthName( currentTime.Month, false ) + " " + string(currentTime.Day, 2);
    Year.String = string(currentTime.Year);

    PlainClock.Second=currentTime.Second;
    PlainClock.Hour=currentTime.Hour;
    PlainClock.Minute=currentTime.Minute;
  }

  $rect <20,20,160,60>
  object Views::Text Hour
  {
    preset Bounds = <14,108,154,403>;
    preset String = "00";
    preset Font = Clock::TimeFont;
  }

  $rect <20,20,160,60>
  object Views::Text Second
  {
    preset Bounds = <295,108,384,403>;
    preset String = "00";
    preset Font = Clock::SecondFont;
  }

  $rect <20,20,160,60>
  object Views::Text Dot
  {
    preset Bounds = <154,107,172,402>;
    preset String = "05:30";
    preset Font = Clock::TimeFont;
  }

  $rect <20,20,160,60>
  object Views::Text Minute
  {
    preset Bounds = <172,108,312,403>;
    preset String = "00";
    preset Font = Clock::TimeFont;
  }

  $rect <20,20,160,60>
  object Core::Outline Outline
  {
    preset Bounds = <0,0,640,39>;
  }

  $rect <210,570,410,610>
  slot WipeUpSlot
  {
    Owner.SwitchToDialog( new Clock::FunctionalitiesScreen, Effects::SlideUpCentered, null, null, null, null, null, null, null, null, false );
  }

  $rect <210,610,410,650>
  slot WipeDownSlot
  {
    Owner.SwitchToDialog( null, Effects::SlideDownCentered, null, null, null, null, null, null, null, null, false );
  }
}

$rect <480,110,680,150>
$output false
resource Resources::Font TimeFont
{
  attr fontname FontName = Agency FB;
  attr fontheight Height = 150;
  attr fontheightmode HeightMode = Popular;
  attr fontquality Quality = High;
  attr fontranges Ranges = 0x20-0xFF;
  attr fontaspectratio AspectRatio = 1;
  attr fontbold Bold = true;
  attr fontitalic Italic = false;
  attr fontkerning Kerning = true;
  attr fontrowdistance RowDistance;
}

$rect <490,380,690,420>
inline Inline
{
  /*

    TO DO:

    Include external header files or add type and function declarations needed
    in the implementation of Clock::DeviceClass. For example:

      #include "DeviceDriver.h"

      #include "your_middleware_api.h"

      void Your_Middleware_Some_Function( int aSomeArg );

  */
}

$rect <490,340,690,380>
$output false
class DeviceClass : Templates::DeviceClass
{
  $rect <30,80,230,120>
  inherited method Done()
  {
    // The following section is intended to perform de-initialization-related operations
    // in the underlying device or middleware. Consequently, the section is taken in
    // account only when generating code (not during prototyping).
    $if !$prototyper
      var object thisObject = this;

      /*
         TO DO:

         The following native statement is intended to enclose code to communicate with
         your device API. The variable 'thisObject' contains a pointer to the actually
         de-initialized Clock::DeviceClass object. Use the 'thisObject' pointer to
         e.g. de-register the object from the middleware if you have registered it
         beforehand.
         
      */

      native ( thisObject )
      {
        /*
           TO DO:

           Depending on your application case you call functions of the underlying
           middleware (or access the device directly) in order to perform the necessary
           de-initialization steps. For example, you invoke some 'C' function:

             YourDevice_DeInitialize();

           IMPORTANT:
           ----------

           The variable 'thisObject' represents the actually de-initialized instance of the
           Clock::DeviceClass. If you have stored this object at the initialization
           time (in the 'Init' method) in some global C variable or registered it by the
           middleware, it is important to perform now the opposite operation. Set the
           global variable to NULL or de-register 'thisObject' object from the middleware.
           
        */
      }
    $endif
  }

  $rect <30,40,230,80>
  inherited method Init()
  {
    // The following section is intended to perform initialization-related operations
    // in the underlying device or middleware. Consequently, the section is taken in
    // account only when generating code (not during prototyping).
    $if !$prototyper
      var object thisObject = this;

      /*
         TO DO:

         The following native statement is intended to enclose code to communicate with
         your device API. The variable 'thisObject' contains a pointer to the actually
         initialized Clock::DeviceClass object. Use the 'thisObject' pointer to
         e.g. register the object by the middleware as receiver of events, etc.
         
      */

      native ( thisObject )
      {
        /*
           TO DO:

           Depending on your application case you call functions of the underlying
           middleware (or access the device directly) in order to perform the necessary
           initialization steps. For example, you invoke some 'C' function:

             YourDevice_Initialize();

           The variable 'thisObject' represents the actually initialized instance of the
           Clock::DeviceClass. You can store this variable e.g. in the middleware
           and use it whenever the middleware needs to notify the GUI application about
           some state alternation or events. In this manner, the middleware will be able
           to invoke methods of the interface device object.

           For example, you can store 'thisObject' in some global C variable:

             // Declaration of the global C variable
             XObject theDeviceObject;

             // Store the instance in the global variable
             theDeviceObject = thisObject;

           Later use the global variable e.g. to provide the GUI application with events:

             ApplicationDeviceClass__TriggerSomeEvent( theDeviceObject );

           IMPORTANT:
           ----------

           If you store 'thisObject' for later use, don't forget to implement the opposite
           operation in the method 'Done'. Concrete, 'Done' should set the global variable
           again to the value NULL.

        */
      }
    $endif
  }

  // Constructor and Destructor
  note group Note1
  {
    attr Bounds = <10,0,250,140>;
  }

  $rect <10,170,210,210>
  object Core::Timer Timer
  {
    preset OnTrigger = Slot;
    preset Period = 1000;
    preset Enabled = true;
  }

  $rect <10,210,200,250>
  object Core::Time Time;

  $rect <210,170,410,210>
  slot Slot
  {
    trace "fet";
  }
}

$rect <690,340,890,380>
autoobject Clock::DeviceClass Device;

$rect <480,150,680,190>
$output false
resource Resources::Font SecondFont
{
  attr fontname FontName = Agency FB;
  attr fontheight Height = 50;
  attr fontheightmode HeightMode = Popular;
  attr fontquality Quality = High;
  attr fontranges Ranges = 0x20-0xFF;
  attr fontaspectratio AspectRatio = 1;
  attr fontbold Bold = true;
  attr fontitalic Italic = false;
  attr fontkerning Kerning = true;
  attr fontrowdistance RowDistance;
}

$rect <80,150,280,190>
$output false
class RunningScreen : Core::Group
{
  $rect <10,230,210,270>
  inherited property Bounds = <0,0,300,200>;

  $rect <10,390,210,430>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <10,350,210,390>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  // To do:
  // 
  // - Adjust the visible size of your component (the thick blue border).
  // 
  // - The simplest way to compose the appearance of the component is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To implement the interface of the component use the 'Property' template from \
  // the Gallery folder 'Chora'.
  // 
  // - To store values use the 'Variable' and 'Array' templates available in the \
  // Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - In the method 'UpdateViewState()' you can put code to update the state of \
  // views enclosed in your component.
  // 
  // - In the method 'UpdateLayout()' you can put code to perform sophisticated layout \
  // calculation for enclosed views.
  note legend Note1
  {
    attr Bounds = <220,230,1000,550>;
  }
}

$rect <81,190,281,230>
$output false
class FunctionalitiesScreen : Core::Group
{
  $rect <0,540,200,580>
  inherited method Init()
  {
    postsignal UpdateTime;
  }

  $rect <0,500,200,540>
  inherited property Bounds = rect(0,0,$ScreenSize.x,$ScreenSize.y);

  $rect <0,590,200,630>
  object Core::Timer Timer
  {
    preset OnTrigger = UpdateTime;
    preset Period = 100;
    preset Enabled = true;
  }

  $rect <210,590,410,630>
  slot WipeUpSlot
  {
    Owner.SwitchToDialog(new Clock::ClockScreen, Effects::SlideUpCentered, null, null, null, null, null, null, null, null, false );
  }

  $rect <210,500,410,540>
  slot UpdateTime
  {
    var Core::Time currentTime = Clock::Time.CurrentTime;
    Hour.String=string(currentTime.Hour/10)+string(currentTime.Hour%10)+":"+string(currentTime.Minute/10)+string(currentTime.Minute%10);
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Bounds = <0,0,640,480>;
    preset Color = #00000058;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle1
  {
    preset Bounds = <0,439,640,480>;
    preset ColorBL = #4D5784FF;
    preset ColorBR = #4D5784FF;
    preset ColorTR = #4D578453;
    preset ColorTL = #4D578453;
  }

  $rect <20,20,160,60>
  object Views::Image Image
  {
    preset Bounds = <295,430,345,480>;
    preset Bitmap = Resources::NavigationIconsMedium;
  }

  $rect <20,20,160,60>
  object Core::WipeTouchHandler WipeUp
  {
    preset Bounds = <0,430,640,479>;
    preset OnTop = WipeUpSlot;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle2
  {
    preset Bounds = <0,0,640,41>;
    preset ColorBL = #4D5784FF;
    preset ColorBR = #4D5784FF;
    preset ColorTR = #4D5784FF;
    preset ColorTL = #4D5784FF;
    preset Color = #FFFFFFFF;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle3
  {
    preset Bounds = <0,39,640,80>;
    preset ColorBL = #4D578453;
    preset ColorBR = #4D578453;
    preset ColorTR = #4D5784FF;
    preset ColorTL = #4D5784FF;
  }

  $rect <20,20,160,60>
  object Views::Text Hour
  {
    preset Bounds = <458,9,640,70>;
    preset String = "Text";
    preset Font = Clock::SecondFont;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton ChronometerButton
  {
    preset Bounds = <146,125,246,225>;
    preset OnPress = OnChronButton;
    preset Label = "Caption";
    preset Appearance = ChronometerButtonConfig;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton CalendarButton
  {
    preset Bounds = <394,125,494,225>;
    preset OnEnter = OnCalButton;
    preset Label = "Caption";
    preset Appearance = CalendarButtonConfig;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton TimerButton
  {
    preset Bounds = <146,277,246,377>;
    preset OnEnter = OnTimerButton;
    preset Label = "Caption";
    preset Appearance = TimerButtonConfig;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton AlarmButton
  {
    preset Bounds = <394,277,494,377>;
    preset OnPress = OnAlarmButton;
    preset Label = "Caption";
    preset Appearance = AlarmButtonConfig;
  }

  $rect <0,700,240,740>
  object WidgetSet::PushButtonConfig ChronometerButtonConfig
  {
    preset IconAlignment = Views::ImageAlignment[AlignHorzCenter, AlignVertCenter];
    preset FaceActive = Clock::ChronometerActiveImg;
    preset FaceFocused = Clock::ChronometerImg;
    preset FaceDisabled = Clock::ChronometerImg;
    preset FaceDefault = Clock::ChronometerImg;
  }

  $rect <0,740,240,780>
  object WidgetSet::PushButtonConfig AlarmButtonConfig
  {
    preset IconAlignment = Views::ImageAlignment[AlignHorzCenter, AlignVertCenter];
    preset FaceActive = Clock::AlarmActiveImg;
    preset FaceFocused = Clock::AlarmImg;
    preset FaceDisabled = Clock::AlarmImg;
    preset FaceDefault = Clock::AlarmImg;
  }

  $rect <0,780,240,820>
  object WidgetSet::PushButtonConfig TimerButtonConfig
  {
    preset IconAlignment = Views::ImageAlignment[AlignHorzCenter, AlignVertCenter];
    preset FaceActive = Clock::TimerActiveImg;
    preset FaceFocused = Clock::TimerImg;
    preset FaceDisabled = Clock::TimerImg;
    preset FaceDefault = Clock::TimerImg;
  }

  $rect <0,820,240,860>
  object WidgetSet::PushButtonConfig CalendarButtonConfig
  {
    preset IconAlignment = Views::ImageAlignment[AlignHorzCenter, AlignVertCenter];
    preset FaceActive = Clock::CalendarActiveImg;
    preset FaceFocused = Clock::CalendarImg;
    preset FaceDisabled = Clock::CalendarImg;
    preset FaceDefault = Clock::CalendarImg;
  }

  $rect <20,20,160,60>
  object Views::Text CronometerText
  {
    preset Bounds = <146,222,246,252>;
    preset String = "Chronometer";
    preset Font = Resources::FontSmall;
  }

  $rect <20,20,160,60>
  object Views::Text CalendarText
  {
    preset Bounds = <394,222,494,252>;
    preset String = "Calendar";
    preset Font = Resources::FontSmall;
  }

  $rect <20,20,160,60>
  object Views::Text TimerText
  {
    preset Bounds = <146,377,246,407>;
    preset String = "Timer";
    preset Font = Resources::FontSmall;
  }

  $rect <20,20,160,60>
  object Views::Text AlarmText
  {
    preset Bounds = <394,377,494,407>;
    preset String = "Alarm";
    preset Font = Resources::FontSmall;
  }

  $rect <419,590,619,630>
  slot OnTimerButton
  {
    Owner.SwitchToDialog(new Clock::TimerScreen, Effects::FadeInOutCentered, null, null, null, null, null, null, null, null, false );
  }

  $rect <419,630,619,670>
  slot OnChronButton
  {
    Owner.SwitchToDialog(new Clock::ChronometerScreen, Effects::FadeInOutCentered, null, null, null, null, null, null, null, null, false );
  }

  $rect <419,670,619,710>
  slot OnAlarmButton
  {
    Owner.SwitchToDialog(new Clock::AlarmScreen, Effects::FadeInOutCentered, null, null, null, null, null, null, null, null, false );
  }

  $rect <419,710,619,750>
  slot OnCalButton
  {
    Owner.SwitchToDialog(new Clock::CalendarScreen, Effects::FadeInOutCentered, null, null, null, null, null, null, null, null, false );
  }
}

$rect <690,70,890,110>
$output false
resource Resources::Bitmap CalendarImg
{
  attr bitmapfile FileName = .\Resources\CalendarImg.png;
  attr bitmapdithering Dithering = Auto;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapformat Format = Native;
  attr bitmapmode Mode = Default;
}

$rect <690,110,890,150>
$output false
resource Resources::Bitmap ChronometerImg
{
  attr bitmapfile FileName = .\Resources\ChronometerImg.png;
  attr bitmapdithering Dithering = Auto;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapformat Format = Native;
  attr bitmapmode Mode = Default;
}

$rect <690,150,890,190>
$output false
resource Resources::Bitmap TimerImg
{
  attr bitmapfile FileName = .\Resources\TimerImg.png;
  attr bitmapdithering Dithering = Auto;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapformat Format = Native;
  attr bitmapmode Mode = Default;
}

$rect <690,30,890,70>
$output false
resource Resources::Bitmap AlarmImg
{
  attr bitmapfile FileName = .\Resources\AlarmImg.png;
  attr bitmapdithering Dithering = Auto;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapformat Format = Native;
  attr bitmapmode Mode = Default;
}

$rect <890,30,1090,70>
$output false
resource Resources::Bitmap AlarmActiveImg
{
  attr bitmapfile FileName = .\Resources\AlarmActiveImg.png;
  attr bitmapdithering Dithering = Auto;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapformat Format = Native;
  attr bitmapmode Mode = Default;
}

$rect <890,70,1090,110>
$output false
resource Resources::Bitmap CalendarActiveImg
{
  attr bitmapfile FileName = .\Resources\CalendarActiveImg.png;
  attr bitmapdithering Dithering = Auto;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapformat Format = Native;
  attr bitmapmode Mode = Default;
}

$rect <890,110,1090,150>
$output false
resource Resources::Bitmap ChronometerActiveImg
{
  attr bitmapfile FileName = .\Resources\ChronometerActiveImg.png;
  attr bitmapdithering Dithering = Auto;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapformat Format = Native;
  attr bitmapmode Mode = Default;
}

$rect <890,150,1090,190>
$output false
resource Resources::Bitmap TimerActiveImg
{
  attr bitmapfile FileName = .\Resources\TimerActiveImg.png;
  attr bitmapdithering Dithering = Auto;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapformat Format = Native;
  attr bitmapmode Mode = Default;
}

// This class implements a 'rotary knob' widget. The user can touch the knob and \
// rotate it causing the widget's value to be changed accordingly. The current value \
// of the widget is represented by the property @CurrentValue. The valid range for \
// this value is determined by the properties @MinValue and @MaxValue.
// While the user is dragging the knob, the widget sends signals to the slot method \
// stored in the property @OnChange. When the user terminates the interaction, a \
// signal is sent to the slot method stored in @OnApply.
// Alternatively the property @Outlet can refer to any other 'int32' property the \
// widget should remain synchronized with. When the user drags the knob, the affected \
// property is automatically updated to reflect the widget's current value. On the \
// other hand, when the referred property is modified by another one, the widget \
// is automatically notified to remain in sync with the property.
// This approach follows the Model-View-Controller (MVC) programming paradigm. Here \
// the rotary knob represents the 'View' and 'Controller' and the property referred \
// via 'Outlet' can be seen as a part of the 'Model'.
$rect <80,411,280,451>
$output false
class PlainClock : Templates::RotaryKnob
{
  $rect <10,10,160,50>
  inherited method Init()
  {
    postsignal UpdateColor;
  }

  $rect <480,390,680,430>
  inherited property Bounds = <0,0,400,400>;

  $rect <480,350,680,390>
  object Graphics::ArcPath ArcPath
  {
    preset NoOfEdges = 0;
    preset EndAngle = 360;
    preset InnerRadius = 0;
    preset RadiusX = 0.0;
    preset Radius = 170;
    preset Style = Graphics::ArcStyle.Arc;
  }

  $rect <20,20,160,60>
  object Views::StrokePath StrokePath
  {
    preset Bounds = <0,0,400,400>;
    preset Offset = <200,200>;
    preset Width = 15.0;
    preset Path = ArcPath;
  }

  $rect <20,20,160,60>
  object Views::Line Line
  {
    preset Point2 = <200,50>;
    preset Point1 = <200,30>;
    preset Width = 10;
  }

  $rect <20,20,160,60>
  object Views::Line Line1
  {
    preset Point2 = <199,370>;
    preset Point1 = <199,350>;
    preset Width = 10;
  }

  $rect <20,20,160,60>
  object Views::Line Line2
  {
    preset Point2 = <350,200>;
    preset Point1 = <370,200>;
    preset Width = 10;
  }

  $rect <20,20,160,60>
  object Views::Line Line3
  {
    preset Point2 = <30,200>;
    preset Point1 = <50,200>;
    preset Width = 10;
  }

  $rect <470,0,670,40>
  property int32 Hour = 0;

  $rect <470,40,670,80>
  onset Hour
  {
    // The value doesn't change - nothing to do.
    if ( pure Hour == value )
      return;

    // Remember the property's new value.
    pure Hour = value;

    postsignal UpdateLines;
    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <470,80,670,120>
  onget Hour
  {
    return pure Hour;
  }

  $rect <670,0,870,40>
  property int32 Minute = 0;

  $rect <670,40,870,80>
  onset Minute
  {
    // The value doesn't change - nothing to do.
    if ( pure Minute == value )
      return;

    // Remember the property's new value.
    pure Minute = value;

    postsignal UpdateLines;
    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <670,80,870,120>
  onget Minute
  {
    return pure Minute;
  }

  $rect <870,0,1070,40>
  property int32 Second = 0;

  $rect <870,40,1070,80>
  onset Second
  {
    // The value doesn't change - nothing to do.
    if ( pure Second == value )
      return;

    // Remember the property's new value.
    pure Second = value;

    postsignal UpdateLines;
    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <870,80,1070,120>
  onget Second
  {
    return pure Second;
  }

  $rect <480,310,680,350>
  slot UpdateLines
  {
    SecondImg.RotateAndScale( SecondImg.SourceAnchor, -Second*6, 1.0, 1.0 );
    MinuteImg.RotateAndScale( MinuteImg.SourceAnchor, -Minute*6, 1.0, 1.0 );
    HourImg.RotateAndScale( HourImg.SourceAnchor, -Hour*15, 1.0, 1.0 );

  }

  $rect <20,20,160,60>
  object Views::WarpImage SecondImg
  {
    preset Point4 = <0,400>;
    preset Point3 = <400,400>;
    preset Point2 = <400,0>;
    preset Point1 = <0,0>;
    preset Shininess = 0.0;
    preset Quality = true;
    preset SourceAnchor = <200,200>;
    preset Color = Color;
    preset Bitmap = Clock::SecondLine;
  }

  $rect <20,20,160,60>
  object Views::WarpImage MinuteImg
  {
    preset Point4 = <0,400>;
    preset Point3 = <400,400>;
    preset Point2 = <400,0>;
    preset Point1 = <0,0>;
    preset Shininess = 0.0;
    preset Quality = true;
    preset SourceAnchor = <200,200>;
    preset Color = Color;
    preset Bitmap = Clock::MinuteLine;
  }

  $rect <20,20,160,60>
  object Views::WarpImage HourImg
  {
    preset Point4 = <0,400>;
    preset Point3 = <400,400>;
    preset Point2 = <400,0>;
    preset Point1 = <0,0>;
    preset Shininess = 0.0;
    preset Quality = true;
    preset SourceAnchor = <200,200>;
    preset AlphaBlended = true;
    preset Color = Color;
    preset Bitmap = Clock::HourLine;
  }

  $rect <470,120,670,160>
  property color Color = #FFFFFFFF;

  $rect <470,160,670,200>
  onset Color
  {
    // The value doesn't change - nothing to do.
    if ( pure Color == value )
      return;

    // Remember the property's new value.
    pure Color = value;

    postsignal UpdateColor;
    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <470,200,670,240>
  onget Color
  {
    return pure Color;
  }

  $rect <680,310,880,350>
  slot UpdateColor
  {
    HourImg.Color=Color;
    MinuteImg.Color=Color;
    SecondImg.Color=Color;
    Line.Color=Color;
    Line1.Color=Color;
    Line2.Color=Color;
    Line3.Color=Color;
    StrokePath.Color=Color;
  }
}

$rect <1090,30,1290,70>
$output false
resource Resources::Bitmap HourLine
{
  attr bitmapfile FileName = .\Resources\HourLine.png;
  attr bitmapdithering Dithering = Auto;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapformat Format = Alpha8;
  attr bitmapmode Mode = Default;
}

$rect <1090,70,1290,110>
$output false
resource Resources::Bitmap MinuteLine
{
  attr bitmapfile FileName = .\Resources\MinuteLine.png;
  attr bitmapdithering Dithering = Auto;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapformat Format = Alpha8;
  attr bitmapmode Mode = Default;
}

$rect <1090,110,1290,150>
$output false
resource Resources::Bitmap SecondLine
{
  attr bitmapfile FileName = .\Resources\SecondLine.png;
  attr bitmapdithering Dithering = Auto;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapformat Format = Alpha8;
  attr bitmapmode Mode = Default;
}

$rect <480,70,680,110>
$output false
resource Resources::Bitmap Background
{
  attr bitmapfile FileName = .\Resources\Background.jpg;
  attr bitmapdithering Dithering = Auto;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapformat Format = Alpha8;
  attr bitmapmode Mode = Default;
}

// This class implements a 'rotary knob' widget. The user can touch the knob and \
// rotate it causing the widget's value to be changed accordingly. The current value \
// of the widget is represented by the property @CurrentValue. The valid range for \
// this value is determined by the properties @MinValue and @MaxValue.
// While the user is dragging the knob, the widget sends signals to the slot method \
// stored in the property @OnChange. When the user terminates the interaction, a \
// signal is sent to the slot method stored in @OnApply.
// Alternatively the property @Outlet can refer to any other 'int32' property the \
// widget should remain synchronized with. When the user drags the knob, the affected \
// property is automatically updated to reflect the widget's current value. On the \
// other hand, when the referred property is modified by another one, the widget \
// is automatically notified to remain in sync with the property.
// This approach follows the Model-View-Controller (MVC) programming paradigm. Here \
// the rotary knob represents the 'View' and 'Controller' and the property referred \
// via 'Outlet' can be seen as a part of the 'Model'.
$rect <80,461,280,501>
$output false
class TimerClock : Templates::RotaryKnob
{
  $rect <480,160,630,200>
  inherited method Init()
  {
    postsignal UpdateColor;
  }

  $rect <480,390,680,430>
  inherited property Bounds = <0,0,379,379>;

  $rect <880,240,1080,280>
  inherited onget Enabled
  {
    return pure Enabled;
  }

  $rect <880,200,1080,240>
  inherited onset Enabled
  {
    pure Enabled = value;

    Timer.Enabled=value;
    if(value==true) TimePicker.Cover.Enabled=true;
  }

  $rect <880,160,1080,200>
  inherited property Enabled = false;

  $rect <480,350,680,390>
  object Graphics::ArcPath ArcPath
  {
    preset NoOfEdges = 0;
    preset EndAngle = 360;
    preset InnerRadius = 0;
    preset RadiusX = 0.0;
    preset Radius = 130;
    preset Style = Graphics::ArcStyle.Arc;
  }

  $rect <20,20,160,60>
  object Views::StrokePath StrokePath
  {
    preset Bounds = <0,0,380,380>;
    preset Color = #FFFFFF88;
    preset Offset = <190,190>;
    preset Width = 8;
    preset Path = ArcPath;
  }

  $rect <670,0,870,40>
  property color Color = #FFFFFFFF;

  $rect <670,40,870,80>
  onset Color
  {
    // The value doesn't change - nothing to do.
    if ( pure Color == value )
      return;

    // Remember the property's new value.
    pure Color = value;

    postsignal UpdateColor;
    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <670,80,870,120>
  onget Color
  {
    return pure Color;
  }

  $rect <680,310,880,350>
  slot UpdateColor
  {
  }

  $rect <20,20,160,60>
  object Views::StrokePath TimePassing
  {
    preset Bounds = <0,0,380,380>;
    preset ColorBL = #4B3FFFFF;
    preset ColorBR = #41F5FFFF;
    preset ColorTR = #19FF72FF;
    preset ColorTL = #FF43F8FF;
    preset Color = #FFFFFFFF;
    preset Offset = <190,190>;
    preset EndCap = Graphics::PathCap.Round;
    preset Width = 8;
    preset Path = TimerPath;
  }

  $rect <679,350,879,390>
  object Graphics::ArcPath TimerPath
  {
    preset NoOfEdges = 0;
    preset EndAngle = 270;
    preset StartAngle = 270;
    preset InnerRadius = 0;
    preset RadiusX = 0.0;
    preset Radius = 130;
    preset Style = Graphics::ArcStyle.Arc;
  }

  $rect <880,350,1080,390>
  slot UpdateTime
  {
    if(MaxValue==0)
    {
      Enabled=false;
      Running=false;
      ResetTime(true);
    }
    else
    {
      StartValue=StartValue+IncValue;
      TimerPath.EndAngle=TimerPath.StartAngle+uint32(StartValue);
      TimePicker.SetTime( --MaxValue );
    }
  }

  $rect <880,310,1080,350>
  object Core::Timer Timer
  {
    preset OnTrigger = UpdateTime;
  }

  $rect <1070,0,1270,40>
  property float StartValue = 0;

  $rect <1070,40,1270,80>
  onset StartValue
  {
    // The value doesn't change - nothing to do.
    if ( pure StartValue == value )
      return;

    // Remember the property's new value.
    pure StartValue = value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <1070,80,1270,120>
  onget StartValue
  {
    return pure StartValue;
  }

  $rect <480,310,680,350>
  slot UpdateMaxValue
  {
    var int32 hour = TimePicker.Hour==24?0:TimePicker.Hour;
    var int32 minute = TimePicker.Minute==60?0:TimePicker.Minute;
    var int32 second = TimePicker.Second==60?0:TimePicker.Second;

    MaxValue=hour*3600+minute*60+second;

    if(MaxValue>0) 
    {
      Running=true;

      IncValue=360.0/float(MaxValue);

    }
  }

  $rect <1270,0,1470,40>
  property int32 MaxValue = 0;

  $rect <1270,40,1470,80>
  onset MaxValue
  {
    // The value doesn't change - nothing to do.
    if ( pure MaxValue == value )
      return;

    // Remember the property's new value.
    pure MaxValue = value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <1270,80,1470,120>
  onget MaxValue
  {
    return pure MaxValue;
  }

  $rect <20,20,160,60>
  object Clock::TimePicker TimePicker
  {
    preset Bounds = <66,92,314,289>;
    preset OnChange = UpdateMaxValue;
  }

  $rect <1470,0,1670,40>
  property float IncValue = 0;

  $rect <1470,40,1670,80>
  onset IncValue
  {
    // The value doesn't change - nothing to do.
    if ( pure IncValue == value )
      return;

    // Remember the property's new value.
    pure IncValue = value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <1470,80,1670,120>
  onget IncValue
  {
    return pure IncValue;
  }

  $rect <679,160,879,200>
  property bool Running = false;

  $rect <679,200,879,240>
  onset Running
  {
    pure Running = value;

    postsignal OnChange;
  }

  $rect <679,240,879,280>
  onget Running
  {
    return pure Running;
  }

  $rect <1080,160,1280,200>
  property slot OnChange;

  $rect <1080,200,1280,240>
  onset OnChange
  {
    // The value doesn't change - nothing to do.
    if ( pure OnChange == value )
      return;

    // Remember the property's new value.
    pure OnChange = value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <1080,240,1280,280>
  onget OnChange
  {
    return pure OnChange;
  }

  $rect <480,270,680,310>
  method void ResetTime( arg bool TimeOut )
  {
    TimePicker.Hour=0;
    TimePicker.Minute=0;
    TimePicker.Second=0;
    TimerPath.EndAngle=270;
    IncValue=0.0;
    StartValue=0.0;

    Enabled=false;
    Running=false;

    TimePicker.End(TimeOut);
  }
}

$rect <480,190,680,230>
$output false
resource Resources::Font SmallerTimeFont
{
  attr fontname FontName = Agency FB;
  attr fontheight Height = 80;
  attr fontheightmode HeightMode = Popular;
  attr fontquality Quality = High;
  attr fontranges Ranges = 0x20-0xFF;
  attr fontaspectratio AspectRatio = 1;
  attr fontbold Bold = true;
  attr fontitalic Italic = false;
  attr fontkerning Kerning = true;
  attr fontrowdistance RowDistance;
}

// This is a GUI component.
$rect <80,510,280,550>
$output false
class TimePicker : Templates::PickerControl
{
  $rect <250,500,450,540>
  inherited property Bounds = <0,0,248,197>;

  $rect <480,280,680,320>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    // Determine the new state of the time picker widget.
    //
    // isEnabled  --> the time picker can react to user inputs.
    // isSelected --> the time picker can receive keyboard events.
    // isSliding  --> the user interacts with the time picker.
    //
    var bool isEnabled  = aState.contains( Core::ViewState[ Enabled  ]);
    var bool isSelected = aState.contains( Core::ViewState[ Selected ]);
    var bool isSliding  = TouchHandlerHour.Sliding   || 
                          TouchHandlerMinute.Sliding ||
                          TouchHandlerSecond.Sliding;

    /*

      TO DO:

      Depending on your time picker design, you have surely added some new 
      views  to your time picker. In the below code you should update the
      properties of these views. For example, when your picker has an image
      which you want to show only while the user is changing the time, than
      following can be done:

        theImage.Visible = isSliding;

      Depending on the state of the time picker, you can alternate any property 
      of your views. You can change their visibility, colors, opacity, bitmaps
      shown in image views, fonts used to render text, the position and the
      size the view, ...
       

      HINT:

      Instead of instantly alternate the views properties you can here also
      start effects to do this with an animation. Important: To decide when
      to start an effect you should compare the current state of the picker
      (e.g. 'isSliding') with its preceding state (e.g. variable 'sliding').

      Assuming you have already added to your time picker component a new
      effect member, named it 'slidingEffect' and configured it to animate
      e.g. the opacity of an image within the time picker. Then following is
      sufficient to trigger the animation:

        if ( isSliding && !sliding )
        {
          pressedEffect.Reversed = false;
          pressedEffect.Enabled  = true;
        }
        else if ( !isSliding && sliding )
        {
          pressedEffect.Reversed = true;
          pressedEffect.Enabled  = true;
        }

    */


    // Remember the current state. Next time when the UpdateViewState() is called
    // you can compare the 'old' state with the 'new' state and perform more
    // sophisticated update, e.g. you can start an animation effect for the
    // sliding <<-->> not sliding transition.
    enabled  = isEnabled;
    selected = isSelected;
    sliding  = isSliding;
  }

  // State Management
  note group Note3
  {
    attr Bounds = <470,240,690,450>;
  }

  // Touch screen events
  note group Note2
  {
    attr Bounds = <240,240,460,500>;
  }

  // List Management
  note group Note1
  {
    attr Bounds = <10,240,230,410>;
  }

  // This variable stores the current state of the time picker.
  $rect <480,400,680,440>
  var bool sliding;

  // This variable stores the current state of the time picker.
  $rect <480,360,680,400>
  var bool selected;

  // This method is called when one of the Slide Touch Handler (TouchHandlerHour, \
  // TouchHandlerMinute or TouchHandlerSecond) has finished the slide animation. \
  // Thereupon the owner of the time picker is notified, that the time has been changed.
  $rect <250,320,450,360>
  slot OnEndSlide
  {
    // The user has finished the interaction with the time picker. Request the
    // UpdateViewState() method to be called in order to eventually refresh
    // the time picker appearance.
    InvalidateViewState();

    // Notify the owner of the time picker, that the user has selected another time.
    // Do this however only after the last list has finished the slide animation.
    if ( !TouchHandlerHour.Sliding && !TouchHandlerMinute.Sliding && !TouchHandlerSecond.Sliding )
      postsignal OnChange;
  }

  // This method is called when one of the Slide Touch Handler (TouchHandlerHour, \
  // TouchHandlerMinute or TouchHandlerSecond) has begun the slide animation.
  $rect <250,280,450,320>
  slot OnStartSlide
  {
    // The user has begun an interaction with the time picker. Request the
    // UpdateViewState() method to be called in order to eventually refresh
    // the time picker appearance.
    InvalidateViewState();
  }

  // This method is called by 'ListSecond' vertical list every time the list loads \
  // or updates an item.
  $rect <20,360,220,400>
  slot OnLoadSecondItem
  {
    // Get the number of the item to load. The list component takes care of the
    // creation of the corresponding item view. Just access it ...
    var int32       itemNo   = ListSecond.Item;
    var Views::Text itemView = (Views::Text)ListSecond.View;

    // The implementation of this slot method does not match the item class
    // specified in the associated list component. Or the slot method is not
    // called in context of the OnLoadItem list operation.
    if ( itemView == null )
      return;

    var int32 itemCenter = ListSecond.GetItemAtPosition( SecondCenter );
    itemView.String    = string( itemNo, 2 );
    itemView.Font      = ( itemCenter == itemNo )?  Clock::SecondFont : Clock::SmallerSecondFont;
    itemView.Color     = ( itemCenter == itemNo )? #FFFFFFFF : #FFFFFF80;
    itemView.Alignment = Views::TextAlignment[ AlignHorzCenter, AlignVertCenter ];
    itemView.ScrollOffset = <0,-2>;                  
    // Ensure that the item has correct size. The position of the item will be
    // managed by the list component.
    itemView.Bounds.size = point( ListSecond.Bounds.w, ListSecond.ItemHeight );
  }

  // This method is called by 'ListMinute' vertical list every time the list loads \
  // or updates an item.
  $rect <20,320,220,360>
  slot OnLoadMinuteItem
  {
    // Get the number of the item to load. The list component takes care of the
    // creation of the corresponding item view. Just access it ...
    var int32       itemNo   = ListMinute.Item;
    var Views::Text itemView = (Views::Text)ListMinute.View;

    // The implementation of this slot method does not match the item class
    // specified in the associated list component. Or the slot method is not
    // called in context of the OnLoadItem list operation.
    if ( itemView == null )
      return;

    var int32 itemCenter = ListMinute.GetItemAtPosition( MinuteCenter );
    itemView.String    = string( itemNo, 2 );
    itemView.Font      = ( itemCenter == itemNo )?  Clock::SecondFont : Clock::SmallerSecondFont;
    itemView.Color     = ( itemCenter == itemNo )? #FFFFFFFF : #FFFFFF80;
    itemView.Alignment = Views::TextAlignment[ AlignHorzCenter, AlignVertCenter ];
    itemView.ScrollOffset = <0,-2>;                  
    // Ensure that the item has correct size. The position of the item will be
    // managed by the list component.
    itemView.Bounds.size = point( ListMinute.Bounds.w, ListMinute.ItemHeight );
  }

  // This method is called by 'ListHour' vertical list every time the list loads \
  // or updates an item.
  $rect <20,280,220,320>
  slot OnLoadHourItem
  {
    // Get the number of the item to load. The list component takes care of the
    // creation of the corresponding item view. Just access it ...
    var int32       itemNo   = ListHour.Item;
    var Views::Text itemView = (Views::Text)ListHour.View;

    // The implementation of this slot method does not match the item class
    // specified in the associated list component. Or the slot method is not
    // called in context of the OnLoadItem list operation.
    if ( itemView == null )
      return;

    var int32 itemCenter = ListHour.GetItemAtPosition( HourCenter );
    // Configure the item view ...     
    itemView.String    = string( itemNo ,2);
    itemView.Font      = ( itemCenter == itemNo )?  Clock::SecondFont : Clock::SmallerSecondFont;
    itemView.Color     = ( itemCenter == itemNo )? #FFFFFFFF : #FFFFFF80;
    itemView.Alignment = Views::TextAlignment[ AlignHorzCenter, AlignVertCenter ]; 
    itemView.ScrollOffset = <0,-2>;
                     
    // Ensure that the item has correct size. The position of the item will be
    // managed by the list component.
    itemView.Bounds.size = point( ListHour.Bounds.w, ListHour.ItemHeight );
  }

  $rect <670,90,869,130>
  onget Second
  {
    // From the actual scroll offset calculate the number of the corresponding
    // list item. Note, the list displays the actually selected time at the
    // third position (index 2).
    return (( -ListSecond.ScrollOffset / ListSecond.ItemHeight ) + 1 ) % 61;
  }

  $rect <669,50,870,90>
  onset Second
  {
    // Limit the assigned value to the valid range 0 .. 59
    if ( value < 0  ) value = 0;
    if ( value > 59 ) value = 59;

    // Adjust the scroll position of the corresponding list. Note, the
    // list displays the actually selected time scrolled by two items.
    // Take this displacement in account.
    ListSecond.ScrollOffset = ( value - 1 ) * -ListSecond.ItemHeight;

    UpdateCenterFont(ListSecond,SecondCenter);  
  }

  $rect <469,90,669,130>
  onget Minute
  {
    // From the actual scroll offset calculate the number of the corresponding
    // list item. Note, the list displays the actually selected time at the
    // third position (index 2).
    return (( -ListMinute.ScrollOffset / ListMinute.ItemHeight ) + 1 ) % 61;
  }

  $rect <469,50,669,90>
  onset Minute
  {
    // Limit the assigned value to the valid range 0 .. 59
    if ( value < 0  ) value = 0;
    if ( value > 59 ) value = 59;

    // Adjust the scroll position of the corresponding list. Note, the
    // list displays the actually selected time scrolled by two items.
    // Take this displacement in account.
    ListMinute.ScrollOffset = ( value - 1 ) * -ListMinute.ItemHeight;

    UpdateCenterFont(ListMinute,MinuteCenter);  
  }

  $rect <269,90,469,130>
  onget Hour
  {
    // From the actual scroll offset calculate the number of the corresponding
    // list item. Note, the list displays the actually selected time at the
    // third position (index 2).
    return (( -ListHour.ScrollOffset / ListHour.ItemHeight ) +1) % 25;
  }

  $rect <269,50,469,90>
  onset Hour
  {
    // Limit the assigned value to the valid range 0 .. 23
    if ( value < 0  ) value = 0;
    if ( value > 23 ) value = 23;
    // Adjust the scroll position of the corresponding list. Note, the
    // list displays the actually selected time scrolled by two items.
    // Take this displacement in account.
    ListHour.ScrollOffset = ( value - 1 ) * -ListHour.ItemHeight;

    UpdateCenterFont(ListHour,HourCenter);  
  }

  $rect <20,20,160,60>
  object Views::Border BorderCurrent
  {
    preset Bounds = <19,68,230,124>;
    preset Width = 5;
    preset Color = #FFFFFFFF;
    preset Visible = true;
  }

  $rect <20,20,160,60>
  object Core::SlideTouchHandler TouchHandlerSecond
  {
    preset Bounds = <169,8,230,187>;
    preset OnSlide = OnSlideSecond;
    preset OnEnd = OnEndSlide;
    preset OnStart = OnStartSlide;
    preset SnapNext = <0,60>;
    preset Friction = 0.2;
  }

  $rect <20,20,160,60>
  object Core::SlideTouchHandler TouchHandlerMinute
  {
    preset Bounds = <94,7,155,186>;
    preset OnSlide = OnSlideMinute;
    preset OnEnd = OnEndSlide;
    preset OnStart = OnStartSlide;
    preset SnapNext = <0,60>;
    preset Friction = 0.2;
  }

  // This variable stores the current state of the time picker.
  $rect <480,320,680,360>
  var bool enabled = true;

  $rect <20,20,160,60>
  object Core::SlideTouchHandler TouchHandlerHour
  {
    preset Bounds = <19,6,80,186>;
    preset OnSlide = OnSlideHour;
    preset OnEnd = OnEndSlide;
    preset OnStart = OnStartSlide;
    preset SnapNext = <0,60>;
    preset Friction = 0.2;
  }

  $rect <20,20,160,60>
  object Core::VerticalList ListSecond
  {
    preset Bounds = <169,7,230,187>;
    preset Enabled = true;
    preset OnLoadItem = OnLoadSecondItem;
    preset Endless = true;
    preset SlideHandler = TouchHandlerSecond;
    preset ScrollOffset = 60;
    preset SelectedItem = -1;
    preset ItemHeight = 60;
    preset NoOfItems = 60;
  }

  $rect <20,20,160,60>
  object Core::VerticalList ListMinute
  {
    preset Bounds = <94,7,155,187>;
    preset Enabled = true;
    preset OnLoadItem = OnLoadMinuteItem;
    preset Endless = true;
    preset SlideHandler = TouchHandlerMinute;
    preset ScrollOffset = 60;
    preset ItemHeight = 60;
    preset NoOfItems = 60;
  }

  $rect <20,20,160,60>
  object Core::VerticalList ListHour
  {
    preset Bounds = <19,7,80,188>;
    preset Enabled = true;
    preset OnLoadItem = OnLoadHourItem;
    preset Endless = true;
    preset SlideHandler = TouchHandlerHour;
    preset ScrollOffset = 60;
    preset SelectedItem = 2;
    preset ItemHeight = 60;
    preset NoOfItems = 24;
  }

  $rect <20,20,160,60>
  object Views::Text Separator1
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToTop];
    preset Bounds = <155,61,169,116>;
    preset String = ":";
    preset Font = Clock::SecondFont;
    preset Color = #FFFFFFFF;
  }

  $rect <20,20,160,60>
  object Views::Text Separator2
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToTop];
    preset Bounds = <80,61,94,116>;
    preset String = ":";
    preset Font = Clock::SecondFont;
    preset Color = #FFFFFFFF;
  }

  // The property 'OnChange' can refer to a slot method, which will receive a signal \
  // each time the user select another time. Thereupon the method's logic will be \
  // executed. In the associated slot method you can evaluate the time picker properties \
  // @Hour, @Minute and @Second.
  $rect <269,150,469,190>
  property slot OnChange = null;

  // The property 'Second' stores the number of seconds after the minute. The value \
  // is valid in range 0 .. 59.
  $rect <669,10,869,50>
  property int32 Second = 0;

  // The property 'Minute' stores the number of minutes after the hour. The value \
  // is valid in range 0 .. 59.
  $rect <469,10,669,50>
  property int32 Minute = 0;

  // The property 'Hour' stores the number of hours since midnight. The value is \
  // valid in range 0 .. 23.
  $rect <269,10,469,50>
  property int32 Hour = 0;

  // This method is called when one of the Slide Touch Handler (TouchHandlerDay, \
  // TouchHandlerMonth or TouchHandlerYear) has finished the slide animation. Thereupon \
  // the owner of the date picker is notified, that the date has been changed.
  $rect <250,450,450,490>
  slot OnSlideSecond
  {
    ListSecond.InvalidateItems( 0, ListSecond.NoOfItems );
  }

  // This method is called when one of the Slide Touch Handler (TouchHandlerDay, \
  // TouchHandlerMonth or TouchHandlerYear) has finished the slide animation. Thereupon \
  // the owner of the date picker is notified, that the date has been changed.
  $rect <250,410,450,450>
  slot OnSlideMinute
  {
    ListMinute.InvalidateItems( 0, ListMinute.NoOfItems );
  }

  // This method is called when one of the Slide Touch Handler (TouchHandlerDay, \
  // TouchHandlerMonth or TouchHandlerYear) has finished the slide animation. Thereupon \
  // the owner of the date picker is notified, that the date has been changed.
  $rect <250,370,450,410>
  slot OnSlideHour
  {
    ListHour.InvalidateItems( 0, ListHour.NoOfItems );
  }

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler Cover
  {
    preset Point4 = <0,0>;
    preset Point3 = <247,0>;
    preset Point2 = <247,197>;
    preset Point1 = <0,197>;
    preset Enabled = false;
  }

  $rect <690,240,890,280>
  var point HourCenter = <30,90>;

  $rect <690,279,890,319>
  var point MinuteCenter = <124,90>;

  $rect <690,320,890,360>
  var point SecondCenter = <199,90>;

  $rect <470,150,670,190>
  method void SetTime( arg int32 value )
  {
    var int32 hours = 0; 
    var int32 minutes= 0;
    var int32 seconds = value;

    minutes= int32(seconds/60);
    seconds-=minutes*60;

    hours=int32(minutes/60);
    minutes-=hours*60;

    Second=seconds;
    Minute=minutes;
    Hour=hours;

  }

  $rect <890,240,1090,280>
  object Effects::ColorEffect ColorEffect
  {
    preset OnFinished = OnFinishedFlash;
    preset Symmetric = true;
    preset NoOfCycles = 5;
    preset Enabled = false;
    preset Value2 = #FF0000FF;
    preset Value1 = #FFFFFFFF;
    preset Outlet = ^TimeColor;
  }

  $rect <690,370,890,410>
  property color TimeColor = #FFFFFFFF;

  $rect <690,410,890,440>
  onset TimeColor
  {
    // The value doesn't change - nothing to do.
    if ( pure TimeColor == value )
      return;

    // Remember the property's new value.
    pure TimeColor = value;

    UpdateCenterFont(ListSecond,SecondCenter); 
    UpdateCenterFont(ListMinute,MinuteCenter); 
    UpdateCenterFont(ListHour,HourCenter); 
    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <690,450,890,490>
  onget TimeColor
  {
    return pure TimeColor;
  }

  $rect <670,150,870,190>
  method void UpdateCenterFont( arg Core::VerticalList TextList, arg point Center )
  {
    var int32 itemCenter = TextList.GetItemAtPosition( Center );
    var Views::Text itemView = (Views::Text)TextList.GetViewForItem( itemCenter );
    var int32 itemBelow = TextList.GetItemAtPosition( Center + <0,60>);
    var Views::Text itemBelowView = (Views::Text)TextList.GetViewForItem( itemBelow );

    if(itemView!=null) 
    {
      itemView.Color=TimeColor;
      itemView.Font = Clock::SecondFont;
    }
    if(itemBelowView!=null)
    {
      itemBelowView.Color=#FFFFFF80;
      itemBelowView.Font = Clock::SmallerSecondFont;
    }
  }

  $rect <870,150,1070,190>
  method void End( arg bool TimeOut )
  {
    if(TimeOut)
    {
      ColorEffect.Enabled=true;
    }
    else
    {
      Cover.Enabled=false;
    }
  }

  $rect <890,280,1090,320>
  slot OnFinishedFlash
  {
    Cover.Enabled=false;
  }

  $reorder OnSetOpacity 9
  $reorder OnGetEmbedded 9
  $reorder OnSetEmbedded 9
  $reorder OnGetAlphaBlended 9
  $reorder OnSetAlphaBlended 9
  $reorder OnGetVisible 9
  $reorder OnSetVisible 9
  $reorder DrawForeground 9
  $reorder DrawBackground 9
  $reorder GetMinimalSize 9
  $reorder FindActiveDialogByClass 9
  $reorder FindDialogByClass 9
  $reorder FindCurrentDialog 9
  $reorder IsCurrentDialog 9
  $reorder IsActiveDialog 9
  $reorder IsDialog 9
  $reorder GetIndexOfDialog 9
  $reorder GetDialogAtIndex 9
  $reorder CountDialogs 9
  $reorder SwitchToDialog 9
  $reorder DismissDialog 9
  $reorder PresentDialog 9
  $reorder ObtainFocus 9
  $reorder HasViewState 9
  $reorder LocalPosition 9
  $reorder GlobalPosition 9
  $reorder DispatchEvent 9
  $reorder BroadcastEventAtPosition 9
  $reorder BroadcastEvent 9
  $reorder UpdateLayout 9
  $reorder UpdateViewState 9
  $reorder InvalidateLayout 9
  $reorder InvalidateViewState 9
  $reorder InvalidateArea 9
  $reorder GetIndexOfView 9
  $reorder GetViewAtIndex 9
  $reorder CountViews 9
  $reorder FindViewInDirection 9
  $reorder FindViewWithinArea 9
  $reorder FindViewAtPosition 9
  $reorder FindPrevView 9
  $reorder FindNextView 9
  $reorder FindSiblingView 9
  $reorder GetContentArea 9
  $reorder FadeGroup 9
  $reorder RestackBehind 9
  $reorder RestackBack 9
  $reorder RestackTop 9
  $reorder Restack 9
  $reorder RemoveAll 9
  $reorder Remove 9
  $reorder Opacity 14
  $reorder Embedded 14
  $reorder AlphaBlended 14
  $reorder Visible 14
  $reorder Note3 14
  $reorder Note2 14
  $reorder Note1 14
  $reorder sliding 14
  $reorder selected 14
  $reorder OnEndSlide 14
  $reorder OnStartSlide 14
  $reorder OnLoadSecondItem 14
  $reorder OnLoadMinuteItem 14
  $reorder OnLoadHourItem 14
  $reorder OnGetSecond 14
  $reorder OnSetSecond 14
  $reorder OnGetMinute 14
  $reorder OnSetMinute 14
  $reorder OnGetHour 14
  $reorder OnSetHour 14
  $reorder BorderCurrent 14
  $reorder TouchHandlerSecond 14
  $reorder TouchHandlerMinute 14
  $reorder enabled 14
  $reorder TouchHandlerHour 14
  $reorder ListSecond 14
  $reorder ListMinute 14
  $reorder ListHour 14
  $reorder Separator1 14
  $reorder Separator2 14
  $reorder OnChange 14
  $reorder Second 14
  $reorder Minute 14
  $reorder Hour 14
  $reorder OnSlideSecond 14
  $reorder OnSlideMinute 14
  $reorder OnSlideHour 14
  $reorder AddBehind 9
  $reorder Add 9
  $reorder Focus 9
  $reorder Buffered 9
}

$rect <80,230,280,270>
$output false
class TimerScreen : Core::Group
{
  $rect <0,540,200,580>
  inherited method Init()
  {
    postsignal UpdateTime;
  }

  $rect <0,500,200,540>
  inherited property Bounds = rect(0,0,$ScreenSize.x,$ScreenSize.y);

  $rect <0,590,200,630>
  object Core::Timer Timer
  {
    preset OnTrigger = UpdateTime;
    preset Period = 100;
    preset Enabled = true;
  }

  $rect <0,630,190,670>
  object Core::Time Time;

  $rect <210,590,410,630>
  slot WipeUpSlot
  {
    Owner.SwitchToDialog(new Clock::ClockScreen, Effects::SlideUpCentered, null, null, null, null, null, null, null, null, false );
  }

  $rect <210,500,410,540>
  slot UpdateTime
  {
    var Core::Time currentTime = Time.CurrentTime;
    Hour.String=string(currentTime.Hour/10)+string(currentTime.Hour%10)+":"+string(currentTime.Minute/10)+string(currentTime.Minute%10);
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Bounds = <0,0,640,480>;
    preset Color = #00000058;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle1
  {
    preset Bounds = <0,439,640,480>;
    preset ColorBL = #4D5784FF;
    preset ColorBR = #4D5784FF;
    preset ColorTR = #4D578453;
    preset ColorTL = #4D578453;
  }

  $rect <20,20,160,60>
  object Views::Image Image
  {
    preset Bounds = <295,430,345,480>;
    preset Bitmap = Resources::NavigationIconsMedium;
  }

  $rect <20,20,160,60>
  object Core::WipeTouchHandler WipeUp
  {
    preset Bounds = <0,430,640,479>;
    preset OnTop = WipeUpSlot;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle2
  {
    preset Bounds = <0,0,640,41>;
    preset ColorBL = #4D5784FF;
    preset ColorBR = #4D5784FF;
    preset ColorTR = #4D5784FF;
    preset ColorTL = #4D5784FF;
    preset Color = #FFFFFFFF;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle3
  {
    preset Bounds = <0,39,640,80>;
    preset ColorBL = #4D578453;
    preset ColorBR = #4D578453;
    preset ColorTR = #4D5784FF;
    preset ColorTL = #4D5784FF;
  }

  $rect <20,20,160,60>
  object Views::Text Hour
  {
    preset Bounds = <458,9,640,70>;
    preset Alignment = Views::TextAlignment[AlignHorzAuto, AlignHorzCenter, AlignVertCenter];
    preset String = "Text";
    preset Font = Clock::SecondFont;
  }

  $rect <20,20,160,60>
  object Clock::TimerClock TimerClock
  {
    preset Bounds = <131,26,510,405>;
    preset OnChange = ChangeButtons;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton StartButton
  {
    preset Bounds = <330,355,430,404>;
    preset Enabled = false;
    preset OnPress = OnStart;
    preset Label = "Start";
    preset Appearance = WidgetSet::PushButton_Medium;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton CancelButton
  {
    preset Bounds = <210,355,304,405>;
    preset Enabled = false;
    preset OnPress = OnCancel;
    preset Label = "Cancel";
    preset Appearance = WidgetSet::PushButton_Medium;
  }

  $rect <0,680,200,720>
  slot OnStart
  {
    switch(StartButton.Label=="Stop")
    {
      case true:
      {
        TimerClock.Enabled=false;
        StartButton.Label="Start";
      }
      case false:
      {
        TimerClock.Enabled=true;
        StartButton.Label="Stop";
      }
      default:;
    }              

  }

  $rect <198,680,400,720>
  slot OnCancel
  {
    TimerClock.ResetTime(false);

  }

  $rect <419,590,619,630>
  slot ChangeButtons
  {
    StartButton.Enabled=(TimerClock.Running && TimerClock.MaxValue>0);
    CancelButton.Enabled=TimerClock.Running;

    if(!TimerClock.Running) StartButton.Label="Start";

  }
}

$rect <80,270,280,310>
$output false
class ChronometerScreen : Core::Group
{
  $rect <0,540,200,580>
  inherited method Init()
  {
    postsignal UpdateTime;

  }

  $rect <0,500,200,540>
  inherited property Bounds = rect(0,0,$ScreenSize.x,$ScreenSize.y);

  $rect <0,590,200,630>
  object Core::Timer Timer
  {
    preset OnTrigger = UpdateTime;
    preset Period = 100;
    preset Enabled = true;
  }

  $rect <210,590,410,630>
  slot WipeUpSlot
  {
    Owner.SwitchToDialog(new Clock::ClockScreen, Effects::SlideUpCentered, null, null, null, null, null, null, null, null, false );
  }

  $rect <210,500,410,540>
  slot UpdateTime
  {
    var Core::Time currentTime = Clock::Time.CurrentTime;
    Hour.String=string(currentTime.Hour/10)+string(currentTime.Hour%10)+":"+string(currentTime.Minute/10)+string(currentTime.Minute%10);
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Bounds = <0,0,640,480>;
    preset Color = #00000058;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle1
  {
    preset Bounds = <0,439,640,480>;
    preset ColorBL = #4D5784FF;
    preset ColorBR = #4D5784FF;
    preset ColorTR = #4D578453;
    preset ColorTL = #4D578453;
  }

  $rect <20,20,160,60>
  object Views::Image Image
  {
    preset Bounds = <295,430,345,480>;
    preset Bitmap = Resources::NavigationIconsMedium;
  }

  $rect <20,20,160,60>
  object Core::WipeTouchHandler WipeUp
  {
    preset Bounds = <0,430,640,479>;
    preset OnTop = WipeUpSlot;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle2
  {
    preset Bounds = <0,0,640,41>;
    preset ColorBL = #4D5784FF;
    preset ColorBR = #4D5784FF;
    preset ColorTR = #4D5784FF;
    preset ColorTL = #4D5784FF;
    preset Color = #FFFFFFFF;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle3
  {
    preset Bounds = <0,39,640,80>;
    preset ColorBL = #4D578453;
    preset ColorBR = #4D578453;
    preset ColorTR = #4D5784FF;
    preset ColorTL = #4D5784FF;
  }

  $rect <20,20,160,60>
  object Views::Text Hour
  {
    preset Bounds = <458,9,640,70>;
    preset Alignment = Views::TextAlignment[AlignHorzAuto, AlignHorzCenter, AlignVertCenter];
    preset String = "Text";
    preset Font = Clock::SecondFont;
  }

  $rect <20,20,160,60>
  object Clock::Chronometer Chronometer
  {
    preset Bounds = <62,172,579,343>;
    preset OnChange = ChangeButtons;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton ResetButton
  {
    preset Bounds = <244,357,394,407>;
    preset Enabled = false;
    preset OnPress = OnResetButton;
    preset Label = "Reset";
    preset Appearance = WidgetSet::PushButton_Medium;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PauseButton
  {
    preset Bounds = <94,357,244,407>;
    preset Enabled = true;
    preset OnPress = OnPauseButton;
    preset Label = "Start";
    preset Appearance = WidgetSet::PushButton_Medium;
  }

  $rect <210,630,410,670>
  slot ChangeButtons
  {
    ResetButton.Enabled=Chronometer.Running;
    SaveButton.Enabled=Chronometer.Running;
  }

  $rect <410,539,610,579>
  slot OnPauseButton
  {
    switch(PauseButton.Label=="Pause")
    {
      case true:
      {
        Chronometer.Enabled=false;
        PauseButton.Label="Start";
      }
      case false:
      {
        if(!Chronometer.Running) Chronometer.Running=true;
        Chronometer.Enabled=true;
        PauseButton.Label="Pause";
      }
      default:;
    }

  }

  $rect <410,579,610,619>
  slot OnResetButton
  {
    Chronometer.Enabled=false;
    Chronometer.Running=false;
    Chronometer.CurrentValue=0;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton SaveButton
  {
    preset Bounds = <394,357,544,407>;
    preset Enabled = false;
    preset OnPress = OnSaveButton;
    preset Label = "Save";
    preset Appearance = WidgetSet::PushButton_Medium;
  }

  $rect <410,619,610,659>
  slot OnSaveButton
  {
    var Views::Text txt=new Views::Text;
    txt.Embedded=true;
    txt.Bounds=<0,0,320,50>;
    txt.Font=Clock::SecondFont;
    txt.String=Chronometer.HourText.String+":"+ Chronometer.MinuteText.String+":"+Chronometer.SecondText.String+":"+Chronometer.MillisecondText.String;
    Add( txt, 0 );
    postsignal UpdateOutline;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle4
  {
    preset Bounds = <320,110,640,160>;
    preset ColorBL = #4D57844A;
    preset ColorBR = #4D578492;
    preset ColorTR = #4D578492;
    preset ColorTL = #4D57844A;
    preset Color = #FFFFFFFF;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle5
  {
    preset Bounds = <0,110,320,160>;
    preset ColorBL = #4D578492;
    preset ColorBR = #4D57844A;
    preset ColorTR = #4D57844A;
    preset ColorTL = #4D578492;
    preset Color = #FFFFFFFF;
  }

  $rect <20,20,160,60>
  object Views::Image Image1
  {
    preset Bounds = <595,110,645,160>;
    preset ScrollOffset = <0,0>;
    preset FrameNumber = 3;
    preset Bitmap = Resources::NavigationIconsMedium;
  }

  $rect <20,20,160,60>
  object Views::Image Image2
  {
    preset Bounds = <0,110,50,160>;
    preset ScrollOffset = <0,0>;
    preset FrameNumber = 2;
    preset Bitmap = Resources::NavigationIconsMedium;
  }

  $rect <210,670,410,710>
  slot UpdateOutline
  {
    var Core::View view=Outline.GetViewAtIndex( Outline.CountViews()-1 );
    Outline.EnsureVisible( view, true, Clock::PointEffect, null );
  }

  $rect <20,20,160,60>
  object Core::Outline Outline
  {
    preset Bounds = <0,110,640,160>;
    preset OnUpdate = null;
    preset SlideHandler = SlideTouchHandler;
    preset Formation = Core::Formation.LeftToRight;
  }

  $rect <20,20,160,60>
  object Core::SlideTouchHandler SlideTouchHandler
  {
    preset Bounds = <0,110,640,160>;
    preset SnapNext = <0,50>;
    preset SlideVert = false;
    preset RubberBandEffectElasticity = 5.0;
  }
}

// This class implements an 'instrument', used to display e.g. measured values. The \
// widget is controlled by the properties @CurrentValue and @Unit.
// Alternatively the property @Outlet can refer to any other 'int32' property the \
// widget should remain synchronized with. When the referred property is modified \
// by another one, the widget is automatically notified to remain in sync with the \
// property.
// This approach follows the Model-View-Controller (MVC) programming paradigm. Here \
// the widget represents the 'View' and the property referred via 'Outlet' can be \
// seen as a part of the 'Model'.
$rect <-130,410,70,450>
$output false
class Chronometer : Templates::ValueDisplay
{
  $rect <599,239,799,279>
  inherited property Bounds = <0,0,517,171>;

  $rect <20,20,160,60>
  object Views::Text HourText
  {
    preset Bounds = <23,0,141,171>;
    preset String = "00";
    preset Font = Clock::SmallerTimeFont;
  }

  $rect <20,20,160,60>
  object Views::Text Dots1
  {
    preset Bounds = <141,0,170,149>;
    preset String = ":";
    preset Font = Clock::SmallerTimeFont;
  }

  $rect <20,20,160,60>
  object Views::Text MinuteText
  {
    preset Bounds = <170,0,288,171>;
    preset String = "00";
    preset Font = Clock::SmallerTimeFont;
  }

  $rect <20,20,160,60>
  object Views::Text Dots2
  {
    preset Bounds = <288,0,317,149>;
    preset String = ":";
    preset Font = Clock::SmallerTimeFont;
  }

  $rect <810,10,1010,50>
  inherited property Enabled = false;

  $rect <20,20,160,60>
  object Views::Text SecondText
  {
    preset Bounds = <317,0,435,171>;
    preset String = "00";
    preset Font = Clock::SmallerTimeFont;
  }

  $rect <20,20,160,60>
  object Views::Text MillisecondText
  {
    preset Bounds = <435,21,495,171>;
    preset String = "00";
    preset Font = Clock::SecondFont;
  }

  $rect <998,240,1198,280>
  object Core::Timer Timer
  {
    preset OnTrigger = UpdateTime;
    preset Period = 100;
    preset Enabled = false;
  }

  $rect <998,280,1198,320>
  slot UpdateTime
  {
    CurrentValue++;
  }

  $rect <798,239,998,279>
  method void SetTime( arg int32 value )
  {
    var int32 hours = 0; 
    var int32 minutes= 0;
    var int32 seconds = 0;
    var int32 milliseconds=value;

    seconds= int32(milliseconds/60);
    milliseconds-=seconds*60;

    minutes= int32(seconds/60);
    seconds-=minutes*60;

    hours=int32(minutes/60);
    minutes-=hours*60;

    HourText.String=string(hours,2);
    MinuteText.String=string(minutes,2);
    SecondText.String=string(seconds,2);
    MillisecondText.String=string(milliseconds,2);

  }

  $rect <601,8,801,48>
  property int32 CurrentValue = 0;

  $rect <601,48,801,88>
  onset CurrentValue
  {
    // The value doesn't change - nothing to do.
    if ( pure CurrentValue == value )
      return;

    // Remember the property's new value.
    pure CurrentValue = value;

    if(CurrentValue>=21599999) Enabled=false;
    SetTime(value);


  }

  $rect <601,88,801,128>
  onget CurrentValue
  {
    return pure CurrentValue;
  }

  $rect <810,50,1010,90>
  inherited onset Enabled
  {
    pure Enabled = value;

    Timer.Enabled=value;
  }

  $rect <810,90,1010,130>
  inherited onget Enabled
  {
    return pure Enabled;
  }

  // The property 'OnChange' can refer to a slot method, which will receive a signal \
  // each time the user select another time. Thereupon the method's logic will be \
  // executed. In the associated slot method you can evaluate the time picker properties \
  // @Hour, @Minute and @Second.
  $rect <599,130,799,170>
  property slot OnChange = null;

  // The property 'Enabled' determines whether the component is able to react to \
  // user input events. Disabled components will never receive these events.
  // The @Enabled property is reflected in the current state of the component Core::ViewState.Enabled. \
  // This state can be evaluated in the implementation of the @UpdateViewState() \
  // method. For example, the method may show disabled components with pale colors, \
  // etc.
  // Please note, changing the enabled state of the component currently selected \
  // in the @Focus property will cause the framework to select other sibling view, \
  // which will be able to react to keyboard events.
  $rect <999,10,1199,50>
  property bool Running = false;

  $rect <999,50,1199,90>
  onset Running
  {
    pure Running = value;

    postsignal OnChange;
  }

  $rect <999,90,1199,130>
  onget Running
  {
    return pure Running;
  }

  $reorder OnSetOpacity 4
  $reorder OnGetEmbedded 4
  $reorder OnSetEmbedded 4
  $reorder OnGetAlphaBlended 4
  $reorder OnSetAlphaBlended 4
  $reorder OnGetVisible 4
  $reorder OnSetVisible 4
  $reorder DrawForeground 4
  $reorder DrawBackground 4
  $reorder GetMinimalSize 4
  $reorder FindActiveDialogByClass 4
  $reorder FindDialogByClass 4
  $reorder FindCurrentDialog 4
  $reorder IsCurrentDialog 4
  $reorder IsActiveDialog 4
  $reorder IsDialog 4
  $reorder GetIndexOfDialog 4
  $reorder GetDialogAtIndex 4
  $reorder CountDialogs 4
  $reorder SwitchToDialog 4
  $reorder DismissDialog 4
  $reorder PresentDialog 4
  $reorder ObtainFocus 4
  $reorder HasViewState 4
  $reorder LocalPosition 4
  $reorder GlobalPosition 4
  $reorder DispatchEvent 4
  $reorder BroadcastEventAtPosition 4
  $reorder BroadcastEvent 4
  $reorder UpdateLayout 4
  $reorder UpdateViewState 4
  $reorder InvalidateLayout 4
  $reorder InvalidateViewState 4
  $reorder InvalidateArea 4
  $reorder GetIndexOfView 4
  $reorder GetViewAtIndex 4
  $reorder CountViews 4
  $reorder FindViewInDirection 4
  $reorder FindViewWithinArea 4
  $reorder FindViewAtPosition 4
  $reorder FindPrevView 4
  $reorder FindNextView 4
  $reorder FindSiblingView 4
  $reorder GetContentArea 4
  $reorder FadeGroup 4
  $reorder RestackBehind 4
  $reorder RestackBack 4
  $reorder RestackTop 4
  $reorder Restack 4
  $reorder RemoveAll 4
  $reorder Remove 4
  $reorder Opacity 9
  $reorder Embedded 9
  $reorder AlphaBlended 9
  $reorder Visible 9
  $reorder HourText 9
  $reorder Dots1 9
  $reorder MinuteText 9
  $reorder Dots2 9
  $reorder Enabled 8
  $reorder SecondText 8
  $reorder MillisecondText 8
  $reorder Timer 8
  $reorder UpdateTime 8
  $reorder SetTime 8
  $reorder CurrentValue 8
  $reorder OnSetCurrentValue 8
  $reorder OnGetCurrentValue 8
  $reorder AddBehind 4
  $reorder Add 4
  $reorder Focus 4
  $reorder Buffered 4
  $reorder OnSetEnabled 2
}

$rect <279,70,479,110>
$output false
autoobject Effects::PointEffect PointEffect;

$rect <480,230,680,270>
$output false
resource Resources::Font SmallerSecondFont
{
  attr fontname FontName = Agency FB;
  attr fontheight Height = 35;
  attr fontheightmode HeightMode = Popular;
  attr fontquality Quality = High;
  attr fontranges Ranges = 0x20-0xFF;
  attr fontaspectratio AspectRatio = 1;
  attr fontbold Bold = true;
  attr fontitalic Italic = false;
  attr fontkerning Kerning = true;
  attr fontrowdistance RowDistance;
}

$rect <80,310,280,350>
$output false
class AlarmScreen : Core::Group
{
  $rect <0,540,200,580>
  inherited method Init()
  {
    postsignal UpdateTime;

  }

  $rect <0,500,200,540>
  inherited property Bounds = rect(0,0,$ScreenSize.x,$ScreenSize.y);

  $rect <0,590,200,630>
  object Core::Timer Timer
  {
    preset OnTrigger = UpdateTime;
    preset Period = 100;
    preset Enabled = true;
  }

  $rect <210,590,410,630>
  slot WipeUpSlot
  {
    Owner.SwitchToDialog(new Clock::ClockScreen, Effects::SlideUpCentered, null, null, null, null, null, null, null, null, false );
  }

  $rect <210,500,410,540>
  slot UpdateTime
  {
    var Core::Time currentTime =  Clock::Time.CurrentTime;
    Hour.String=string(currentTime.Hour/10)+string(currentTime.Hour%10)+":"+string(currentTime.Minute/10)+string(currentTime.Minute%10);
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Bounds = <0,0,640,480>;
    preset Color = #00000058;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle1
  {
    preset Bounds = <0,439,640,480>;
    preset ColorBL = #4D5784FF;
    preset ColorBR = #4D5784FF;
    preset ColorTR = #4D578453;
    preset ColorTL = #4D578453;
  }

  $rect <20,20,160,60>
  object Views::Image Image
  {
    preset Bounds = <295,430,345,480>;
    preset Bitmap = Resources::NavigationIconsMedium;
  }

  $rect <20,20,160,60>
  object Core::WipeTouchHandler WipeUp
  {
    preset Bounds = <0,430,640,479>;
    preset OnTop = WipeUpSlot;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle2
  {
    preset Bounds = <0,0,640,41>;
    preset ColorBL = #4D5784FF;
    preset ColorBR = #4D5784FF;
    preset ColorTR = #4D5784FF;
    preset ColorTL = #4D5784FF;
    preset Color = #FFFFFFFF;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle3
  {
    preset Bounds = <0,39,640,80>;
    preset ColorBL = #4D578453;
    preset ColorBR = #4D578453;
    preset ColorTR = #4D5784FF;
    preset ColorTL = #4D5784FF;
  }

  $rect <20,20,160,60>
  object Views::Text Hour
  {
    preset Bounds = <458,9,640,70>;
    preset Alignment = Views::TextAlignment[AlignHorzAuto, AlignHorzCenter, AlignVertCenter];
    preset String = "00:00";
    preset Font = Clock::SecondFont;
  }

  $rect <20,20,160,60>
  object Clock::TimePicker TimePicker
  {
    preset Bounds = <125,128,373,325>;
  }

  $rect <20,20,160,60>
  object Clock::DayOfTheWeekPicker DayOfTheWeekPicker
  {
    preset Bounds = <40,331,458,390>;
  }

  $rect <20,20,160,60>
  object Views::Line Line;

  $rect <20,20,160,60>
  object Views::Line Line1
  {
    preset Point2 = <507,390>;
    preset Point1 = <507,128>;
    preset Width = 3;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton AddButton
  {
    preset Bounds = <539,213,615,289>;
    preset OnPress = OnAddButton;
    preset Label = "+";
    preset Appearance = WidgetSet::PushButton_Medium;
  }

  $rect <410,500,610,540>
  slot OnAddButton
  {
    sender; /* the method is called from the sender object */
  }
}

$rect <80,350,280,390>
$output false
class CalendarScreen : Core::Group
{
  $rect <0,540,200,580>
  inherited method Init()
  {
    postsignal UpdateTime;

  }

  $rect <0,500,200,540>
  inherited property Bounds = rect(0,0,$ScreenSize.x,$ScreenSize.y);

  $rect <0,590,200,630>
  object Core::Timer Timer
  {
    preset OnTrigger = UpdateTime;
    preset Period = 100;
    preset Enabled = true;
  }

  $rect <210,590,410,630>
  slot WipeUpSlot
  {
    Owner.SwitchToDialog(new Clock::ClockScreen, Effects::SlideUpCentered, null, null, null, null, null, null, null, null, false );
  }

  $rect <210,500,410,540>
  slot UpdateTime
  {
    var Core::Time currentTime =  Clock::Time.CurrentTime;
    Hour.String=string(currentTime.Hour/10)+string(currentTime.Hour%10)+":"+string(currentTime.Minute/10)+string(currentTime.Minute%10);
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Bounds = <0,0,640,480>;
    preset Color = #00000058;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle1
  {
    preset Bounds = <0,439,640,480>;
    preset ColorBL = #4D5784FF;
    preset ColorBR = #4D5784FF;
    preset ColorTR = #4D578453;
    preset ColorTL = #4D578453;
  }

  $rect <20,20,160,60>
  object Views::Image Image
  {
    preset Bounds = <295,430,345,480>;
    preset Bitmap = Resources::NavigationIconsMedium;
  }

  $rect <20,20,160,60>
  object Core::WipeTouchHandler WipeUp
  {
    preset Bounds = <0,430,640,479>;
    preset OnTop = WipeUpSlot;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle2
  {
    preset Bounds = <0,0,640,41>;
    preset ColorBL = #4D5784FF;
    preset ColorBR = #4D5784FF;
    preset ColorTR = #4D5784FF;
    preset ColorTL = #4D5784FF;
    preset Color = #FFFFFFFF;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle3
  {
    preset Bounds = <0,39,640,80>;
    preset ColorBL = #4D578453;
    preset ColorBR = #4D578453;
    preset ColorTR = #4D5784FF;
    preset ColorTL = #4D5784FF;
  }

  $rect <20,20,160,60>
  object Views::Text Hour
  {
    preset Bounds = <458,9,640,70>;
    preset String = "Text";
    preset Font = Clock::SecondFont;
  }

  $rect <20,20,160,60>
  object Clock::Chronometer Chronometer
  {
    preset Bounds = <62,172,579,343>;
    preset OnChange = ChangeButtons;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton ResetButton
  {
    preset Bounds = <244,357,394,407>;
    preset Enabled = false;
    preset OnPress = OnResetButton;
    preset Label = "Reset";
    preset Appearance = WidgetSet::PushButton_Medium;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PauseButton
  {
    preset Bounds = <94,357,244,407>;
    preset Enabled = true;
    preset OnPress = OnPauseButton;
    preset Label = "Start";
    preset Appearance = WidgetSet::PushButton_Medium;
  }

  $rect <210,630,410,670>
  slot ChangeButtons
  {
    ResetButton.Enabled=Chronometer.Running;
    SaveButton.Enabled=Chronometer.Running;
  }

  $rect <410,539,610,579>
  slot OnPauseButton
  {
    switch(PauseButton.Label=="Pause")
    {
      case true:
      {
        Chronometer.Enabled=false;
        PauseButton.Label="Start";
      }
      case false:
      {
        if(!Chronometer.Running) Chronometer.Running=true;
        Chronometer.Enabled=true;
        PauseButton.Label="Pause";
      }
      default:;
    }

  }

  $rect <410,579,610,619>
  slot OnResetButton
  {
    Chronometer.Enabled=false;
    Chronometer.Running=false;
    Chronometer.CurrentValue=0;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton SaveButton
  {
    preset Bounds = <394,357,544,407>;
    preset Enabled = false;
    preset OnPress = OnSaveButton;
    preset Label = "Save";
    preset Appearance = WidgetSet::PushButton_Medium;
  }

  $rect <410,619,610,659>
  slot OnSaveButton
  {
    var Views::Text txt=new Views::Text;
    txt.Embedded=true;
    txt.Bounds=<0,0,320,50>;
    txt.Font=Clock::SecondFont;
    txt.String=Chronometer.HourText.String+":"+ Chronometer.MinuteText.String+":"+Chronometer.SecondText.String+":"+Chronometer.MillisecondText.String;
    Add( txt, 0 );
    postsignal UpdateOutline;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle4
  {
    preset Bounds = <320,110,640,160>;
    preset ColorBL = #4D57844A;
    preset ColorBR = #4D578492;
    preset ColorTR = #4D578492;
    preset ColorTL = #4D57844A;
    preset Color = #FFFFFFFF;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle5
  {
    preset Bounds = <0,110,320,160>;
    preset ColorBL = #4D578492;
    preset ColorBR = #4D57844A;
    preset ColorTR = #4D57844A;
    preset ColorTL = #4D578492;
    preset Color = #FFFFFFFF;
  }

  $rect <20,20,160,60>
  object Views::Image Image1
  {
    preset Bounds = <595,110,645,160>;
    preset ScrollOffset = <0,0>;
    preset FrameNumber = 3;
    preset Bitmap = Resources::NavigationIconsMedium;
  }

  $rect <20,20,160,60>
  object Views::Image Image2
  {
    preset Bounds = <0,110,50,160>;
    preset ScrollOffset = <0,0>;
    preset FrameNumber = 2;
    preset Bitmap = Resources::NavigationIconsMedium;
  }

  $rect <210,670,410,710>
  slot UpdateOutline
  {
    var Core::View view=Outline.GetViewAtIndex( Outline.CountViews()-1 );
    Outline.EnsureVisible( view, true, Clock::PointEffect, null );
  }

  $rect <20,20,160,60>
  object Core::Outline Outline
  {
    preset Bounds = <0,110,640,160>;
    preset OnUpdate = null;
    preset SlideHandler = SlideTouchHandler;
    preset Formation = Core::Formation.LeftToRight;
  }

  $rect <20,20,160,60>
  object Core::SlideTouchHandler SlideTouchHandler
  {
    preset Bounds = <0,110,640,160>;
    preset SnapNext = <0,50>;
    preset SlideVert = false;
    preset RubberBandEffectElasticity = 5.0;
  }
}

// This class implements a 'radio button' widget. When the user presses the button, \
// the current value of the button represented by the property @Selected is set and \
// a signal is sent to the slot method stored in the property @OnSelect. Once selected, \
// the radio button remains in this state until the property @Selected is set to \
// the value 'false' (e.g. in reaction to another radio button selection).
// Alternatively the property @Outlet can refer to any other 'int32' property the \
// widget should remain synchronized with. When the user selects the radio button, \
// the affected property is automatically set to the value @OutletSelector. On the \
// other hand, when the referred property is modified by another one, the radio button \
// is automatically notified to remain in sync with the property.
// This approach follows the Model-View-Controller (MVC) programming paradigm. Here \
// the radio button represents the 'View' and 'Controller' and the property referred \
// via 'Outlet' can be seen as a part of the 'Model'.
$rect <-130,460,70,500>
$output false
class DayOfTheWeekPicker : Templates::RadioButton
{
  $rect <499,-10,699,30>
  inherited property Bounds = <0,0,418,59>;

  $rect <20,20,160,60>
  object Clock::DayButton MonButton
  {
    preset Bounds = <59,0,119,60>;
    preset WeekDay = 1;
    preset OnSelected = OnSelect;
    preset OnDeselected = OnDeselect;
  }

  $rect <20,20,160,60>
  object Clock::DayButton TueButton
  {
    preset Bounds = <118,0,178,60>;
    preset WeekDay = 2;
    preset OnSelected = OnSelect;
    preset OnDeselected = OnDeselect;
  }

  $rect <20,20,160,60>
  object Clock::DayButton WedButton
  {
    preset Bounds = <177,0,237,60>;
    preset WeekDay = 3;
    preset OnSelected = OnSelect;
    preset OnDeselected = OnDeselect;
  }

  $rect <20,20,160,60>
  object Clock::DayButton ThuButton
  {
    preset Bounds = <237,0,297,60>;
    preset WeekDay = 4;
    preset OnSelected = OnSelect;
    preset OnDeselected = OnDeselect;
  }

  $rect <20,20,160,60>
  object Clock::DayButton FriButton
  {
    preset Bounds = <297,0,357,60>;
    preset WeekDay = 5;
    preset OnSelected = OnSelect;
    preset OnDeselected = OnDeselect;
  }

  $rect <20,20,160,60>
  object Clock::DayButton SatButton
  {
    preset Bounds = <357,0,417,60>;
    preset WeekDay = 6;
    preset OnSelected = OnSelect;
    preset OnDeselected = OnDeselect;
  }

  $rect <20,20,160,60>
  object Clock::DayButton SunButton
  {
    preset Bounds = <0,0,60,60>;
    preset WeekDay = 0;
    preset OnSelected = OnSelect;
    preset OnDeselected = OnDeselect;
  }

  $rect <499,50,699,90>
  array bool SelectedDays[ 7 ] =
  (
    Default[0] = false;
    Default[1] = false;
    Default[2] = false;
    Default[3] = false;
    Default[4] = false;
    Default[5] = false;
    Default[6] = false;
  );

  $rect <730,-10,930,30>
  property int32 SelectedNumber = 0;

  $rect <730,30,930,70>
  onset SelectedNumber
  {
    // The value doesn't change - nothing to do.
    if ( pure SelectedNumber == value )
      return;

    // Remember the property's new value.
    pure SelectedNumber = value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <730,70,930,110>
  onget SelectedNumber
  {
    return pure SelectedNumber;
  }

  $rect <510,139,710,179>
  slot OnSelect
  {
    var Clock::DayButton selectedDay = (Clock::DayButton)sender;
    SelectedDays[selectedDay.WeekDay]=true;
    SelectedNumber++;
  }

  $rect <510,179,710,219>
  slot OnDeselect
  {
    var Clock::DayButton selectedDay = (Clock::DayButton)sender;
    SelectedDays[selectedDay.WeekDay]=false;
    SelectedNumber--;
  }
}

// This class implements a 'push button' widget. When the user presses the button, \
// a signal is sent to the slot method stored in its @OnActivate property.
$rect <-130,510,70,550>
$output false
class DayButton : Templates::PushButton
{
  $rect <480,310,680,350>
  inherited property Bounds = <0,0,60,60>;

  $rect <380,110,580,150>
  inherited onget Enabled
  {
    return pure Enabled;
  }

  $rect <380,70,580,110>
  inherited onset Enabled
  {
    if ( pure Enabled == value )
      return;

    pure Enabled = value;
  }

  $rect <380,30,580,70>
  inherited property Enabled = false;

  $rect <20,20,160,60>
  object Views::Bevel Bevel
  {
    preset Bounds = <0,0,60,59>;
    preset Width = 4;
    preset ColorL = #4D578453;
    preset ColorR = #4D5784FF;
    preset ColorB = #4D5784FF;
    preset ColorT = #4D578453;
  }

  $rect <20,20,160,60>
  object Views::Text Caption
  {
    preset Bounds = <5,0,53,59>;
    preset String = "Sun";
    preset Font = Clock::SmallerSecondFont;
  }

  $rect <180,-10,380,30>
  property int32 WeekDay = 0;

  $rect <180,30,380,70>
  onset WeekDay
  {
    // The value doesn't change - nothing to do.
    if ( pure WeekDay == value )
      return;

    // Remember the property's new value.
    pure WeekDay = value;

    ChangeWeekDayLabel(value);

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <180,70,380,110>
  onget WeekDay
  {
    return pure WeekDay;
  }

  $rect <380,-10,580,30>
  method void ChangeWeekDayLabel( arg int32 value )
  {
    Caption.String=Clock::Time.getDayOfWeekName( value, true );

  }

  $rect <180,110,380,150>
  property slot OnSelected;

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler SimpleTouchHandler
  {
    preset Point4 = <4,0>;
    preset Point3 = <53,0>;
    preset Point2 = <53,59>;
    preset Point1 = <4,59>;
    preset OnPress = ChangeState;
  }

  $rect <580,-10,780,30>
  slot ChangeState
  {
    switch(Enabled)
    {
      case true: 
      {
        Caption.Color=#8FFFF5FF;
        postsignal OnSelected;
      }
      case false:
      {
        Caption.Color=#FFFFFFFF;
        postsignal OnDeselected;
      }
      default:;
    }
    Enabled=!Enabled;
  }

  $rect <180,150,380,190>
  property slot OnDeselected;
}

$rect <-119,610,70,650>
$output false
autoobject Core::Time Time;

// This component implements a simple menu item.
$rect <80,560,280,600>
$output false
class EventItem : Templates::MenuItem
{
  $rect <310,-10,510,30>
  inherited property Bounds = <0,0,299,40>;

  $rect <510,30,710,70>
  onset Caption
  {
    // The value doesn't change - nothing to do.
    if ( pure Caption == value )
      return;

    // Remember the property's new value.
    pure Caption = value;

    // ... and update the text displayed in the item
    CaptionText.String = value;
  }

  $rect <20,20,160,60>
  object Views::Text CaptionText
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToRight, AlignToTop];
    preset Bounds = <57,1,291,39>;
    preset Ellipsis = true;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Event";
    preset Font = Resources::FontMedium;
    preset Color = #FFFFFFFF;
  }

  // The property 'Caption' stores the text to display within the item. 
  $rect <510,-10,710,30>
  property string Caption = "Event";

  $rect <20,20,160,60>
  object Views::Image Image
  {
    preset Bounds = <7,1,46,40>;
    preset Alignment = Views::ImageAlignment[AlignHorzCenter, AlignVertCenter];
    preset Bitmap = Resources::DefaultBitmap;
  }

  $rect <710,-10,910,30>
  property Resources::Bitmap Icon = Resources::DefaultFrame;

  $rect <710,30,910,70>
  onset Icon
  {
    // The value doesn't change - nothing to do.
    if ( pure Icon == value )
      return;

    // Remember the property's new value.
    pure Icon = value;

    Image.Bitmap=Icon;
    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <510,130,710,170>
  property bool IsMiniature = false;

  $rect <510,171,710,211>
  onset IsMiniature
  {
    // The value doesn't change - nothing to do.
    if ( pure IsMiniature == value )
      return;

    // Remember the property's new value.
    pure IsMiniature = value;

    Resize();
    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <310,-60,510,-20>
  method void Resize()
  {
    switch(IsMiniature)
    {
      case true: 
      {
        Bounds=<0,0,39,39>;
        SimpleTouchHandler.Enabled=false;
      }
      case false: 
      {
        Bounds=<0,0,300,39>;  
        SimpleTouchHandler.Enabled=true;
      }
      default:;
    }
  }

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler SimpleTouchHandler
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToTop, ResizeHorz, ResizeVert];
    preset Point4 = <0,0>;
    preset Point3 = <300,0>;
    preset Point2 = <299,38>;
    preset Point1 = <0,38>;
    preset OnPress = OnTouch;
  }

  $rect <310,80,510,120>
  slot OnTouch
  {
    IsExpanded=!IsExpanded;
  }

  $rect <510,-60,710,-20>
  method void Expand()
  {
    switch(IsExpanded)
    {
      case true: 
      {
        Bounds=<0,0,300,82>;
        CancelButton.Visible=true;
        CancelButton.Enabled=true;
      }
      case false: 
      {
        CancelButton.Visible=false;
        CancelButton.Enabled=false;
        Bounds=<0,0,300,41>;
      }
      default:;
    }
  }

  $rect <510,210,710,250>
  property bool IsExpanded;

  $rect <510,250,710,290>
  onset IsExpanded
  {
    // The value doesn't change - nothing to do.
    if ( pure IsExpanded == value )
      return;

    // Remember the property's new value.
    pure IsExpanded = value;
    Expand();
    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <510,290,710,330>
  onget IsExpanded
  {
    return pure IsExpanded;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton CancelButton
  {
    preset Layout = Core::Layout[AlignToBottom];
    preset Bounds = <75,2,225,40>;
    preset Enabled = false;
    preset Visible = false;
    preset OnPress = OnCancel;
    preset Label = "Cancel";
    preset Appearance = WidgetSet::PushButton_Medium;
  }

  $rect <20,20,160,60>
  object Views::Line Line
  {
    preset Layout = Core::Layout[AlignToBottom];
    preset Point2 = <291,40>;
    preset Point1 = <7,40>;
    preset Width = 6;
  }

  $rect <310,130,510,170>
  slot OnCancel
  {
    postsignal OnCancelled;
  }

  $rect <510,330,710,370>
  property bool OnCancelled;
}

// This class implements the item component for the Clock::ListBox widget. You will \
// probably never need to directly instantiate and control this item component.
$rect <80,650,280,690>
$output false
class WeekItem : Templates::ListItem
{
  $rect <680,10,880,50>
  inherited property Bounds = <0,0,315,40>;

  $rect <680,50,880,90>
  method void FillButtons( arg Core::Time time )
  {
    var Core::TimeSpan span=Clock::TimeSpan.Initialize2( 1, 0, 0, 0 );
    var int32 index;
    for(index=0;index<7;index++)
      { 
        Days[index]=time;
        time=time.Add(span);  
      }

    HorizontalList.InvalidateItems( 0, 6 );
                            
  }

  $rect <20,20,160,60>
  object Core::HorizontalList HorizontalList
  {
    preset Bounds = <0,0,315,40>;
    preset OnLoadItem = OnLoadItem;
    preset ItemWidth = 45;
    preset NoOfItems = 7;
    preset ItemClass = Clock::DateDayButton;
  }

  // This method is called by 'HorizontalList' every time the list loads or updates \
  // an item.
  $rect <880,10,1080,50>
  slot OnLoadItem
  {
    /*

      Hint:

      - The code below demonstrates a simple usage of the list component.

      - The list component creates and manages automatically view item instances of
        the class specified in its property 'ItemClass'. In this example it is the
        class 'Views::Image'.

      - When you change the 'ItemClass' property you will also need to replace
        accordingly all 'Views::Image' occurrences in the below code.

      - You will also need to adapt the initialization of the 'itemView'.

    */

    // Get the number of the item to load. The list component takes care of the
    // creation of the corresponding item view. Just access it ...
    var int32        itemNo   = HorizontalList.Item;
    var Clock::DateDayButton itemView = (Clock::DateDayButton)HorizontalList.View;

    // The implementation of this slot method does not match the item class
    // specified in the associated list component. Or the slot method is not
    // called in context of the OnLoadItem list operation. 
    if ( itemView == null )
      return;

    // Configure the item view ...
    itemView.Date=Days[itemNo];  
    itemView.Selectable=Days[itemNo].Month==Month;

    // Ensure that the item has correct size. The position of the item will be
    // managed by the list component.
    itemView.Bounds.size = point( HorizontalList.ItemWidth, HorizontalList.Bounds.h );
  }

  $rect <880,50,1080,90>
  array Core::Time Days[ 7 ] =
  (
    Default[0] = Clock::Time;
    Default[1] = Clock::Time;
    Default[2] = Clock::Time;
    Default[3] = Clock::Time;
    Default[4] = Clock::Time;
    Default[5] = Clock::Time;
    Default[6] = Clock::Time;
  );

  $rect <680,90,880,130>
  method Core::Time GetDate( arg int32 index )
  {
    return Days[index];
  }

  $rect <880,90,1080,130>
  property int32 Month;

  $rect <880,130,1080,170>
  onset Month
  {
    // The value doesn't change - nothing to do.
    if ( pure Month == value )
      return;

    // Remember the property's new value.
    pure Month = value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <880,170,1080,210>
  onget Month
  {
    return pure Month;
  }
}

// This class implements a 'push button' widget. When the user presses the button, \
// a signal is sent to the slot method stored in its @OnActivate property.
$rect <-130,560,70,600>
$output false
class DateDayButton : Templates::PushButton
{
  $rect <480,310,680,350>
  inherited property Bounds = <0,0,45,40>;

  $rect <20,20,160,60>
  object Views::Bevel Bevel
  {
    preset Bounds = <-2,0,43,40>;
    preset Width = 4;
    preset ColorL = #4D57841C;
    preset ColorR = #4D57845D;
    preset ColorB = #4D57845D;
    preset ColorT = #4D57841C;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Bounds = <-2,0,43,40>;
    preset Color = #4D578428;
    preset Visible = false;
  }

  $rect <20,20,160,60>
  object Views::Text Caption
  {
    preset Bounds = <-2,0,43,40>;
    preset String = " ";
    preset Font = Clock::SmallerSecondFont;
  }

  $rect <180,-10,380,30>
  property Core::Time Date = Clock::Time;

  $rect <180,30,380,70>
  onset Date
  {
    // The value doesn't change - nothing to do.
    if ( pure Date == value )
      return;

    // Remember the property's new value.
    pure Date = value;

    ChangeWeekDayLabel(value);

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <180,70,380,110>
  onget Date
  {
    return pure Date;
  }

  $rect <380,-10,580,30>
  method void ChangeWeekDayLabel( arg Core::Time time )
  {
    Caption.String=string(time.Day,2);

  }

  $rect <180,110,380,150>
  property slot OnSelected;

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler SimpleTouchHandler
  {
    preset Point4 = <5,4>;
    preset Point3 = <33,4>;
    preset Point2 = <33,36>;
    preset Point1 = <5,36>;
    preset OnLeave = null;
    preset OnRelease = ChangeState;
    preset OnPress = ChangeState;
  }

  $rect <580,-10,780,30>
  slot ChangeState
  {
    if(!Active)
    {
      Rectangle.Visible=true;
      postsignal OnSelected;
    }
    else
    {
      Rectangle.Visible=false;
    }

    Active=!Active;

  }

  $rect <380,110,580,150>
  onget Active
  {
    return pure Active;
  }

  $rect <380,70,580,110>
  onset Active
  {
    if ( pure Active == value )
      return;

    pure Active = value;
  }

  // The property 'Enabled' determines whether the component is able to react to \
  // user input events. Disabled components will never receive these events.
  // The @Enabled property is reflected in the current state of the component Core::ViewState.Enabled. \
  // This state can be evaluated in the implementation of the @UpdateViewState() \
  // method. For example, the method may show disabled components with pale colors, \
  // etc.
  // Please note, changing the enabled state of the component currently selected \
  // in the @Focus property will cause the framework to select other sibling view, \
  // which will be able to react to keyboard events.
  $rect <380,30,580,70>
  property bool Active = false;

  $rect <580,110,780,150>
  onget Selectable
  {
    return pure Selectable;
  }

  $rect <580,70,780,110>
  onset Selectable
  {
    if ( pure Selectable == value )
      return;

    pure Selectable = value;

    if(Selectable)
    {
      SimpleTouchHandler.Enabled=true;
      Rectangle.Visible=false;
      Caption.Color=#FFFFFFFF;
    }
    else
    {
      SimpleTouchHandler.Enabled=false;
      Rectangle.Visible=true;
      Caption.Color=#4D578444;
    }
  }

  // The property 'Enabled' determines whether the component is able to react to \
  // user input events. Disabled components will never receive these events.
  // The @Enabled property is reflected in the current state of the component Core::ViewState.Enabled. \
  // This state can be evaluated in the implementation of the @UpdateViewState() \
  // method. For example, the method may show disabled components with pale colors, \
  // etc.
  // Please note, changing the enabled state of the component currently selected \
  // in the @Focus property will cause the framework to select other sibling view, \
  // which will be able to react to keyboard events.
  $rect <580,30,780,70>
  property bool Selectable = true;
}

// This class implements the Clock::ListBox widget. This widget is intended to display \
// a list of options and permit the user to select the desired option. Selecting \
// the option sends a signal to the slot method stored in the property @OnSelect.
// Alternatively the property @Outlet can refer to any other 'int32' property the \
// widget should remain synchronized with. When the user selects an option, the affected \
// property is automatically updated to reflect the number of the selected option. \
// On the other hand, when the referred property is modified by another one, the \
// ListBox is automatically notified to remain in sync with the property.
// The total number of available ListBox items (the number of options) is determined \
// by the property @NoOfItems. Which option is actually selected is controlled by \
// the property @SelectedItem.
// The items are loaded dynamically at the runtime. For this purpose a slot method \
// has to be implemented and assigned to the @OnLoadItem property. The ListBox will \
// invoke the slot method automatically each time it needs an item to be loaded. \
// Within the slot method the implementation can access and initialize the affected \
// item by using the variable @View.
// In order to trigger the list to reload one or more items, invoke the method @InvalidateItems(). \
// The list box will thereupon schedule the necessary loading steps automatically.
$rect <80,610,280,650>
$output false
class MonthList : Templates::List
{
  $rect <980,-30,1180,10>
  inherited method Init()
  {
    CurrentTime= Clock::Time.CurrentTime;
    CurrentTime.Day=1;
  }

  $rect <779,20,979,60>
  inherited property Bounds = <0,0,315,331>;

  $rect <20,20,160,60>
  object Core::VerticalList VerticalList
  {
    preset Bounds = <3,91,315,331>;
    preset OnLoadItem = OnLoadItem;
    preset Endless = false;
    preset SlideHandler = null;
    preset ScrollOffset = 0;
    preset ItemHeight = 40;
    preset NoOfItems = 6;
    preset ItemClass = Clock::WeekItem;
  }

  // This method is called by 'VerticalList1' every time the list loads or updates \
  // an item.
  $rect <779,-30,979,10>
  slot OnLoadItem
  {
    /*

      Hint:

      - The code below demonstrates a simple usage of the list component.

      - The list component creates and manages automatically view item instances of
        the class specified in its property 'ItemClass'. In this example it is the
        class 'Views::Text'.

      - When you change the 'ItemClass' property you will also need to replace
        accordingly all 'Views::Text' occurrences in the below code.

      - You will also need to adapt the initialization of the 'itemView'.

    */

    // Get the number of the item to load. The list component takes care of the
    // creation of the corresponding item view. Just access it ...
    var int32       itemNo   = VerticalList.Item;
    var Clock::WeekItem itemView = (Clock::WeekItem)VerticalList.View;

    // The implementation of this slot method does not match the item class
    // specified in the associated list component. Or the slot method is not
    // called in context of the OnLoadItem list operation. 
    if ( itemView == null )
      return;

    // Configure the item view ...                                                     
    itemView.FillButtons(FitToDayOfWeek(CurrentTime).Add( Clock::TimeSpan.Initialize2( 7*itemNo,0,0,0 )));
    itemView.Month=CurrentTime.Month;
    // Ensure that the item has correct size. The position of the item will be
    // managed by the list component.
    itemView.Bounds.size = point( VerticalList.Bounds.w, VerticalList.ItemHeight );
  }

  $rect <779,79,979,119>
  property Core::Time CurrentTime;

  $rect <779,119,979,159>
  onset CurrentTime
  {
    // The value doesn't change - nothing to do.
    if ( pure CurrentTime == value )
      return;

    // Remember the property's new value.
    pure CurrentTime = value;

    Month=CurrentTime.Month;
    Year=CurrentTime.Year;

    VerticalList.InvalidateItems( 0, 5 );
    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <779,159,979,199>
  onget CurrentTime
  {
    return pure CurrentTime;
  }

  $rect <20,20,160,60>
  object Views::Text YearText
  {
    preset Bounds = <3,44,159,91>;
    preset String = "Text";
    preset Font = Clock::SmallerSecondFont;
  }

  $rect <20,20,160,60>
  object Views::Text MonthText
  {
    preset Bounds = <159,44,315,91>;
    preset String = "Text";
    preset Font = Clock::SmallerSecondFont;
  }

  $rect <980,80,1180,120>
  method Core::Time FitToDayOfWeek( arg Core::Time time )
  {
    return time.Subtract( Clock::TimeSpan.Initialize2( time.DayOfWeek, 0, 0, 0 ) );
  }

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler Next
  {
    preset Point4 = <159,0>;
    preset Point3 = <315,0>;
    preset Point2 = <315,44>;
    preset Point1 = <159,44>;
    preset OnPress = OnNext;
  }

  $rect <790,250,990,290>
  slot OnNext
  {
    Month++;
    VerticalList.InvalidateItems( 0, 5 );
  }

  $rect <1180,80,1380,120>
  property int32 Month;

  $rect <1180,120,1380,160>
  onset Month
  {
    // The value doesn't change - nothing to do.
    if ( pure Month == value )
      return;

    // Remember the property's new value.

    pure Month = value;
    if(Month>12) 
    {
      Month=1;
      Year++;
    }
    if(Month<1)
    {
      Month=12;
      Year--;
    }
    CurrentTime.Month=Month;
    MonthText.String=Clock::Time.getMonthName(Month,true);

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <1180,160,1380,200>
  onget Month
  {
    return pure Month;
  }

  $rect <1390,80,1590,120>
  property int32 Year;

  $rect <1390,120,1590,160>
  onset Year
  {
    // The value doesn't change - nothing to do.
    if ( pure Year == value )
      return;

    // Remember the property's new value.
    pure Year = value;
    YearText.String=string(Year);
    CurrentTime.Year=Year;
    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <1390,160,1590,200>
  onget Year
  {
    return pure Year;
  }

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler Prev
  {
    preset Point4 = <3,0>;
    preset Point3 = <159,0>;
    preset Point2 = <159,44>;
    preset Point1 = <3,44>;
    preset OnPress = OnPrev;
  }

  $rect <790,290,990,330>
  slot OnPrev
  {
    Month--;
    VerticalList.InvalidateItems( 0, 5 );
  }
}

$rect <-119,650,71,690>
$output false
autoobject Core::TimeSpan TimeSpan;

// The definition Core::ViewState determines the set of possible states, a Core::View \
// can assume at its lifetime. These states are used internally by all GUI components. \
// They determine whether components are visible, able to react to user events, etc. 
$rect <-119,370,71,410>
$output false
set ViewState
{
  // The state 'Visible' determines the visibility of the corresponding view. Invisible \
  // views will not appear on the screen. Whether a view is really visible depends \
  // on the visibility of its owner and the position of the view within the owners \
  // boundary area.
  $rect <10,10,190,50>
  item Visible;

  // The state 'AlphaBlended' determines the drawing mode for the corresponding view. \
  // Views with disabled alpha-blending will override the affected screen areas. \
  // If this mode is enabled, the aspect of the view is combined with the origin \
  // screen content by alpha-blending.
  $rect <190,10,370,50>
  item AlphaBlended;

  // The state 'Focusable' determines whether the view is able to become focused \
  // and react to keyboard events. Non focusable views can not receive keyboard events.
  $rect <10,50,190,90>
  item Focusable;

  // The state 'Touchable' determines whether the view is able to receive cursor \
  // events. Non touchable views can not react to user touch screen taps.
  $rect <190,50,370,90>
  item Touchable;

  // The state 'Enabled' determines whether the view is able to react to user input \
  // events. Disabled views will never receive these events. Whether the can really \
  // react to events depends additionally on its other states @Focusable and @Touchable.
  $rect <370,50,550,90>
  item Enabled;

  // The state 'Selected' determines whether the view is currently selected within \
  // its owner. The selected view is stored in its owner Focus property.
  $rect <10,90,190,130>
  item Selected;

  // The state 'Focused' determines whether the view belongs to the focus path and \
  // thus is able to receive keyboard events.
  $rect <190,90,370,130>
  item Focused;

  // The state 'Modal' determines whether the view is currently modal.
  $rect <370,90,550,130>
  item Modal;

  $rect <10,130,190,170>
  item FastReshape;

  $rect <190,130,370,170>
  item IsOutline;

  // The state 'Embedded' determines how the view should appear and behave within \
  // its superior owner. If this state is active, the affected view will be embedded \
  // (limited) to the boundary of a preceding Core::Outline sibling view. This is \
  // as if the view had been embedded within this outline. If this state is not active, \
  // the view is considered as a regular view of its owner - it doesn't belong to \
  // any outline.
  $rect <370,130,550,170>
  item Embedded;

  $rect <10,170,190,210>
  item RequestLayout;

  $rect <190,170,370,210>
  item UpdateLayout;

  $rect <370,170,550,210>
  item UpdatingLayout;

  $rect <10,210,190,250>
  item PendingLayout;

  $rect <190,210,370,250>
  item PendingViewState;

  // The state 'Dialog' is set for every GUI component being explicitly presented \
  // by using the method Core::Group.PresentDialog() or Core::Group.SwitchToDialog().
  $rect <550,90,730,130>
  item Dialog;

  $rect <10,250,190,290>
  item PendingFader;

  $rect <190,250,370,290>
  item RunningFader;
}
