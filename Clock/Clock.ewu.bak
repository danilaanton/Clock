$version 11.00

$rect <80,70,280,110>
$output false
class Base : Core::Group
{
  $rect <20,550,220,590>
  inherited method Init()
  {
    Bounds.size = $ScreenSize;
    Image.Bounds.size=$ScreenSize;
    Rectangle.Bounds.size=$ScreenSize;
    this.PresentDialog( new Clock::ClockScreen, null, null, null, null, null, null, null, null, false );

  }

  $rect <20,500,220,540>
  inherited property Bounds = <0,0,300,200>;

  $rect <690,190,880,230>
  object Effects::RectEffect SlideDown
  {
    preset OnFinished = SlideDown.StopEffect;
    preset Bounces = 3;
    preset Oscillations = 3;
    preset Timing = Effects::Timing.FastIn_EaseOut;
    preset NoOfCycles = 1;
    preset CycleDuration = 500;
    preset Value2 = <0,0,640,522>;
    preset Value1 = <0,-482,640,40>;
    preset Outlet = ^RunningEvents.Bounds;
  }

  $rect <690,240,880,280>
  object Effects::RectEffect SlideUp
  {
    preset OnFinished = SlideUp.StopEffect;
    preset Bounces = 3;
    preset Oscillations = 3;
    preset Timing = Effects::Timing.FastIn_EaseOut;
    preset NoOfCycles = 1;
    preset CycleDuration = 500;
    preset Value2 = <0,-482,640,40>;
    preset Value1 = <0,0,640,522>;
    preset Outlet = ^RunningEvents.Bounds;
  }

  $rect <220,500,420,540>
  object Core::SystemEventHandler EventTriggeredHandler
  {
    preset OnEvent = onEvent;
    preset Event = Clock::Device.EventTriggered;
  }

  // This slot method is executed when the associated system event handler 'SystemEventHandler' \
  // receives an event.
  $rect <420,500,620,540>
  slot onEvent
  {
    var Clock::Alert alert=new Clock::Alert;
    var Clock::Event event=(Clock::Event)EventTriggeredHandler.Context;
    var string triggerTime=Clock::Time.Initialize( event.TriggerTime ).String;

    alert.Sender=event;
    alert.Icon=Clock::IconsMedium;
    switch(event.Type)
    {
      case Clock::EventType.Alarm: 
      {
        alert.Caption=string(triggerTime.remove( 0, triggerTime.length-8 ));
        alert.IconFrame=2;
      }
      case Clock::EventType.Calendar:  
      {
        alert.Caption=string(triggerTime);
        alert.IconFrame=3;
      }
      default:;
    }
    alert.OnButton1=OnButton1;
    trace event.Snooze;
    if(event.Snooze<=10)
    {
      alert.OnIgnored=OnButton2;
      alert.OnButton2=OnButton2;
    }
    else
    {
      alert.OnIgnored=OnButton1;
      alert.PushButton2.Enabled=false;
    }
    this.PresentDialog( alert, Effects::SlideDownCentered, null, null, null, null, null, null, null, false );
  }

  $rect <220,550,420,590>
  slot OnButton1
  {
    var Clock::Alert alert= (Clock::Alert)sender;
    if(Clock::Device.GetEvent( alert.Index )!=null) 
    {
      alert.Sender.Snooze=0;
      Clock::Device.UpdateEvent( alert.Index );
    }
    this.DismissDialog( (Clock::Alert)sender, null, null, null, null, null, false );
  }

  $rect <20,20,160,60>
  object Views::Image Image
  {
    preset Bounds = <0,0,640,520>;
    preset Alignment = Views::ImageAlignment[AlignHorzCenter, AlignVertCenter, StretchToFill];
    preset Bitmap = Clock::BackgroundImg;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,0,640,480>;
    preset Color = #27608074;
  }

  $rect <20,20,160,60>
  object Clock::RunningEvents RunningEvents
  {
    preset Bounds = <0,-482,640,40>;
  }

  $rect <220,590,420,630>
  slot OnButton2
  {
    var Clock::Alert alert=(Clock::Alert)sender;
    var Clock::Event event=alert.Sender;

    event.Snooze+=5;
    if(!event.IsScheduled) Clock::Device.AddEvent( event );
    this.DismissDialog( alert, null, null, null, null, null, false );
  }
}

$rect <80,110,280,150>
$output false
class ClockScreen : Core::Group
{
  $rect <0,500,200,540>
  inherited method Init()
  {
    postsignal UpdateTime;
  }

  $rect <660,-10,860,30>
  inherited property Bounds = rect(0,0,$ScreenSize.x,$ScreenSize.y);

  $rect <20,20,160,60>
  object Clock::PlainClock PlainClock
  {
    preset Bounds = <-7,60,377,445>;
    preset Opacity = 255;
    preset Color = #255C7BFF;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle2
  {
    preset Bounds = <0,39,384,480>;
    preset ColorBL = #255C7BFF;
    preset ColorBR = #4FA8C3FF;
    preset ColorTR = #4FA8C3FF;
    preset ColorTL = #255C7BFF;
    preset Color = #FFFFFFB0;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Bounds = <0,39,640,80>;
    preset ColorBL = #0F1E3553;
    preset ColorBR = #0F1E3553;
    preset ColorTR = #0F1E35FF;
    preset ColorTL = #0F1E35FF;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle1
  {
    preset Bounds = <0,439,640,480>;
    preset ColorBL = #0F1E35FF;
    preset ColorBR = #0F1E35FF;
    preset ColorTR = #0F1E3553;
    preset ColorTL = #0F1E3553;
  }

  $rect <20,20,160,60>
  object Views::Image Image
  {
    preset Bounds = <295,430,345,480>;
    preset Color = #FAE9E0FF;
    preset Bitmap = Resources::NavigationIconsMedium;
  }

  $rect <20,20,160,60>
  object Views::Image Image1
  {
    preset Bounds = <295,39,345,89>;
    preset Orientation = Views::Orientation.Rotated_180;
    preset Color = #FAE9E0FF;
    preset Bitmap = Resources::NavigationIconsMedium;
  }

  $rect <20,20,160,60>
  object Views::Line Line
  {
    preset Point2 = <384,439>;
    preset Point1 = <384,80>;
    preset Width = 2;
    preset Color = #FAE9E0FF;
  }

  $rect <20,20,160,60>
  object Views::Line Line1
  {
    preset Point2 = <401,240>;
    preset Point1 = <614,240>;
    preset Width = 1;
    preset Color = #FAE9E0FF;
  }

  $rect <20,20,160,60>
  object Views::Text DayMonth
  {
    preset Bounds = <384,108,552,240>;
    preset WrapText = true;
    preset Alignment = Views::TextAlignment[AlignHorzCenter, AlignHorzJustified, AlignHorzRight, AlignVertCenter];
    preset String = "Mon, July 32";
    preset Font = Resources::FontLarge;
    preset Color = #FAE9E0FF;
  }

  $rect <20,20,160,60>
  object Views::Text Year
  {
    preset Bounds = <413,255,614,318>;
    preset WrapText = true;
    preset String = "Year";
    preset Font = Resources::FontExtraLarge;
    preset Color = #FAE9E0FF;
  }

  $rect <210,500,410,540>
  slot UpdateTime
  {
    var Core::Time currentTime =  Clock::Time.CurrentTime;

    Second.String=string(currentTime.Second/10)+ string(currentTime.Second%10);
    Hour.String=string(currentTime.Hour/10)+string(currentTime.Hour%10);
    Minute.String=string(currentTime.Minute/10)+string(currentTime.Minute%10);
    DayMonth.String=currentTime.getDayOfWeekName( currentTime.DayOfWeek, false ) + "\n" + currentTime.getMonthName( currentTime.Month, false ) + " " + string(currentTime.Day, 2);
    Year.String = string(currentTime.Year);

    PlainClock.Second=currentTime.Second;
    PlainClock.Hour=currentTime.Hour;
    PlainClock.Minute=currentTime.Minute;

    if(currentTime.Hour>6 && currentTime.Hour<18) Image2.FrameNumber=20;
    else Image2.FrameNumber=21;
  }

  $rect <20,20,160,60>
  object Views::Text Hour
  {
    preset Bounds = <14,108,154,403>;
    preset String = "00";
    preset Font = Clock::ExtraLargeFont;
    preset Color = #FAE9E0FF;
  }

  $rect <20,20,160,60>
  object Views::Text Second
  {
    preset Bounds = <295,108,384,403>;
    preset String = "00";
    preset Font = Clock::LargeFont;
    preset Color = #FAE9E0FF;
  }

  $rect <20,20,160,60>
  object Views::Text Dot
  {
    preset Bounds = <154,107,172,402>;
    preset String = "05:30";
    preset Font = Clock::ExtraLargeFont;
    preset Color = #FAE9E0FF;
  }

  $rect <20,20,160,60>
  object Views::Text Minute
  {
    preset Bounds = <172,108,312,403>;
    preset String = "00";
    preset Font = Clock::ExtraLargeFont;
    preset Color = #FAE9E0FF;
  }

  $rect <210,570,410,610>
  slot WipeUpSlot
  {
    Owner.SwitchToDialog( new Clock::FunctionalitiesScreen, Effects::SlideUpCentered, null, null, null, null, null, null, null, null, false );
  }

  $rect <210,610,410,650>
  slot WipeDownSlot
  {
    var Clock::Base owner=(Clock::Base) Owner;
    owner.SlideDown.Enabled=true;
    owner.DismissDialog( this, Effects::SlideDownCentered, null, null, null, null, false );                    
  }

  $rect <400,500,700,540>
  object Core::SystemEventHandler TimeChangedHandler
  {
    preset OnEvent = UpdateTime;
    preset Event = Clock::Device.TimeChanged;
  }

  $rect <20,20,160,60>
  object Views::Image Image2
  {
    preset Bounds = <552,130,640,218>;
    preset Color = #FAE9E0FF;
    preset Bitmap = Resources::SymbolIconsLarge;
  }

  $rect <20,20,160,60>
  object Views::Border Border
  {
    preset Bounds = <0,439,640,479>;
    preset Color = #0F1E358C;
  }

  $rect <20,20,160,60>
  object Views::Border Border1
  {
    preset Bounds = <0,0,640,80>;
    preset Color = #0F1E358C;
  }

  $rect <20,20,160,60>
  object Core::WipeTouchHandler WipeDown
  {
    preset Bounds = <0,0,640,108>;
    preset OnBottom = WipeDownSlot;
  }

  $rect <20,20,160,60>
  object Core::WipeTouchHandler WipeUp
  {
    preset Bounds = <0,403,640,479>;
    preset OnTop = WipeUpSlot;
  }
}

$rect <480,110,680,150>
$output false
resource Resources::Font ExtraLargeFont
{
  attr fontname FontName = Agency FB;
  attr fontheight Height = 150;
  attr fontheightmode HeightMode = Popular;
  attr fontquality Quality = High;
  attr fontranges Ranges = 0x20-0xFF;
  attr fontaspectratio AspectRatio = 1;
  attr fontbold Bold = true;
  attr fontitalic Italic = false;
  attr fontkerning Kerning = true;
  attr fontrowdistance RowDistance;
}

$rect <490,380,690,420>
inline Inline
{
  /*

    TO DO:

    Include external header files or add type and function declarations needed
    in the implementation of Clock::DeviceClass. For example:

      #include "DeviceDriver.h"

      #include "your_middleware_api.h"

      void Your_Middleware_Some_Function( int aSomeArg );

  */
}

$rect <490,340,690,380>
$output false
class DeviceClass : Templates::DeviceClass
{
  $rect <30,80,230,120>
  inherited method Done()
  {
    // The following section is intended to perform de-initialization-related operations
    // in the underlying device or middleware. Consequently, the section is taken in
    // account only when generating code (not during prototyping).
    $if !$prototyper
      var object thisObject = this;

      /*
         TO DO:

         The following native statement is intended to enclose code to communicate with
         your device API. The variable 'thisObject' contains a pointer to the actually
         de-initialized Clock::DeviceClass object. Use the 'thisObject' pointer to
         e.g. de-register the object from the middleware if you have registered it
         beforehand.
         
      */

      native ( thisObject )
      {
        /*
           TO DO:

           Depending on your application case you call functions of the underlying
           middleware (or access the device directly) in order to perform the necessary
           de-initialization steps. For example, you invoke some 'C' function:

             YourDevice_DeInitialize();

           IMPORTANT:
           ----------

           The variable 'thisObject' represents the actually de-initialized instance of the
           Clock::DeviceClass. If you have stored this object at the initialization
           time (in the 'Init' method) in some global C variable or registered it by the
           middleware, it is important to perform now the opposite operation. Set the
           global variable to NULL or de-register 'thisObject' object from the middleware.
           
        */
      }
    $endif
  }

  $rect <30,40,230,80>
  inherited method Init()
  {
    // The following section is intended to perform initialization-related operations
    // in the underlying device or middleware. Consequently, the section is taken in
    // account only when generating code (not during prototyping).
    $if !$prototyper
      var object thisObject = this;

      /*
         TO DO:

         The following native statement is intended to enclose code to communicate with
         your device API. The variable 'thisObject' contains a pointer to the actually
         initialized Clock::DeviceClass object. Use the 'thisObject' pointer to
         e.g. register the object by the middleware as receiver of events, etc.
         
      */

      native ( thisObject )
      {
        /*
           TO DO:

           Depending on your application case you call functions of the underlying
           middleware (or access the device directly) in order to perform the necessary
           initialization steps. For example, you invoke some 'C' function:

             YourDevice_Initialize();

           The variable 'thisObject' represents the actually initialized instance of the
           Clock::DeviceClass. You can store this variable e.g. in the middleware
           and use it whenever the middleware needs to notify the GUI application about
           some state alternation or events. In this manner, the middleware will be able
           to invoke methods of the interface device object.

           For example, you can store 'thisObject' in some global C variable:

             // Declaration of the global C variable
             XObject theDeviceObject;

             // Store the instance in the global variable
             theDeviceObject = thisObject;

           Later use the global variable e.g. to provide the GUI application with events:

             ApplicationDeviceClass__TriggerSomeEvent( theDeviceObject );

           IMPORTANT:
           ----------

           If you store 'thisObject' for later use, don't forget to implement the opposite
           operation in the method 'Done'. Concrete, 'Done' should set the global variable
           again to the value NULL.

        */
      }
    $endif
  }

  // Constructor and Destructor
  note group Note1
  {
    attr Bounds = <10,0,250,140>;
  }

  $rect <10,190,210,230>
  object Core::Timer Timer
  {
    preset OnTrigger = TimeProgress;
    preset Period = 1000;
    preset Enabled = true;
  }

  $rect <210,190,410,230>
  slot TimeProgress
  {
    TimeChanged.Trigger( null, null );

    var int32 index;
    var int64 currentTime=Clock::Time.CurrentTime.Time;
    for(index=0;index<GetEventsCount();)
    {
      var Clock::Event event=GetEvent(index);
      if(event.IsTriggered( currentTime ))
         {
          EventTriggered.Trigger( event, null ); 
          if(event.IsExpired( currentTime ))
              {
                RemoveEvent(index);
                continue;
              }
         }
      index++;
    }
  }

  $rect <10,240,270,280>
  object Core::SystemEvent TimeChanged;

  $rect <270,240,470,280>
  object Core::SystemEvent EventChanged;

  $rect <10,300,210,340>
  method int32 GetEventsCount()
  {
    /* The template just returns the given argument... */
    return 0;
  }

  $rect <10,340,210,380>
  method Clock::Event GetEvent( arg int32 index )
  {
    /* The template just returns the given argument... */
    return null;
  }

  $rect <10,380,210,420>
  method bool AddEvent( arg Clock::Event event )
  {
  }

  $rect <10,420,210,460>
  method bool RemoveEvent( arg int32 index )
  {
  }

  $rect <470,240,670,280>
  object Core::SystemEvent EventTriggered;

  $rect <10,460,210,500>
  method bool UpdateEvent( arg int32 index )
  {
    var Clock::Event event=Clock::Device.GetEvent( index );
    var int32 currentDayOfWeek=Clock::Time.Initialize( event.TriggerTime ).DayOfWeek;
    var int64 currentTime=Clock::Time.CurrentTime.Time;
    var int64 i=event.TriggerTime ;
    do
    {
      if(event.ScheduledDays[(currentDayOfWeek+int32(i-event.TriggerTime )/86400)%7]==true && i>currentTime) 
       {
          event.TriggerTime=i;
          Clock::Device.EventChanged.Trigger( null, null );
          return true; 
       }
      i+=86400;
    }while(i<=event.TriggerTime+7*86400);
    return false;
  }
}

$rect <690,340,890,380>
autoobject Clock::DeviceClass Device;

$rect <480,150,680,190>
$output false
resource Resources::Font LargeFont
{
  attr fontname FontName = Agency FB;
  attr fontheight Height = 50;
  attr fontheightmode HeightMode = Popular;
  attr fontquality Quality = High;
  attr fontranges Ranges = 0x20-0xFF;
  attr fontaspectratio AspectRatio = 1;
  attr fontbold Bold = true;
  attr fontitalic Italic = false;
  attr fontkerning Kerning = true;
  attr fontrowdistance RowDistance;
}

$rect <81,150,281,190>
$output false
class FunctionalitiesScreen : Core::Group
{
  $rect <0,540,200,580>
  inherited method Init()
  {
    postsignal UpdateTime;
  }

  $rect <0,500,200,540>
  inherited property Bounds = rect(0,0,$ScreenSize.x,$ScreenSize.y);

  $rect <210,590,410,630>
  slot WipeDownSlot
  {
    Owner.SwitchToDialog(new Clock::ClockScreen, Effects::SlideDownCentered, null, null, null, null, null, null, null, null, false );
  }

  $rect <210,500,410,540>
  slot UpdateTime
  {
    var Core::Time currentTime = Clock::Time.CurrentTime;
    Hour.String=string(currentTime.Hour/10)+string(currentTime.Hour%10)+":"+string(currentTime.Minute/10)+string(currentTime.Minute%10);
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Bounds = <0,39,640,480>;
    preset Color = #1D243858;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle1
  {
    preset Bounds = <0,439,640,480>;
    preset ColorBL = #FFFFFFFF;
    preset ColorBR = #FFFFFFFF;
    preset ColorTR = #FFFFFF53;
    preset ColorTL = #FFFFFF53;
    preset Color = #0F1E35FF;
  }

  $rect <20,20,160,60>
  object Views::Border Border
  {
    preset Bounds = <0,439,640,479>;
    preset Color = #0F1E358C;
  }

  $rect <20,20,160,60>
  object Core::WipeTouchHandler WipeDown
  {
    preset Bounds = <0,0,640,80>;
    preset OnBottom = WipeDownSlot;
    preset OnTop = null;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle3
  {
    preset Bounds = <0,39,640,80>;
    preset ColorBL = #FFFFFF53;
    preset ColorBR = #FFFFFF53;
    preset ColorTR = #FFFFFFFF;
    preset ColorTL = #FFFFFFFF;
    preset Color = #0F1E35FF;
  }

  $rect <20,20,160,60>
  object Views::Image Image
  {
    preset Bounds = <295,34,345,84>;
    preset Color = #FAE9E0FF;
    preset FrameNumber = 1;
    preset Bitmap = Resources::NavigationIconsMedium;
  }

  $rect <20,20,160,60>
  object Views::Text Hour
  {
    preset Bounds = <458,9,640,70>;
    preset String = "Text";
    preset Font = Clock::LargeFont;
    preset Color = #FAE9E0FF;
  }

  $rect <20,20,160,60>
  object Views::Text CronometerText
  {
    preset Bounds = <146,222,246,252>;
    preset String = "Chronometer";
    preset Font = Resources::FontSmall;
    preset Color = #FAE9E0FF;
  }

  $rect <20,20,160,60>
  object Views::Text CalendarText
  {
    preset Bounds = <394,222,494,252>;
    preset String = "Calendar";
    preset Font = Resources::FontSmall;
    preset Color = #FAE9E0FF;
  }

  $rect <20,20,160,60>
  object Views::Text TimerText
  {
    preset Bounds = <146,377,246,407>;
    preset String = "Timer";
    preset Font = Resources::FontSmall;
    preset Color = #FAE9E0FF;
  }

  $rect <20,20,160,60>
  object Views::Text AlarmText
  {
    preset Bounds = <394,377,494,407>;
    preset String = "Alarm";
    preset Font = Resources::FontSmall;
    preset Color = #FAE9E0FF;
  }

  $rect <419,590,619,630>
  slot OnTimerButton
  {
    Owner.SwitchToDialog(new Clock::TimerScreen, Effects::FadeInOutCentered, null, null, null, null, null, null, null, null, false );
  }

  $rect <419,630,619,670>
  slot OnChronButton
  {
    Owner.SwitchToDialog(new Clock::ChronometerScreen, Effects::FadeInOutCentered, null, null, null, null, null, null, null, null, false );
  }

  $rect <419,670,619,710>
  slot OnAlarmButton
  {
    Owner.SwitchToDialog(new Clock::AlarmScreen, Effects::FadeInOutCentered, null, null, null, null, null, null, null, null, false );
  }

  $rect <419,710,619,750>
  slot OnCalButton
  {
    Owner.SwitchToDialog(new Clock::CalendarScreen, Effects::FadeInOutCentered, null, null, null, null, null, null, null, null, false );
  }

  $rect <410,500,710,540>
  object Core::SystemEventHandler TimeChangedHandler
  {
    preset OnEvent = UpdateTime;
    preset Event = Clock::Device.TimeChanged;
  }

  $rect <20,20,160,60>
  object Clock::FunctionalitiesButton ChronometerButton
  {
    preset Bounds = <146,125,246,225>;
    preset OnPress = OnChronButton;
    preset Bitmap = Clock::IconsMedium;
    preset IconColor = #0F1E35FF;
    preset Color = #D2D5DBFF;
    preset ShadowColor = #B5C5D3FF;
  }

  $rect <20,20,160,60>
  object Clock::FunctionalitiesButton CalendarButton
  {
    preset Bounds = <394,125,494,225>;
    preset OnPress = OnCalButton;
    preset FrameNumber = 3;
    preset Bitmap = Clock::IconsMedium;
    preset IconColor = #0F1E35FF;
    preset Color = #D2D5DBFF;
    preset ShadowColor = #B5C5D3FF;
  }

  $rect <20,20,160,60>
  object Clock::FunctionalitiesButton TimerButton
  {
    preset Bounds = <146,277,246,377>;
    preset OnPress = OnTimerButton;
    preset FrameNumber = 1;
    preset Bitmap = Clock::IconsMedium;
    preset IconColor = #0F1E35FF;
    preset Color = #D2D5DBFF;
    preset ShadowColor = #B5C5D3FF;
  }

  $rect <20,20,160,60>
  object Clock::FunctionalitiesButton AlarmButton
  {
    preset Bounds = <394,277,494,377>;
    preset OnPress = OnAlarmButton;
    preset FrameNumber = 2;
    preset Bitmap = Clock::IconsMedium;
    preset IconColor = #0F1E35FF;
    preset Color = #D2D5DBFF;
    preset ShadowColor = #B5C5D3FF;
  }

  $rect <20,20,160,60>
  object Views::Border Border1
  {
    preset Bounds = <0,0,640,80>;
    preset Color = #0F1E358C;
  }

  $rect <20,20,160,60>
  object Views::Text CalendarText1
  {
    preset Bounds = <394,222,494,252>;
    preset String = "Calendar";
    preset Font = Resources::FontSmall;
    preset Color = #FAE9E0FF;
  }
}

// This class implements a 'rotary knob' widget. The user can touch the knob and \
// rotate it causing the widget's value to be changed accordingly. The current value \
// of the widget is represented by the property @CurrentValue. The valid range for \
// this value is determined by the properties @MinValue and @MaxValue.
// While the user is dragging the knob, the widget sends signals to the slot method \
// stored in the property @OnChange. When the user terminates the interaction, a \
// signal is sent to the slot method stored in @OnApply.
// Alternatively the property @Outlet can refer to any other 'int32' property the \
// widget should remain synchronized with. When the user drags the knob, the affected \
// property is automatically updated to reflect the widget's current value. On the \
// other hand, when the referred property is modified by another one, the widget \
// is automatically notified to remain in sync with the property.
// This approach follows the Model-View-Controller (MVC) programming paradigm. Here \
// the rotary knob represents the 'View' and 'Controller' and the property referred \
// via 'Outlet' can be seen as a part of the 'Model'.
$rect <90,458,290,498>
$output false
class PlainClock : Templates::RotaryKnob
{
  $rect <10,10,160,50>
  inherited method Init()
  {
    postsignal UpdateColor;
  }

  $rect <480,390,680,430>
  inherited property Bounds = <0,0,400,400>;

  $rect <480,350,680,390>
  object Graphics::ArcPath ArcPath
  {
    preset NoOfEdges = 0;
    preset EndAngle = 360;
    preset InnerRadius = 0;
    preset RadiusX = 0.0;
    preset Radius = 170;
    preset Style = Graphics::ArcStyle.Arc;
  }

  $rect <20,20,160,60>
  object Views::StrokePath StrokePath
  {
    preset Bounds = <0,0,400,400>;
    preset Offset = <200,200>;
    preset Width = 15.0;
    preset Path = ArcPath;
  }

  $rect <20,20,160,60>
  object Views::Line Line
  {
    preset Point2 = <200,50>;
    preset Point1 = <200,30>;
    preset Width = 10;
  }

  $rect <20,20,160,60>
  object Views::Line Line1
  {
    preset Point2 = <199,370>;
    preset Point1 = <199,350>;
    preset Width = 10;
  }

  $rect <20,20,160,60>
  object Views::Line Line2
  {
    preset Point2 = <350,200>;
    preset Point1 = <370,200>;
    preset Width = 10;
  }

  $rect <20,20,160,60>
  object Views::Line Line3
  {
    preset Point2 = <30,200>;
    preset Point1 = <50,200>;
    preset Width = 10;
  }

  $rect <470,0,670,40>
  property int32 Hour = 0;

  $rect <470,40,670,80>
  onset Hour
  {
    // The value doesn't change - nothing to do.
    if ( pure Hour == value )
      return;

    // Remember the property's new value.
    pure Hour = value;

    postsignal UpdateLines;
    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <470,80,670,120>
  onget Hour
  {
    return pure Hour;
  }

  $rect <670,0,870,40>
  property int32 Minute = 0;

  $rect <670,40,870,80>
  onset Minute
  {
    // The value doesn't change - nothing to do.
    if ( pure Minute == value )
      return;

    // Remember the property's new value.
    pure Minute = value;

    postsignal UpdateLines;
    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <670,80,870,120>
  onget Minute
  {
    return pure Minute;
  }

  $rect <870,0,1070,40>
  property int32 Second = 0;

  $rect <870,40,1070,80>
  onset Second
  {
    // The value doesn't change - nothing to do.
    if ( pure Second == value )
      return;

    // Remember the property's new value.
    pure Second = value;

    postsignal UpdateLines;
    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <870,80,1070,120>
  onget Second
  {
    return pure Second;
  }

  $rect <480,310,680,350>
  slot UpdateLines
  {
    SecondImg.RotateAndScale( SecondImg.SourceAnchor, -Second*6, 1.0, 1.0 );
    MinuteImg.RotateAndScale( MinuteImg.SourceAnchor, -Minute*6, 1.0, 1.0 );
    HourImg.RotateAndScale( HourImg.SourceAnchor, -Hour*15, 1.0, 1.0 );

  }

  $rect <20,20,160,60>
  object Views::WarpImage SecondImg
  {
    preset Point4 = <0,400>;
    preset Point3 = <400,400>;
    preset Point2 = <400,0>;
    preset Point1 = <0,0>;
    preset Shininess = 0.0;
    preset Quality = true;
    preset SourceAnchor = <200,200>;
    preset Color = Color;
    preset Bitmap = Clock::SecondLine;
  }

  $rect <20,20,160,60>
  object Views::WarpImage MinuteImg
  {
    preset Point4 = <0,400>;
    preset Point3 = <400,400>;
    preset Point2 = <400,0>;
    preset Point1 = <0,0>;
    preset Shininess = 0.0;
    preset Quality = true;
    preset SourceAnchor = <200,200>;
    preset Color = Color;
    preset Bitmap = Clock::MinuteLine;
  }

  $rect <20,20,160,60>
  object Views::WarpImage HourImg
  {
    preset Point4 = <0,400>;
    preset Point3 = <400,400>;
    preset Point2 = <400,0>;
    preset Point1 = <0,0>;
    preset Shininess = 0.0;
    preset Quality = true;
    preset SourceAnchor = <200,200>;
    preset AlphaBlended = true;
    preset Color = Color;
    preset Bitmap = Clock::HourLine;
  }

  $rect <470,120,670,160>
  property color Color = #FFFFFFFF;

  $rect <470,160,670,200>
  onset Color
  {
    // The value doesn't change - nothing to do.
    if ( pure Color == value )
      return;

    // Remember the property's new value.
    pure Color = value;

    postsignal UpdateColor;
    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <470,200,670,240>
  onget Color
  {
    return pure Color;
  }

  $rect <680,310,880,350>
  slot UpdateColor
  {
    HourImg.Color=Color;
    MinuteImg.Color=Color;
    SecondImg.Color=Color;
    Line.Color=Color;
    Line1.Color=Color;
    Line2.Color=Color;
    Line3.Color=Color;
    StrokePath.Color=Color;
  }
}

$rect <690,30,890,70>
$output false
resource Resources::Bitmap HourLine
{
  attr bitmapfile FileName = .\Resources\HourLine.png;
  attr bitmapdithering Dithering = Auto;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapformat Format = Alpha8;
  attr bitmapmode Mode = Default;
}

$rect <690,70,890,110>
$output false
resource Resources::Bitmap MinuteLine
{
  attr bitmapfile FileName = .\Resources\MinuteLine.png;
  attr bitmapdithering Dithering = Auto;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapformat Format = Alpha8;
  attr bitmapmode Mode = Default;
}

$rect <690,110,890,150>
$output false
resource Resources::Bitmap SecondLine
{
  attr bitmapfile FileName = .\Resources\SecondLine.png;
  attr bitmapdithering Dithering = Auto;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapformat Format = Alpha8;
  attr bitmapmode Mode = Default;
}

// This class implements a 'rotary knob' widget. The user can touch the knob and \
// rotate it causing the widget's value to be changed accordingly. The current value \
// of the widget is represented by the property @CurrentValue. The valid range for \
// this value is determined by the properties @MinValue and @MaxValue.
// While the user is dragging the knob, the widget sends signals to the slot method \
// stored in the property @OnChange. When the user terminates the interaction, a \
// signal is sent to the slot method stored in @OnApply.
// Alternatively the property @Outlet can refer to any other 'int32' property the \
// widget should remain synchronized with. When the user drags the knob, the affected \
// property is automatically updated to reflect the widget's current value. On the \
// other hand, when the referred property is modified by another one, the widget \
// is automatically notified to remain in sync with the property.
// This approach follows the Model-View-Controller (MVC) programming paradigm. Here \
// the rotary knob represents the 'View' and 'Controller' and the property referred \
// via 'Outlet' can be seen as a part of the 'Model'.
$rect <90,508,290,548>
$output false
class TimerClock : Templates::RotaryKnob
{
  $rect <480,130,630,170>
  inherited method Init()
  {
    postsignal UpdateColor;
  }

  $rect <480,390,680,430>
  inherited property Bounds = <0,0,379,379>;

  $rect <480,350,680,390>
  object Graphics::ArcPath ArcPath
  {
    preset NoOfEdges = 0;
    preset EndAngle = 360;
    preset InnerRadius = 0;
    preset RadiusX = 0.0;
    preset Radius = 130;
    preset Style = Graphics::ArcStyle.Arc;
  }

  $rect <20,20,160,60>
  object Views::StrokePath StrokePath
  {
    preset Bounds = <0,0,380,380>;
    preset Color = #FAE9E088;
    preset Offset = <190,190>;
    preset Width = 8;
    preset Path = ArcPath;
  }

  $rect <670,0,870,40>
  property color Color = #FFFFFFFF;

  $rect <670,40,870,80>
  onset Color
  {
    // The value doesn't change - nothing to do.
    if ( pure Color == value )
      return;

    // Remember the property's new value.
    pure Color = value;

    postsignal UpdateColor;
    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <670,80,870,120>
  onget Color
  {
    return pure Color;
  }

  $rect <680,310,880,350>
  slot UpdateColor
  {
  }

  $rect <20,20,160,60>
  object Views::StrokePath TimePassing
  {
    preset Bounds = <0,0,380,380>;
    preset ColorBL = #4B3FFFFF;
    preset ColorBR = #41F5FFFF;
    preset ColorTR = #19FF72FF;
    preset ColorTL = #FF43F8FF;
    preset Color = #FAE9E0FF;
    preset Offset = <190,190>;
    preset EndCap = Graphics::PathCap.Round;
    preset Width = 8;
    preset Path = TimerPath;
  }

  $rect <679,350,879,390>
  object Graphics::ArcPath TimerPath
  {
    preset NoOfEdges = 0;
    preset EndAngle = 270;
    preset StartAngle = 270;
    preset InnerRadius = 0;
    preset RadiusX = 0.0;
    preset Radius = 130;
    preset Style = Graphics::ArcStyle.Arc;
  }

  $rect <480,310,680,350>
  slot UpdateSeconds
  {
    var int32 hour = TimePicker.Hour;
    var int32 minute = TimePicker.Minute;
    var int32 second = TimePicker.Second;

    Seconds=hour*3600+minute*60+second;

    if(Seconds>0) 
    {
      postsignal OnValidEntry;
      FloatEffect.CycleDuration=Seconds*1000;
      FloatEffect.Value2=360.0;
      FloatEffect.Value1=0.0;
    }
  }

  $rect <20,20,160,60>
  object Clock::TimePicker TimePicker
  {
    preset Bounds = <66,92,314,289>;
    preset OnChange = UpdateSeconds;
    preset OnAnimationEnded = OnAnimationEnded;
  }

  $rect <480,270,680,310>
  method void ResetTime()
  {
    TimePicker.SetTime( 0 );
    TimerPath.EndAngle=270;

    FloatEffect.Enabled=false;

    TimePicker.Cover.Enabled=false;

    postsignal OnEnd;
  }

  $rect <480,230,680,270>
  method void Start()
  {
    TimePicker.Cover.Enabled=true;
    FloatEffect.Enabled=true;
  }

  $rect <480,190,680,230>
  method void Stop()
  {
    var float value=FloatEffect.Value;
    FloatEffect.Enabled=false;
    FloatEffect.Value1=value;
  }

  $rect <1079,199,1279,239>
  property slot OnEnd;

  $rect <870,0,1070,40>
  property int32 Seconds;

  $rect <870,40,1070,80>
  onset Seconds
  {
    // The value doesn't change - nothing to do.
    if ( pure Seconds == value )
      return;

    // Remember the property's new value.
    pure Seconds = value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <870,80,1070,120>
  onget Seconds
  {
    return pure Seconds;
  }

  $rect <1079,240,1279,280>
  property slot OnValidEntry;

  $rect <1670,160,1870,200>
  slot OnEndEffect
  {
    postsignal OnEnd;
    TimePicker.SetTime( 0 );
    TimePicker.End();
  }

  $rect <1470,160,1670,200>
  slot OnAnimateEffect
  {
    TimerPath.EndAngle=TimerPath.StartAngle+uint32(FloatEffect.Value);
    if(Seconds==0) return;
    TimePicker.SetTime( Seconds-int32(FloatEffect.Value/(360.0/float(Seconds))));
  }

  $rect <1280,160,1470,200>
  object Effects::FloatEffect FloatEffect
  {
    preset OnFinished = OnEndEffect;
    preset OnAnimate = OnAnimateEffect;
    preset NoOfCycles = 1;
    preset Value2 = 360.0;
  }

  $rect <1280,280,1480,320>
  slot OnAnimationEnded
  {
    ResetTime();
  }
}

$rect <480,190,680,230>
$output false
resource Resources::Font MediumFont
{
  attr fontname FontName = Agency FB;
  attr fontheight Height = 80;
  attr fontheightmode HeightMode = Popular;
  attr fontquality Quality = High;
  attr fontranges Ranges = 0x20-0xFF;
  attr fontaspectratio AspectRatio = 1;
  attr fontbold Bold = true;
  attr fontitalic Italic = false;
  attr fontkerning Kerning = true;
  attr fontrowdistance RowDistance;
}

// This is a GUI component.
$rect <90,557,290,597>
$output false
class TimePicker : Templates::PickerControl
{
  $rect <250,500,450,540>
  inherited property Bounds = <0,0,248,197>;

  $rect <480,280,680,320>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    // Determine the new state of the time picker widget.
    //
    // isEnabled  --> the time picker can react to user inputs.
    // isSelected --> the time picker can receive keyboard events.
    // isSliding  --> the user interacts with the time picker.
    //
    var bool isEnabled  = aState.contains( Core::ViewState[ Enabled  ]);
    var bool isSelected = aState.contains( Core::ViewState[ Selected ]);
    var bool isSliding  = TouchHandlerHour.Sliding   || 
                          TouchHandlerMinute.Sliding ||
                          TouchHandlerSecond.Sliding;

    /*

      TO DO:

      Depending on your time picker design, you have surely added some new 
      views  to your time picker. In the below code you should update the
      properties of these views. For example, when your picker has an image
      which you want to show only while the user is changing the time, than
      following can be done:

        theImage.Visible = isSliding;

      Depending on the state of the time picker, you can alternate any property 
      of your views. You can change their visibility, colors, opacity, bitmaps
      shown in image views, fonts used to render text, the position and the
      size the view, ...
       

      HINT:

      Instead of instantly alternate the views properties you can here also
      start effects to do this with an animation. Important: To decide when
      to start an effect you should compare the current state of the picker
      (e.g. 'isSliding') with its preceding state (e.g. variable 'sliding').

      Assuming you have already added to your time picker component a new
      effect member, named it 'slidingEffect' and configured it to animate
      e.g. the opacity of an image within the time picker. Then following is
      sufficient to trigger the animation:

        if ( isSliding && !sliding )
        {
          pressedEffect.Reversed = false;
          pressedEffect.Enabled  = true;
        }
        else if ( !isSliding && sliding )
        {
          pressedEffect.Reversed = true;
          pressedEffect.Enabled  = true;
        }

    */


    // Remember the current state. Next time when the UpdateViewState() is called
    // you can compare the 'old' state with the 'new' state and perform more
    // sophisticated update, e.g. you can start an animation effect for the
    // sliding <<-->> not sliding transition.
    enabled  = isEnabled;
    selected = isSelected;
    sliding  = isSliding;
  }

  // State Management
  note group Note3
  {
    attr Bounds = <470,240,690,450>;
  }

  // Touch screen events
  note group Note2
  {
    attr Bounds = <240,240,460,500>;
  }

  // List Management
  note group Note1
  {
    attr Bounds = <10,240,230,410>;
  }

  // This variable stores the current state of the time picker.
  $rect <480,400,680,440>
  var bool sliding;

  // This variable stores the current state of the time picker.
  $rect <480,360,680,400>
  var bool selected;

  // This method is called when one of the Slide Touch Handler (TouchHandlerHour, \
  // TouchHandlerMinute or TouchHandlerSecond) has finished the slide animation. \
  // Thereupon the owner of the time picker is notified, that the time has been changed.
  $rect <250,320,450,360>
  slot OnEndSlide
  {
    // The user has finished the interaction with the time picker. Request the
    // UpdateViewState() method to be called in order to eventually refresh
    // the time picker appearance.
    InvalidateViewState();

    // Notify the owner of the time picker, that the user has selected another time.
    // Do this however only after the last list has finished the slide animation.
    if ( !TouchHandlerHour.Sliding && !TouchHandlerMinute.Sliding && !TouchHandlerSecond.Sliding )
      postsignal OnChange;
  }

  // This method is called when one of the Slide Touch Handler (TouchHandlerHour, \
  // TouchHandlerMinute or TouchHandlerSecond) has begun the slide animation.
  $rect <250,280,450,320>
  slot OnStartSlide
  {
    // The user has begun an interaction with the time picker. Request the
    // UpdateViewState() method to be called in order to eventually refresh
    // the time picker appearance.
    InvalidateViewState();
  }

  // This method is called by 'ListSecond' vertical list every time the list loads \
  // or updates an item.
  $rect <20,360,220,400>
  slot OnLoadSecondItem
  {
    // Get the number of the item to load. The list component takes care of the
    // creation of the corresponding item view. Just access it ...
    var int32       itemNo   = ListSecond.Item;
    var Views::Text itemView = (Views::Text)ListSecond.View;

    // The implementation of this slot method does not match the item class
    // specified in the associated list component. Or the slot method is not
    // called in context of the OnLoadItem list operation.
    if ( itemView == null )
      return;

    var int32 itemCenter = ListSecond.GetItemAtPosition( SecondCenter );
    itemView.String    = string( itemNo, 2 );
    itemView.Font      = ( itemCenter == itemNo )?  Clock::LargeFont : Clock::SmallFont;
    itemView.Color     = ( itemCenter == itemNo )? TimeColor : #FAE9E080;
    itemView.Alignment = Views::TextAlignment[ AlignHorzCenter, AlignVertCenter ];
    itemView.ScrollOffset = <0,-2>;                  
    // Ensure that the item has correct size. The position of the item will be
    // managed by the list component.
    itemView.Bounds.size = point( ListSecond.Bounds.w, ListSecond.ItemHeight );
  }

  // This method is called by 'ListMinute' vertical list every time the list loads \
  // or updates an item.
  $rect <20,320,220,360>
  slot OnLoadMinuteItem
  {
    // Get the number of the item to load. The list component takes care of the
    // creation of the corresponding item view. Just access it ...
    var int32       itemNo   = ListMinute.Item;
    var Views::Text itemView = (Views::Text)ListMinute.View;

    // The implementation of this slot method does not match the item class
    // specified in the associated list component. Or the slot method is not
    // called in context of the OnLoadItem list operation.
    if ( itemView == null )
      return;

    var int32 itemCenter = ListMinute.GetItemAtPosition( MinuteCenter );
    itemView.String    = string( itemNo, 2 );
    itemView.Font      = ( itemCenter == itemNo )?  Clock::LargeFont : Clock::SmallFont;
    itemView.Color     = ( itemCenter == itemNo )? TimeColor : #FAE9E080;
    itemView.Alignment = Views::TextAlignment[ AlignHorzCenter, AlignVertCenter ];
    itemView.ScrollOffset = <0,-2>;                  
    // Ensure that the item has correct size. The position of the item will be
    // managed by the list component.
    itemView.Bounds.size = point( ListMinute.Bounds.w, ListMinute.ItemHeight );
  }

  // This method is called by 'ListHour' vertical list every time the list loads \
  // or updates an item.
  $rect <20,280,220,320>
  slot OnLoadHourItem
  {
    // Get the number of the item to load. The list component takes care of the
    // creation of the corresponding item view. Just access it ...
    var int32       itemNo   = ListHour.Item;
    var Views::Text itemView = (Views::Text)ListHour.View;

    // The implementation of this slot method does not match the item class
    // specified in the associated list component. Or the slot method is not
    // called in context of the OnLoadItem list operation.
    if ( itemView == null )
      return;

    var int32 itemCenter = ListHour.GetItemAtPosition( HourCenter );
    // Configure the item view ...     
    itemView.String    = string( itemNo ,2);
    itemView.Font      = ( itemCenter == itemNo )?  Clock::LargeFont : Clock::SmallFont;
    itemView.Color     = ( itemCenter == itemNo )? TimeColor : #FAE9E080;
    itemView.Alignment = Views::TextAlignment[ AlignHorzCenter, AlignVertCenter ]; 
    itemView.ScrollOffset = <0,-2>;
                     
    // Ensure that the item has correct size. The position of the item will be
    // managed by the list component.
    itemView.Bounds.size = point( ListHour.Bounds.w, ListHour.ItemHeight );
  }

  $rect <670,90,869,130>
  onget Second
  {
    // From the actual scroll offset calculate the number of the corresponding
    // list item. Note, the list displays the actually selected time at the
    // third position (index 2).
    return (( -ListSecond.ScrollOffset / ListSecond.ItemHeight ) + 1 ) % 60;
  }

  $rect <669,50,870,90>
  onset Second
  {
    // Limit the assigned value to the valid range 0 .. 59
    if ( value < 0  ) value = 0;
    if ( value > 59 ) value = 59;

    // Adjust the scroll position of the corresponding list. Note, the
    // list displays the actually selected time scrolled by two items.
    // Take this displacement in account.
    ListSecond.ScrollOffset = ( value - 1 ) * -ListSecond.ItemHeight;

    ListSecond.InvalidateItems( 0, ListSecond.NoOfItems );
  }

  $rect <469,90,669,130>
  onget Minute
  {
    // From the actual scroll offset calculate the number of the corresponding
    // list item. Note, the list displays the actually selected time at the
    // third position (index 2).
    return (( -ListMinute.ScrollOffset / ListMinute.ItemHeight ) + 1 ) % 60;
  }

  $rect <469,50,669,90>
  onset Minute
  {
    // Limit the assigned value to the valid range 0 .. 59
    if ( value < 0  ) value = 0;
    if ( value > 59 ) value = 59;

    // Adjust the scroll position of the corresponding list. Note, the
    // list displays the actually selected time scrolled by two items.
    // Take this displacement in account.
    ListMinute.ScrollOffset = ( value - 1 ) * -ListMinute.ItemHeight;

    ListMinute.InvalidateItems( 0, ListMinute.NoOfItems );
  }

  $rect <269,90,469,130>
  onget Hour
  {
    // From the actual scroll offset calculate the number of the corresponding
    // list item. Note, the list displays the actually selected time at the
    // third position (index 2).
    return (( -ListHour.ScrollOffset / ListHour.ItemHeight ) +1) % 24;
  }

  $rect <269,50,469,90>
  onset Hour
  {
    // Limit the assigned value to the valid range 0 .. 23
    if ( value < 0  ) value = 0;
    if ( value > 23 ) value = 23;
    // Adjust the scroll position of the corresponding list. Note, the
    // list displays the actually selected time scrolled by two items.
    // Take this displacement in account.
    ListHour.ScrollOffset = ( value - 1 ) * -ListHour.ItemHeight;

    ListHour.InvalidateItems( 0, ListHour.NoOfItems );
  }

  $rect <20,20,160,60>
  object Views::Border BorderCurrent
  {
    preset Bounds = <19,68,230,124>;
    preset Width = 5;
    preset Color = #FAE9E0FF;
    preset Visible = true;
  }

  $rect <20,20,160,60>
  object Core::SlideTouchHandler TouchHandlerSecond
  {
    preset Bounds = <169,8,230,187>;
    preset OnSlide = OnSlideSecond;
    preset OnEnd = OnEndSlide;
    preset OnStart = OnStartSlide;
    preset SnapNext = <0,60>;
    preset Friction = 0.2;
  }

  $rect <20,20,160,60>
  object Core::SlideTouchHandler TouchHandlerMinute
  {
    preset Bounds = <94,7,155,186>;
    preset OnSlide = OnSlideMinute;
    preset OnEnd = OnEndSlide;
    preset OnStart = OnStartSlide;
    preset SnapNext = <0,60>;
    preset Friction = 0.2;
  }

  // This variable stores the current state of the time picker.
  $rect <480,320,680,360>
  var bool enabled = true;

  $rect <20,20,160,60>
  object Core::SlideTouchHandler TouchHandlerHour
  {
    preset Bounds = <19,6,80,186>;
    preset OnSlide = OnSlideHour;
    preset OnEnd = OnEndSlide;
    preset OnStart = OnStartSlide;
    preset SnapNext = <0,60>;
    preset Friction = 0.2;
  }

  $rect <20,20,160,60>
  object Core::VerticalList ListSecond
  {
    preset Bounds = <169,7,230,187>;
    preset Enabled = true;
    preset OnLoadItem = OnLoadSecondItem;
    preset Endless = true;
    preset SlideHandler = TouchHandlerSecond;
    preset ScrollOffset = 60;
    preset SelectedItem = -1;
    preset ItemHeight = 60;
    preset NoOfItems = 60;
  }

  $rect <20,20,160,60>
  object Core::VerticalList ListMinute
  {
    preset Bounds = <94,7,155,187>;
    preset Enabled = true;
    preset OnLoadItem = OnLoadMinuteItem;
    preset Endless = true;
    preset SlideHandler = TouchHandlerMinute;
    preset ScrollOffset = 60;
    preset ItemHeight = 60;
    preset NoOfItems = 60;
  }

  $rect <20,20,160,60>
  object Core::VerticalList ListHour
  {
    preset Bounds = <19,7,80,188>;
    preset Enabled = true;
    preset OnLoadItem = OnLoadHourItem;
    preset Endless = true;
    preset SlideHandler = TouchHandlerHour;
    preset ScrollOffset = 60;
    preset SelectedItem = 2;
    preset ItemHeight = 60;
    preset NoOfItems = 24;
  }

  $rect <20,20,160,60>
  object Views::Text Separator1
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToTop];
    preset Bounds = <155,61,169,116>;
    preset String = ":";
    preset Font = Clock::LargeFont;
    preset Color = #FAE9E0FF;
  }

  $rect <20,20,160,60>
  object Views::Text Separator2
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToTop];
    preset Bounds = <80,61,94,116>;
    preset String = ":";
    preset Font = Clock::LargeFont;
    preset Color = #FAE9E0FF;
  }

  // The property 'OnChange' can refer to a slot method, which will receive a signal \
  // each time the user select another time. Thereupon the method's logic will be \
  // executed. In the associated slot method you can evaluate the time picker properties \
  // @Hour, @Minute and @Second.
  $rect <269,150,469,190>
  property slot OnChange = null;

  // The property 'Second' stores the number of seconds after the minute. The value \
  // is valid in range 0 .. 59.
  $rect <669,10,869,50>
  property int32 Second = 0;

  // The property 'Minute' stores the number of minutes after the hour. The value \
  // is valid in range 0 .. 59.
  $rect <469,10,669,50>
  property int32 Minute = 0;

  // The property 'Hour' stores the number of hours since midnight. The value is \
  // valid in range 0 .. 23.
  $rect <269,10,469,50>
  property int32 Hour = 0;

  // This method is called when one of the Slide Touch Handler (TouchHandlerDay, \
  // TouchHandlerMonth or TouchHandlerYear) has finished the slide animation. Thereupon \
  // the owner of the date picker is notified, that the date has been changed.
  $rect <250,450,450,490>
  slot OnSlideSecond
  {
    ListSecond.InvalidateItems( 0, ListSecond.NoOfItems );
  }

  // This method is called when one of the Slide Touch Handler (TouchHandlerDay, \
  // TouchHandlerMonth or TouchHandlerYear) has finished the slide animation. Thereupon \
  // the owner of the date picker is notified, that the date has been changed.
  $rect <250,410,450,450>
  slot OnSlideMinute
  {
    ListMinute.InvalidateItems( 0, ListMinute.NoOfItems );
  }

  // This method is called when one of the Slide Touch Handler (TouchHandlerDay, \
  // TouchHandlerMonth or TouchHandlerYear) has finished the slide animation. Thereupon \
  // the owner of the date picker is notified, that the date has been changed.
  $rect <250,370,450,410>
  slot OnSlideHour
  {
    ListHour.InvalidateItems( 0, ListHour.NoOfItems );
  }

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler Cover
  {
    preset Point4 = <0,0>;
    preset Point3 = <247,0>;
    preset Point2 = <247,197>;
    preset Point1 = <0,197>;
    preset Enabled = false;
  }

  $rect <690,240,890,280>
  var point HourCenter = <30,90>;

  $rect <690,279,890,319>
  var point MinuteCenter = <124,90>;

  $rect <690,320,890,360>
  var point SecondCenter = <199,90>;

  $rect <470,150,670,190>
  method void SetTime( arg int64 value )
  {
    Second=int32(value%60);
    Minute=int32((value%3600)/60);
    Hour=int32((value%86400)/3600);

  }

  $rect <890,240,1090,280>
  object Effects::ColorEffect ColorEffect
  {
    preset OnFinished = OnFinishedFlash;
    preset Symmetric = true;
    preset NoOfCycles = 2;
    preset Enabled = false;
    preset Value2 = #FF0000FF;
    preset Value1 = #FAE9E0FF;
    preset Outlet = ^TimeColor;
  }

  $rect <690,370,890,410>
  property color TimeColor = #FAE9E0FF;

  $rect <690,410,890,440>
  onset TimeColor
  {
    // The value doesn't change - nothing to do.
    if ( pure TimeColor == value )
      return;

    // Remember the property's new value.
    pure TimeColor = value;

    ListHour.InvalidateItems( 0, ListHour.NoOfItems );
    ListMinute.InvalidateItems( 0, ListMinute.NoOfItems );
    ListSecond.InvalidateItems( 0, ListSecond.NoOfItems );
    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <690,450,890,490>
  onget TimeColor
  {
    return pure TimeColor;
  }

  $rect <890,200,1090,240>
  method void End()
  {
    ColorEffect.Enabled=true;
  }

  $rect <890,280,1090,320>
  slot OnFinishedFlash
  {
    postsignal OnAnimationEnded;
  }

  $rect <1090,200,1290,240>
  property slot OnAnimationEnded;

  $reorder OnSetOpacity 9
  $reorder OnGetEmbedded 9
  $reorder OnSetEmbedded 9
  $reorder OnGetAlphaBlended 9
  $reorder OnSetAlphaBlended 9
  $reorder OnGetVisible 9
  $reorder OnSetVisible 9
  $reorder DrawForeground 9
  $reorder DrawBackground 9
  $reorder GetMinimalSize 9
  $reorder FindActiveDialogByClass 9
  $reorder FindDialogByClass 9
  $reorder FindCurrentDialog 9
  $reorder IsCurrentDialog 9
  $reorder IsActiveDialog 9
  $reorder IsDialog 9
  $reorder GetIndexOfDialog 9
  $reorder GetDialogAtIndex 9
  $reorder CountDialogs 9
  $reorder SwitchToDialog 9
  $reorder DismissDialog 9
  $reorder PresentDialog 9
  $reorder ObtainFocus 9
  $reorder HasViewState 9
  $reorder LocalPosition 9
  $reorder GlobalPosition 9
  $reorder DispatchEvent 9
  $reorder BroadcastEventAtPosition 9
  $reorder BroadcastEvent 9
  $reorder UpdateLayout 9
  $reorder UpdateViewState 9
  $reorder InvalidateLayout 9
  $reorder InvalidateViewState 9
  $reorder InvalidateArea 9
  $reorder GetIndexOfView 9
  $reorder GetViewAtIndex 9
  $reorder CountViews 9
  $reorder FindViewInDirection 9
  $reorder FindViewWithinArea 9
  $reorder FindViewAtPosition 9
  $reorder FindPrevView 9
  $reorder FindNextView 9
  $reorder FindSiblingView 9
  $reorder GetContentArea 9
  $reorder FadeGroup 9
  $reorder RestackBehind 9
  $reorder RestackBack 9
  $reorder RestackTop 9
  $reorder Restack 9
  $reorder RemoveAll 9
  $reorder Remove 9
  $reorder Opacity 14
  $reorder Embedded 14
  $reorder AlphaBlended 14
  $reorder Visible 14
  $reorder Note3 14
  $reorder Note2 14
  $reorder Note1 14
  $reorder sliding 14
  $reorder selected 14
  $reorder OnEndSlide 14
  $reorder OnStartSlide 14
  $reorder OnLoadSecondItem 14
  $reorder OnLoadMinuteItem 14
  $reorder OnLoadHourItem 14
  $reorder OnGetSecond 14
  $reorder OnSetSecond 14
  $reorder OnGetMinute 14
  $reorder OnSetMinute 14
  $reorder OnGetHour 14
  $reorder OnSetHour 14
  $reorder BorderCurrent 14
  $reorder TouchHandlerSecond 14
  $reorder TouchHandlerMinute 14
  $reorder enabled 14
  $reorder TouchHandlerHour 14
  $reorder ListSecond 14
  $reorder ListMinute 14
  $reorder ListHour 14
  $reorder Separator1 14
  $reorder Separator2 14
  $reorder OnChange 14
  $reorder Second 14
  $reorder Minute 14
  $reorder Hour 14
  $reorder OnSlideSecond 14
  $reorder OnSlideMinute 14
  $reorder OnSlideHour 14
  $reorder AddBehind 9
  $reorder Add 9
  $reorder Focus 9
  $reorder Buffered 9
}

$rect <80,190,280,230>
$output false
class TimerScreen : Core::Group
{
  $rect <0,540,200,580>
  inherited method Init()
  {
    postsignal UpdateTime;
  }

  $rect <0,500,200,540>
  inherited property Bounds = rect(0,0,$ScreenSize.x,$ScreenSize.y);

  $rect <210,640,410,680>
  slot WipeUpSlot
  {
    Owner.SwitchToDialog(new Clock::ClockScreen, Effects::SlideUpCentered, null, null, null, null, null, null, null, null, false );
  }

  $rect <210,500,410,540>
  slot UpdateTime
  {
    var Core::Time currentTime = Clock::Time.CurrentTime;
    Hour.String=string(currentTime.Hour/10)+string(currentTime.Hour%10)+":"+string(currentTime.Minute/10)+string(currentTime.Minute%10);
  }

  $rect <0,630,200,670>
  slot OnStart
  {
    switch(StartButton.FrameNumber==1)
    {
      case true:
      {
        TimerClock.Stop();
        StartButton.FrameNumber=0;
      }
      case false:
      {
        TimerClock.Start();
        StartButton.FrameNumber=1;
      }
      default:;
    }              

  }

  $rect <-10,680,192,720>
  slot OnCancel
  {
    TimerClock.ResetTime();

  }

  $rect <419,590,619,630>
  slot OnValidEntry
  {
    StartButton.Enabled=true;
    CancelButton.Enabled=true;

    StartButton.FrameNumber=0;

  }

  $rect <410,500,710,540>
  object Core::SystemEventHandler TimeChangedHandler
  {
    preset OnEvent = UpdateTime;
    preset Event = Clock::Device.TimeChanged;
  }

  $rect <420,630,620,670>
  slot OnEnd
  {
    StartButton.Enabled=false;
    CancelButton.Enabled=false;

    StartButton.FrameNumber=0;

  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Bounds = <0,39,640,480>;
    preset Color = #1D243858;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle1
  {
    preset Bounds = <0,439,640,480>;
    preset ColorBL = #FFFFFFFF;
    preset ColorBR = #FFFFFFFF;
    preset ColorTR = #FFFFFF53;
    preset ColorTL = #FFFFFF53;
    preset Color = #0F1E35FF;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle2
  {
    preset Bounds = <0,39,640,80>;
    preset ColorBL = #FFFFFF53;
    preset ColorBR = #FFFFFF53;
    preset ColorTR = #FFFFFFFF;
    preset ColorTL = #FFFFFFFF;
    preset Color = #0F1E35FF;
  }

  $rect <20,20,160,60>
  object Views::Border Border1
  {
    preset Bounds = <0,0,640,80>;
    preset Color = #0F1E358C;
  }

  $rect <20,20,160,60>
  object Views::Border Border2
  {
    preset Bounds = <0,439,640,479>;
    preset Color = #0F1E358C;
  }

  $rect <20,20,160,60>
  object Views::Image Image
  {
    preset Bounds = <295,430,345,480>;
    preset Color = #FAE9E0FF;
    preset Bitmap = Resources::NavigationIconsMedium;
  }

  $rect <20,20,160,60>
  object Core::WipeTouchHandler WipeUp
  {
    preset Bounds = <0,430,640,479>;
    preset OnTop = WipeUpSlot;
  }

  $rect <20,20,160,60>
  object Views::Text Hour
  {
    preset Bounds = <458,9,640,70>;
    preset Alignment = Views::TextAlignment[AlignHorzAuto, AlignHorzCenter, AlignVertCenter];
    preset String = "Text";
    preset Font = Clock::LargeFont;
    preset Color = #FAE9E0FF;
  }

  $rect <20,20,160,60>
  object Clock::TimerClock TimerClock
  {
    preset Bounds = <131,26,510,405>;
    preset OnEnd = OnEnd;
    preset OnValidEntry = OnValidEntry;
  }

  $rect <20,20,160,60>
  object Clock::DefaultButton CancelButton
  {
    preset Bounds = <220,367,320,416>;
    preset Enabled = false;
    preset OnPress = OnCancel;
    preset FrameNumber = 14;
    preset Bitmap = Resources::NavigationIconsMedium;
    preset IconColor = #FAE9E0FF;
    preset Color = #0F1E35FF;
    preset LabelColor = #FAE9E0FF;
    preset Label = "";
    preset Font = Resources::FontMedium;
  }

  $rect <20,20,160,60>
  object Clock::DefaultButton StartButton
  {
    preset Bounds = <320,367,420,416>;
    preset Enabled = false;
    preset OnPress = OnStart;
    preset FrameNumber = 0;
    preset Bitmap = Resources::PlayerIconsMedium;
    preset IconColor = #FAE9E0FF;
    preset Color = #0F1E35FF;
    preset LabelColor = #FAE9E0FF;
    preset Label = "";
    preset Font = Resources::FontMedium;
  }

  $rect <20,20,160,60>
  object Views::Line Line
  {
    preset Point2 = <320,410>;
    preset Point1 = <320,373>;
    preset Color = #FAE9E0FF;
  }

  $rect <20,20,160,60>
  object Core::WipeTouchHandler WipeLeft
  {
    preset Bounds = <550,39,640,479>;
    preset OnLeft = WipeLeftSlot;
    preset RetargetCondition = Core::RetargetReason[WipeDown, WipeUp];
  }

  $rect <20,20,160,60>
  object Core::WipeTouchHandler WipeRight
  {
    preset Bounds = <0,40,90,478>;
    preset OnRight = WipeRightSlot;
    preset RetargetCondition = Core::RetargetReason[WipeDown, WipeUp];
  }

  $rect <210,720,410,760>
  slot WipeLeftSlot
  {
    Owner.SwitchToDialog(new Clock::AlarmScreen, Effects::SlideLeftCentered, null, null, null, null, null, null, null, null, false );
  }

  $rect <210,680,410,720>
  slot WipeRightSlot
  {
    Owner.SwitchToDialog(new Clock::CalendarScreen, Effects::SlideRightCentered, null, null, null, null, null, null, null, null, false );
  }
}

$rect <80,230,280,270>
$output false
class ChronometerScreen : Core::Group
{
  $rect <0,540,200,580>
  inherited method Init()
  {
    postsignal UpdateTime;

  }

  $rect <0,500,200,540>
  inherited property Bounds = rect(0,0,$ScreenSize.x,$ScreenSize.y);

  $rect <0,590,200,630>
  object Core::Timer Timer
  {
    preset OnTrigger = UpdateTime;
    preset Period = 100;
    preset Enabled = true;
  }

  $rect <210,690,410,730>
  slot WipeUpSlot
  {
    Owner.SwitchToDialog(new Clock::ClockScreen, Effects::SlideUpCentered, null, null, null, null, null, null, null, null, false );
  }

  $rect <210,500,410,540>
  slot UpdateTime
  {
    var Core::Time currentTime = Clock::Time.CurrentTime;
    Hour.String=string(currentTime.Hour/10)+string(currentTime.Hour%10)+":"+string(currentTime.Minute/10)+string(currentTime.Minute%10);
  }

  $rect <210,730,410,770>
  slot ChangeButtons
  {
    ResetButton.Enabled=Chronometer.Running;
    SaveButton.Enabled=Chronometer.Running;
  }

  $rect <410,539,610,579>
  slot OnPauseButton
  {
    switch(PauseButton.FrameNumber==1)
    {
      case true:
      {
        Chronometer.Enabled=false;
        PauseButton.FrameNumber=0;
      }
      case false:
      {
        if(!Chronometer.Running) Chronometer.Running=true;
        Chronometer.Enabled=true;
        PauseButton.FrameNumber=1;
      }
      default:;
    }

  }

  $rect <410,579,610,619>
  slot OnResetButton
  {
    Chronometer.Enabled=false;
    Chronometer.Running=false;
    Chronometer.CurrentValue=0;

    PauseButton.FrameNumber=0;
  }

  $rect <410,619,610,659>
  slot OnSaveButton
  {
    var Views::Text txt=new Views::Text;
    txt.Embedded=true;
    txt.Bounds=<0,0,320,50>;
    txt.Font=Clock::LargeFont;
    txt.String=Chronometer.HourText.String+":"+ Chronometer.MinuteText.String+":"+Chronometer.SecondText.String+":"+Chronometer.MillisecondText.String;
    Add( txt, 0 );
    postsignal UpdateOutline;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Bounds = <0,39,640,480>;
    preset Color = #1D243858;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle1
  {
    preset Bounds = <0,439,640,480>;
    preset ColorBL = #0F1E35FF;
    preset ColorBR = #0F1E35FF;
    preset ColorTR = #0F1E3553;
    preset ColorTL = #0F1E3553;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle2
  {
    preset Bounds = <0,39,640,80>;
    preset ColorBL = #0F1E3553;
    preset ColorBR = #0F1E3553;
    preset ColorTR = #0F1E35FF;
    preset ColorTL = #0F1E35FF;
  }

  $rect <20,20,160,60>
  object Views::Image Image3
  {
    preset Bounds = <295,430,345,480>;
    preset Color = #FAE9E0FF;
    preset Bitmap = Resources::NavigationIconsMedium;
  }

  $rect <20,20,160,60>
  object Views::Border Border
  {
    preset Bounds = <0,439,640,479>;
    preset Color = #0F1E358C;
  }

  $rect <20,20,160,60>
  object Views::Border Border1
  {
    preset Bounds = <0,0,640,80>;
    preset Color = #0F1E358C;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle4
  {
    preset Bounds = <320,110,640,160>;
    preset ColorBL = #0F1E354A;
    preset ColorBR = #0F1E3592;
    preset ColorTR = #0F1E3592;
    preset ColorTL = #0F1E354A;
    preset Color = #FFFFFFFF;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle5
  {
    preset Bounds = <0,110,320,160>;
    preset ColorBL = #0F1E3592;
    preset ColorBR = #0F1E354A;
    preset ColorTR = #0F1E354A;
    preset ColorTL = #0F1E3592;
    preset Color = #FFFFFFFF;
  }

  $rect <20,20,160,60>
  object Views::Image Image1
  {
    preset Bounds = <595,110,645,160>;
    preset Color = #FAE9E0FF;
    preset ScrollOffset = <0,0>;
    preset FrameNumber = 3;
    preset Bitmap = Resources::NavigationIconsMedium;
  }

  $rect <20,20,160,60>
  object Views::Image Image2
  {
    preset Bounds = <0,110,50,160>;
    preset Color = #FAE9E0FF;
    preset ScrollOffset = <0,0>;
    preset FrameNumber = 2;
    preset Bitmap = Resources::NavigationIconsMedium;
  }

  $rect <210,770,410,810>
  slot UpdateOutline
  {
    var Core::View view=Outline.GetViewAtIndex( Outline.CountViews()-1 );
    var Effects::PointEffect pointEffect=new Effects::PointEffect;
    Outline.EnsureVisible( view, true, pointEffect, null );
  }

  $rect <20,20,160,60>
  object Core::Outline Outline
  {
    preset Bounds = <0,110,640,160>;
    preset OnUpdate = null;
    preset SlideHandler = SlideTouchHandler;
    preset Formation = Core::Formation.LeftToRight;
  }

  $rect <20,20,160,60>
  object Core::SlideTouchHandler SlideTouchHandler
  {
    preset Bounds = <0,110,640,160>;
    preset SnapNext = <0,50>;
    preset SlideVert = false;
    preset RubberBandEffectElasticity = 5.0;
  }

  $rect <20,20,160,60>
  object Clock::DefaultButton ResetButton
  {
    preset Bounds = <270,357,370,406>;
    preset Enabled = false;
    preset OnPress = OnResetButton;
    preset FrameNumber = 14;
    preset Bitmap = Resources::NavigationIconsMedium;
    preset IconColor = #FAE9E0FF;
    preset Color = #0F1E35FF;
    preset LabelColor = #FAE9E0FF;
    preset Label = "";
    preset Font = Resources::FontMedium;
  }

  $rect <20,20,160,60>
  object Clock::DefaultButton PauseButton
  {
    preset Bounds = <170,357,270,406>;
    preset Enabled = true;
    preset OnPress = OnPauseButton;
    preset FrameNumber = 0;
    preset Bitmap = Resources::PlayerIconsMedium;
    preset IconColor = #FAE9E0FF;
    preset Color = #0F1E35FF;
    preset LabelColor = #FAE9E0FF;
    preset Label = "";
    preset Font = Resources::FontMedium;
  }

  $rect <20,20,160,60>
  object Clock::DefaultButton SaveButton
  {
    preset Bounds = <369,357,469,406>;
    preset Enabled = false;
    preset OnPress = OnSaveButton;
    preset FrameNumber = 16;
    preset Bitmap = Resources::NavigationIconsMedium;
    preset IconColor = #FAE9E0FF;
    preset Color = #0F1E35FF;
    preset LabelColor = #FAE9E0FF;
    preset Label = "";
    preset Font = Resources::FontMedium;
  }

  $rect <20,20,160,60>
  object Views::Line Line
  {
    preset Point2 = <270,401>;
    preset Point1 = <270,367>;
  }

  $rect <20,20,160,60>
  object Views::Line Line1
  {
    preset Point2 = <370,401>;
    preset Point1 = <370,367>;
  }

  $rect <20,20,160,60>
  object Views::Image Image
  {
    preset Bounds = <295,430,345,480>;
    preset Color = #FAE9E0FF;
    preset Bitmap = Resources::NavigationIconsMedium;
  }

  $rect <20,20,160,60>
  object Core::WipeTouchHandler WipeUp
  {
    preset Bounds = <0,430,640,479>;
    preset OnTop = WipeUpSlot;
  }

  $rect <20,20,160,60>
  object Views::Text Hour
  {
    preset Bounds = <458,9,640,70>;
    preset Alignment = Views::TextAlignment[AlignHorzAuto, AlignHorzCenter, AlignVertCenter];
    preset String = "Text";
    preset Font = Clock::LargeFont;
    preset Color = #FAE9E0FF;
  }

  $rect <20,20,160,60>
  object Clock::Chronometer Chronometer
  {
    preset Bounds = <62,172,579,343>;
    preset OnChange = ChangeButtons;
  }

  $rect <20,20,160,60>
  object Core::WipeTouchHandler WipeLeft
  {
    preset Bounds = <550,39,640,479>;
    preset OnLeft = WipeLeftSlot;
    preset RetargetCondition = Core::RetargetReason[WipeDown, WipeUp];
  }

  $rect <20,20,160,60>
  object Core::WipeTouchHandler WipeRight
  {
    preset Bounds = <0,40,90,478>;
    preset OnRight = WipeRightSlot;
    preset RetargetCondition = Core::RetargetReason[WipeDown, WipeUp];
  }

  $rect <210,650,410,690>
  slot WipeLeftSlot
  {
    Owner.SwitchToDialog(new Clock::CalendarScreen, Effects::SlideLeftCentered, null, null, null, null, null, null, null, null, false );
  }

  $rect <210,610,410,650>
  slot WipeRightSlot
  {
    Owner.SwitchToDialog(new Clock::AlarmScreen, Effects::SlideRightCentered, null, null, null, null, null, null, null, null, false );
  }
}

// This class implements an 'instrument', used to display e.g. measured values. The \
// widget is controlled by the properties @CurrentValue and @Unit.
// Alternatively the property @Outlet can refer to any other 'int32' property the \
// widget should remain synchronized with. When the referred property is modified \
// by another one, the widget is automatically notified to remain in sync with the \
// property.
// This approach follows the Model-View-Controller (MVC) programming paradigm. Here \
// the widget represents the 'View' and the property referred via 'Outlet' can be \
// seen as a part of the 'Model'.
$rect <-120,457,80,497>
$output false
class Chronometer : Templates::ValueDisplay
{
  $rect <599,239,799,279>
  inherited property Bounds = <0,0,517,171>;

  $rect <20,20,160,60>
  object Views::Text HourText
  {
    preset Bounds = <23,0,141,171>;
    preset String = "00";
    preset Font = Clock::MediumFont;
    preset Color = #FAE9E0FF;
  }

  $rect <20,20,160,60>
  object Views::Text Dots1
  {
    preset Bounds = <141,0,170,149>;
    preset String = ":";
    preset Font = Clock::MediumFont;
    preset Color = #FAE9E0FF;
  }

  $rect <20,20,160,60>
  object Views::Text MinuteText
  {
    preset Bounds = <170,0,288,171>;
    preset String = "00";
    preset Font = Clock::MediumFont;
    preset Color = #FAE9E0FF;
  }

  $rect <20,20,160,60>
  object Views::Text Dots2
  {
    preset Bounds = <288,0,317,149>;
    preset String = ":";
    preset Font = Clock::MediumFont;
    preset Color = #FAE9E0FF;
  }

  $rect <810,10,1010,50>
  inherited property Enabled = false;

  $rect <20,20,160,60>
  object Views::Text SecondText
  {
    preset Bounds = <317,0,435,171>;
    preset String = "00";
    preset Font = Clock::MediumFont;
    preset Color = #FAE9E0FF;
  }

  $rect <20,20,160,60>
  object Views::Text MillisecondText
  {
    preset Bounds = <435,21,495,171>;
    preset String = "00";
    preset Font = Clock::LargeFont;
    preset Color = #FAE9E0FF;
  }

  $rect <998,240,1198,280>
  object Core::Timer Timer
  {
    preset OnTrigger = UpdateTime;
    preset Period = 100;
    preset Enabled = false;
  }

  $rect <998,280,1198,320>
  slot UpdateTime
  {
    CurrentValue++;
  }

  $rect <798,239,998,279>
  method void SetTime( arg int32 value )
  {
    var int32 hours = 0; 
    var int32 minutes= 0;
    var int32 seconds = 0;
    var int32 milliseconds=value;

    seconds= int32(milliseconds/60);
    milliseconds-=seconds*60;

    minutes= int32(seconds/60);
    seconds-=minutes*60;

    hours=int32(minutes/60);
    minutes-=hours*60;

    HourText.String=string(hours,2);
    MinuteText.String=string(minutes,2);
    SecondText.String=string(seconds,2);
    MillisecondText.String=string(milliseconds,2);

  }

  $rect <601,8,801,48>
  property int32 CurrentValue = 0;

  $rect <601,48,801,88>
  onset CurrentValue
  {
    // The value doesn't change - nothing to do.
    if ( pure CurrentValue == value )
      return;

    // Remember the property's new value.
    pure CurrentValue = value;

    if(CurrentValue>=21599999) Enabled=false;
    SetTime(value);


  }

  $rect <601,88,801,128>
  onget CurrentValue
  {
    return pure CurrentValue;
  }

  $rect <810,50,1010,90>
  inherited onset Enabled
  {
    pure Enabled = value;

    Timer.Enabled=value;
  }

  $rect <810,90,1010,130>
  inherited onget Enabled
  {
    return pure Enabled;
  }

  // The property 'OnChange' can refer to a slot method, which will receive a signal \
  // each time the user select another time. Thereupon the method's logic will be \
  // executed. In the associated slot method you can evaluate the time picker properties \
  // @Hour, @Minute and @Second.
  $rect <599,130,799,170>
  property slot OnChange = null;

  // The property 'Enabled' determines whether the component is able to react to \
  // user input events. Disabled components will never receive these events.
  // The @Enabled property is reflected in the current state of the component Core::ViewState.Enabled. \
  // This state can be evaluated in the implementation of the @UpdateViewState() \
  // method. For example, the method may show disabled components with pale colors, \
  // etc.
  // Please note, changing the enabled state of the component currently selected \
  // in the @Focus property will cause the framework to select other sibling view, \
  // which will be able to react to keyboard events.
  $rect <999,10,1199,50>
  property bool Running = false;

  $rect <999,50,1199,90>
  onset Running
  {
    pure Running = value;

    postsignal OnChange;
  }

  $rect <999,90,1199,130>
  onget Running
  {
    return pure Running;
  }

  $reorder OnSetOpacity 4
  $reorder OnGetEmbedded 4
  $reorder OnSetEmbedded 4
  $reorder OnGetAlphaBlended 4
  $reorder OnSetAlphaBlended 4
  $reorder OnGetVisible 4
  $reorder OnSetVisible 4
  $reorder DrawForeground 4
  $reorder DrawBackground 4
  $reorder GetMinimalSize 4
  $reorder FindActiveDialogByClass 4
  $reorder FindDialogByClass 4
  $reorder FindCurrentDialog 4
  $reorder IsCurrentDialog 4
  $reorder IsActiveDialog 4
  $reorder IsDialog 4
  $reorder GetIndexOfDialog 4
  $reorder GetDialogAtIndex 4
  $reorder CountDialogs 4
  $reorder SwitchToDialog 4
  $reorder DismissDialog 4
  $reorder PresentDialog 4
  $reorder ObtainFocus 4
  $reorder HasViewState 4
  $reorder LocalPosition 4
  $reorder GlobalPosition 4
  $reorder DispatchEvent 4
  $reorder BroadcastEventAtPosition 4
  $reorder BroadcastEvent 4
  $reorder UpdateLayout 4
  $reorder UpdateViewState 4
  $reorder InvalidateLayout 4
  $reorder InvalidateViewState 4
  $reorder InvalidateArea 4
  $reorder GetIndexOfView 4
  $reorder GetViewAtIndex 4
  $reorder CountViews 4
  $reorder FindViewInDirection 4
  $reorder FindViewWithinArea 4
  $reorder FindViewAtPosition 4
  $reorder FindPrevView 4
  $reorder FindNextView 4
  $reorder FindSiblingView 4
  $reorder GetContentArea 4
  $reorder FadeGroup 4
  $reorder RestackBehind 4
  $reorder RestackBack 4
  $reorder RestackTop 4
  $reorder Restack 4
  $reorder RemoveAll 4
  $reorder Remove 4
  $reorder Opacity 9
  $reorder Embedded 9
  $reorder AlphaBlended 9
  $reorder Visible 9
  $reorder HourText 9
  $reorder Dots1 9
  $reorder MinuteText 9
  $reorder Dots2 9
  $reorder Enabled 8
  $reorder SecondText 8
  $reorder MillisecondText 8
  $reorder Timer 8
  $reorder UpdateTime 8
  $reorder SetTime 8
  $reorder CurrentValue 8
  $reorder OnSetCurrentValue 8
  $reorder OnGetCurrentValue 8
  $reorder AddBehind 4
  $reorder Add 4
  $reorder Focus 4
  $reorder Buffered 4
  $reorder OnSetEnabled 2
}

$rect <480,230,680,270>
$output false
resource Resources::Font SmallFont
{
  attr fontname FontName = Agency FB;
  attr fontheight Height = 35;
  attr fontheightmode HeightMode = Popular;
  attr fontquality Quality = High;
  attr fontranges Ranges = 0x20-0xFF;
  attr fontaspectratio AspectRatio = 1;
  attr fontbold Bold = true;
  attr fontitalic Italic = false;
  attr fontkerning Kerning = true;
  attr fontrowdistance RowDistance;
}

$rect <80,270,280,310>
$output false
class AlarmScreen : Core::Group
{
  $rect <0,540,200,580>
  inherited method Init()
  {
    postsignal UpdateTime;
    TimePicker.SetTime( Clock::Time.CurrentTime.Time );
  }

  $rect <0,500,200,540>
  inherited property Bounds = rect(0,0,$ScreenSize.x,$ScreenSize.y);

  $rect <210,630,410,670>
  slot WipeUpSlot
  {
    Owner.SwitchToDialog(new Clock::ClockScreen, Effects::SlideUpCentered, null, null, null, null, null, null, null, null, false );
  }

  $rect <210,500,410,540>
  slot UpdateTime
  {
    var Core::Time currentTime =  Clock::Time.CurrentTime;
    Hour.String=string(currentTime.Hour/10)+string(currentTime.Hour%10)+":"+string(currentTime.Minute/10)+string(currentTime.Minute%10);
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Bounds = <0,39,640,480>;
    preset Color = #1D243858;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle1
  {
    preset Bounds = <0,439,640,480>;
    preset ColorBL = #FFFFFFFF;
    preset ColorBR = #FFFFFFFF;
    preset ColorTR = #FFFFFF53;
    preset ColorTL = #FFFFFF53;
    preset Color = #0F1E35FF;
  }

  $rect <20,20,160,60>
  object Views::Border Border
  {
    preset Bounds = <0,439,640,479>;
    preset Color = #0F1E358C;
  }

  $rect <20,20,160,60>
  object Views::Border Border1
  {
    preset Bounds = <0,0,640,80>;
    preset Color = #0F1E358C;
  }

  $rect <20,20,160,60>
  object Views::Image Image
  {
    preset Bounds = <295,430,345,480>;
    preset Bitmap = Resources::NavigationIconsMedium;
  }

  $rect <20,20,160,60>
  object Core::WipeTouchHandler WipeUp
  {
    preset Bounds = <0,430,640,479>;
    preset OnTop = WipeUpSlot;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle3
  {
    preset Bounds = <0,39,640,80>;
    preset ColorBL = #FFFFFF53;
    preset ColorBR = #FFFFFF53;
    preset ColorTR = #FFFFFFFF;
    preset ColorTL = #FFFFFFFF;
    preset Color = #0F1E35FF;
  }

  $rect <20,20,160,60>
  object Views::Text Hour
  {
    preset Bounds = <458,9,640,70>;
    preset Alignment = Views::TextAlignment[AlignHorzAuto, AlignHorzCenter, AlignVertCenter];
    preset String = "00:00";
    preset Font = Clock::LargeFont;
    preset Color = #FAE9E0FF;
  }

  $rect <20,20,160,60>
  object Clock::TimePicker TimePicker
  {
    preset Bounds = <125,128,373,325>;
    preset OnChange = null;
  }

  $rect <20,20,160,60>
  object Views::Line Line;

  $rect <20,20,160,60>
  object Views::Line Line1
  {
    preset Point2 = <507,390>;
    preset Point1 = <507,128>;
    preset Width = 3;
    preset Color = #FAE9E0FF;
  }

  $rect <210,670,410,710>
  slot OnAddButton
  {
    var int64 currentTime=Clock::Time.CurrentTime.Time;
    var Clock::Event event=new Clock::Event;
    event.Type=Clock::EventType.Alarm;
    event.TriggerTime=currentTime-currentTime%86400+TimePicker.Hour*3600+TimePicker.Minute*60+TimePicker.Second;


    if(Clock::Device.AddEvent( event ))
    {      
      var int32 index;
      for(index=0;index<7;index++) 
      {
        event.ScheduledDays[index]=WeekButtonList.SelectedDays[index];
      }
      event.IsScheduled=Clock::Device.UpdateEvent( 0 );
      if(!event.IsScheduled && event.TriggerTime<=currentTime) 
        event.TriggerTime+=86400;
    }


  }

  $rect <410,500,710,540>
  object Core::SystemEventHandler TimeChangedHandler
  {
    preset OnEvent = UpdateTime;
    preset Event = Clock::Device.TimeChanged;
  }

  $rect <20,20,160,60>
  object Core::WipeTouchHandler WipeLeft
  {
    preset Bounds = <550,39,640,479>;
    preset OnLeft = WipeLeftSlot;
    preset RetargetCondition = Core::RetargetReason[WipeDown, WipeUp];
  }

  $rect <20,20,160,60>
  object Core::WipeTouchHandler WipeRight
  {
    preset Bounds = <0,40,90,478>;
    preset OnRight = WipeRightSlot;
    preset RetargetCondition = Core::RetargetReason[WipeDown, WipeUp];
  }

  $rect <20,20,160,60>
  object Clock::DefaultButton DefaultButton
  {
    preset Bounds = <540,213,615,289>;
    preset OnPress = OnAddButton;
    preset FrameNumber = 18;
    preset Bitmap = Resources::NavigationIconsLarge;
    preset IconColor = #FAE9E0FF;
    preset Color = #0F1E35FF;
    preset LabelColor = #FAE9E0FF;
  }

  $rect <20,20,160,60>
  object Clock::WeekButtonList WeekButtonList
  {
    preset Bounds = <40,325,458,384>;
  }

  $rect <210,590,410,630>
  slot WipeLeftSlot
  {
    Owner.SwitchToDialog(new Clock::ChronometerScreen, Effects::SlideLeftCentered, null, null, null, null, null, null, null, null, false );
  }

  $rect <210,550,410,590>
  slot WipeRightSlot
  {
    Owner.SwitchToDialog(new Clock::TimerScreen, Effects::SlideRightCentered, null, null, null, null, null, null, null, null, false );
  }
}

$rect <80,310,280,350>
$output false
class CalendarScreen : Core::Group
{
  $rect <0,540,200,580>
  inherited method Init()
  {
    SelectedDate=Clock::Time.CurrentTime;
    TimePicker.SetTime( Clock::Time.CurrentTime.Time );
    UpdateString();

  }

  $rect <0,500,200,540>
  inherited property Bounds = rect(0,0,$ScreenSize.x,$ScreenSize.y);

  $rect <210,590,410,630>
  slot WipeUpSlot
  {
    Owner.SwitchToDialog(new Clock::ClockScreen, Effects::SlideUpCentered, null, null, null, null, null, null, null, null, false );
  }

  $rect <20,20,160,60>
  object Views::Border Border
  {
    preset Bounds = <0,439,640,479>;
    preset Color = #0F1E358C;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Bounds = <0,39,640,480>;
    preset Color = #00000058;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle1
  {
    preset Bounds = <0,439,640,480>;
    preset ColorBL = #FFFFFFFF;
    preset ColorBR = #FFFFFFFF;
    preset ColorTR = #FFFFFF53;
    preset ColorTL = #FFFFFF53;
    preset Color = #0F1E35FF;
  }

  $rect <20,20,160,60>
  object Views::Image Image
  {
    preset Bounds = <295,430,345,480>;
    preset Color = #FAE9E0FF;
    preset Bitmap = Resources::NavigationIconsMedium;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle3
  {
    preset Bounds = <310,39,526,438>;
    preset ColorBR = #FFFFFF00;
    preset ColorTR = #FFFFFF00;
    preset Color = #1D24384E;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle2
  {
    preset Bounds = <0,39,311,439>;
    preset Color = #276080B6;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle4
  {
    preset Bounds = <0,39,640,343>;
    preset ColorBL = #FFFFFF00;
    preset ColorBR = #FFFFFF00;
    preset ColorTR = #FFFFFFFF;
    preset Color = #1D2438FF;
  }

  $rect <20,20,160,60>
  object Clock::MonthList MonthList
  {
    preset Bounds = <0,39,311,400>;
    preset OnSelected = OnSelectedCalendar;
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <322,266,628,316>;
    preset Alignment = Views::TextAlignment[AlignHorzAuto, AlignHorzCenter, AlignVertTop];
    preset String = "";
    preset Font = Clock::SmallFont;
    preset Color = #FAE9E0FF;
  }

  $rect <0,590,200,630>
  property Core::Time SelectedDate;

  $rect <0,630,200,670>
  onset SelectedDate
  {
    // The value doesn't change - nothing to do.
    if ( pure SelectedDate == value )
      return;

    // Remember the property's new value.
    pure SelectedDate = value;
    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <0,670,200,710>
  onget SelectedDate
  {
    return pure SelectedDate;
  }

  $rect <410,590,610,630>
  slot OnSelectedCalendar
  {
    var Core::Time selected=MonthList.Selected;
    SelectedDate=Clock::Time.Initialize2( selected.Year, selected.Month, selected.Day, TimePicker.Hour, TimePicker.Minute, TimePicker.Second );
    UpdateString();
  }

  $rect <410,630,610,670>
  method void UpdateString()
  {
    Text.String=string(SelectedDate.Year)+" "+ SelectedDate.getMonthName(SelectedDate.Month,true)+" "+string(SelectedDate.Day,2)+" "+string(SelectedDate.Hour,2)+":"+string(SelectedDate.Minute,2);
    ChangeButtons(); 
  }

  $rect <410,670,610,710>
  method void ChangeButtons()
  {
    if(SelectedDate.Time<=Clock::Time.CurrentTime.Time) AddButton.Enabled=false;
    else AddButton.Enabled=true;
  }

  $rect <410,550,610,590>
  slot OnSelectedTime
  {
    SelectedDate=Clock::Time.Initialize2( SelectedDate.Year, SelectedDate.Month, SelectedDate.Day, TimePicker.Hour, TimePicker.Minute, TimePicker.Second );
    UpdateString();
  }

  $rect <210,630,410,670>
  slot OnButton
  {
    var Clock::Event event=new Clock::Event;
    event.Type=Clock::EventType.Calendar;
    event.TriggerTime=SelectedDate.Time;
    event.IsScheduled=false;
    Clock::Device.AddEvent( event );

  }

  $rect <20,20,160,60>
  object Clock::DefaultButton AddButton
  {
    preset Bounds = <437,330,512,380>;
    preset Enabled = false;
    preset OnPress = OnButton;
    preset FrameNumber = 18;
    preset Bitmap = Resources::NavigationIconsMedium;
    preset IconColor = #FAE9E0FF;
    preset Color = #0F1E35FF;
    preset LabelColor = #FAE9E0FF;
  }

  $rect <20,20,160,60>
  object Core::WipeTouchHandler WipeUp
  {
    preset Bounds = <0,430,640,479>;
    preset OnTop = WipeUpSlot;
  }

  $rect <20,20,160,60>
  object Core::WipeTouchHandler WipeLeft
  {
    preset Bounds = <550,43,640,479>;
    preset OnLeft = WipeLeftSlot;
    preset RetargetCondition = Core::RetargetReason[WipeDown, WipeUp];
  }

  $rect <20,20,160,60>
  object Core::WipeTouchHandler WipeRight
  {
    preset Bounds = <0,141,90,478>;
    preset OnRight = WipeRightSlot;
    preset RetargetCondition = Core::RetargetReason[WipeDown, WipeUp];
  }

  $rect <20,20,160,60>
  object Clock::TimePicker TimePicker
  {
    preset Bounds = <350,43,598,240>;
    preset OnChange = OnSelectedTime;
    preset TimeColor = #FAE9E0FF;
  }

  $rect <210,550,410,590>
  slot WipeLeftSlot
  {
    Owner.SwitchToDialog(new Clock::TimerScreen, Effects::SlideLeftCentered, null, null, null, null, null, null, null, null, false );
  }

  $rect <210,510,410,550>
  slot WipeRightSlot
  {
    Owner.SwitchToDialog(new Clock::ChronometerScreen, Effects::SlideRightCentered, null, null, null, null, null, null, null, null, false );
  }
}

// This class implements a 'radio button' widget. When the user presses the button, \
// the current value of the button represented by the property @Selected is set and \
// a signal is sent to the slot method stored in the property @OnSelect. Once selected, \
// the radio button remains in this state until the property @Selected is set to \
// the value 'false' (e.g. in reaction to another radio button selection).
// Alternatively the property @Outlet can refer to any other 'int32' property the \
// widget should remain synchronized with. When the user selects the radio button, \
// the affected property is automatically set to the value @OutletSelector. On the \
// other hand, when the referred property is modified by another one, the radio button \
// is automatically notified to remain in sync with the property.
// This approach follows the Model-View-Controller (MVC) programming paradigm. Here \
// the radio button represents the 'View' and 'Controller' and the property referred \
// via 'Outlet' can be seen as a part of the 'Model'.
$rect <-120,507,80,547>
$output false
class WeekButtonList : Templates::RadioButton
{
  $rect <499,-10,699,30>
  inherited property Bounds = <0,0,418,59>;

  $rect <499,50,699,90>
  array bool SelectedDays[ 7 ] =
  (
    Default[0] = false;
    Default[1] = false;
    Default[2] = false;
    Default[3] = false;
    Default[4] = false;
    Default[5] = false;
    Default[6] = false;
  );

  $rect <510,139,710,179>
  slot OnSelect
  {
    var Clock::WeekButton selectedDay = (Clock::WeekButton)sender;
    SelectedDays[selectedDay.WeekDay]=true;
  }

  $rect <510,179,710,219>
  slot OnDeselect
  {
    var Clock::WeekButton selectedDay = (Clock::WeekButton)sender;
    SelectedDays[selectedDay.WeekDay]=false;
  }

  $rect <20,20,160,60>
  object Core::HorizontalList HorizontalList
  {
    preset Bounds = <0,0,418,59>;
    preset OnLoadItem = OnLoadItem;
    preset ItemWidth = 60;
    preset NoOfItems = 10;
    preset ItemClass = Clock::WeekButton;
  }

  // This method is called by 'HorizontalList' every time the list loads or updates \
  // an item.
  $rect <234,179,434,219>
  slot OnLoadItem
  {
    /*

      Hint:

      - The code below demonstrates a simple usage of the list component.

      - The list component creates and manages automatically view item instances of
        the class specified in its property 'ItemClass'. In this example it is the
        class 'Views::Image'.

      - When you change the 'ItemClass' property you will also need to replace
        accordingly all 'Views::Image' occurrences in the below code.

      - You will also need to adapt the initialization of the 'itemView'.

    */

    // Get the number of the item to load. The list component takes care of the
    // creation of the corresponding item view. Just access it ...
    var int32        itemNo   = HorizontalList.Item;
    var Clock::WeekButton itemView = (Clock::WeekButton)HorizontalList.View;

    // The implementation of this slot method does not match the item class
    // specified in the associated list component. Or the slot method is not
    // called in context of the OnLoadItem list operation. 
    if ( itemView == null )
      return;

    // Configure the item view ...
    itemView.WeekDay=itemNo;
    itemView.OnDeselected=OnDeselect;
    itemView.OnSelected=OnSelect;

    // Ensure that the item has correct size. The position of the item will be
    // managed by the list component.
    itemView.Bounds.size = point( HorizontalList.ItemWidth, HorizontalList.Bounds.h );
  }
}

// This class implements a 'push button' widget. When the user presses the button, \
// a signal is sent to the slot method stored in its @OnActivate property.
$rect <-120,557,80,597>
$output false
class WeekButton : Templates::PushButton
{
  $rect <480,310,680,350>
  inherited property Bounds = <0,0,60,60>;

  $rect <380,110,580,150>
  inherited onget Enabled
  {
    return pure Enabled;
  }

  $rect <380,70,580,110>
  inherited onset Enabled
  {
    if ( pure Enabled == value )
      return;

    pure Enabled = value;
  }

  $rect <380,30,580,70>
  inherited property Enabled = true;

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Bounds = <-2,0,60,59>;
    preset Color = #4D578428;
    preset Visible = true;
  }

  $rect <20,20,160,60>
  object Views::Bevel Bevel
  {
    preset Bounds = <0,0,60,59>;
    preset Width = 4;
    preset ColorL = #1D243828;
    preset ColorR = #1D243881;
    preset ColorB = #1D243881;
    preset ColorT = #1D243828;
  }

  $rect <20,20,160,60>
  object Views::Text Caption
  {
    preset Bounds = <5,0,53,59>;
    preset String = "Sun";
    preset Font = Clock::SmallFont;
    preset Color = #FAE9E0FF;
  }

  $rect <180,-10,380,30>
  property int32 WeekDay = 0;

  $rect <180,30,380,70>
  onset WeekDay
  {
    // The value doesn't change - nothing to do.
    if ( pure WeekDay == value )
      return;

    // Remember the property's new value.
    pure WeekDay = value;

    UpdateDay(value);

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <180,70,380,110>
  onget WeekDay
  {
    return pure WeekDay;
  }

  $rect <380,-10,580,30>
  method void UpdateDay( arg int32 value )
  {
    Caption.String=Clock::Time.getDayOfWeekName( value, true );

  }

  $rect <180,110,380,150>
  property slot OnSelected;

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler SimpleTouchHandler
  {
    preset Point4 = <4,0>;
    preset Point3 = <53,0>;
    preset Point2 = <53,59>;
    preset Point1 = <4,59>;
    preset OnPress = ChangeState;
  }

  $rect <580,-10,780,30>
  slot ChangeState
  {
    switch(!Active)
    {
      case true: 
      {
        Caption.Color=#8FFFF5FF;
        postsignal OnSelected;
      }
      case false:
      {
        Caption.Color=#FFFFFFFF;
        postsignal OnDeselected;
      }
      default:;
    }
    Active=!Active;
  }

  $rect <180,150,380,190>
  property slot OnDeselected;

  $rect <20,20,160,60>
  object Views::Line Line
  {
    preset Point2 = <59,59>;
    preset Point1 = <0,59>;
    preset Width = 3;
    preset Color = #FAE9E0FF;
  }

  $rect <580,110,780,150>
  onget Active
  {
    return pure Active;
  }

  $rect <580,70,780,110>
  onset Active
  {
    if ( pure Active == value )
      return;

    pure Active = value;
  }

  // The property 'Enabled' determines whether the component is able to react to \
  // user input events. Disabled components will never receive these events.
  // The @Enabled property is reflected in the current state of the component Core::ViewState.Enabled. \
  // This state can be evaluated in the implementation of the @UpdateViewState() \
  // method. For example, the method may show disabled components with pale colors, \
  // etc.
  // Please note, changing the enabled state of the component currently selected \
  // in the @Focus property will cause the framework to select other sibling view, \
  // which will be able to react to keyboard events.
  $rect <580,30,780,70>
  property bool Active = false;
}

$rect <440,630,629,670>
$output false
autoobject Core::Time Time;

// This class implements the item component for the Clock::ListBox widget. You will \
// probably never need to directly instantiate and control this item component.
$rect <90,659,290,699>
$output false
class WeekItem : Templates::ListItem
{
  $rect <680,10,880,50>
  inherited property Bounds = <0,0,315,40>;

  $rect <680,50,880,90>
  method void FillButtons( arg Core::Time time )
  {
    var Core::TimeSpan span=Clock::TimeSpan.Initialize2( 1, 0, 0, 0 );
    var int32 index;
    for(index=0;index<7;index++)
      { 
        Days[index]=time;
        time=time.Add(span);  
      }

    HorizontalList.InvalidateItems( 0, 6 );
                            
  }

  $rect <20,20,160,60>
  object Core::HorizontalList HorizontalList
  {
    preset Bounds = <0,0,315,40>;
    preset OnLoadItem = OnLoadItem;
    preset ItemWidth = 45;
    preset NoOfItems = 7;
    preset ItemClass = Clock::DayButton;
  }

  // This method is called by 'HorizontalList' every time the list loads or updates \
  // an item.
  $rect <880,10,1080,50>
  slot OnLoadItem
  {
    /*

      Hint:

      - The code below demonstrates a simple usage of the list component.

      - The list component creates and manages automatically view item instances of
        the class specified in its property 'ItemClass'. In this example it is the
        class 'Views::Image'.

      - When you change the 'ItemClass' property you will also need to replace
        accordingly all 'Views::Image' occurrences in the below code.

      - You will also need to adapt the initialization of the 'itemView'.

    */

    // Get the number of the item to load. The list component takes care of the
    // creation of the corresponding item view. Just access it ...
    var int32        itemNo   = HorizontalList.Item;
    var Clock::DayButton itemView = (Clock::DayButton)HorizontalList.View;

    // The implementation of this slot method does not match the item class
    // specified in the associated list component. Or the slot method is not
    // called in context of the OnLoadItem list operation. 
    if ( itemView == null )
      return;

    // Configure the item view ...
    itemView.Date=Days[itemNo];  
    itemView.OnSelected=ItemSelected;

    // Ensure that the item has correct size. The position of the item will be
    // managed by the list component.
    itemView.Bounds.size = point( HorizontalList.ItemWidth, HorizontalList.Bounds.h );
  }

  $rect <880,50,1080,90>
  array Core::Time Days[ 7 ] =
  (
    Default[0] = Clock::Time;
    Default[1] = Clock::Time;
    Default[2] = Clock::Time;
    Default[3] = Clock::Time;
    Default[4] = Clock::Time;
    Default[5] = Clock::Time;
    Default[6] = Clock::Time;
  );

  $rect <680,90,880,130>
  method Core::Time GetDate( arg int32 index )
  {
    return Days[index];
  }

  // The property 'Bounds' defines the position and the size of the view in the coordinates \
  // of the corresponding @Owner.
  $rect <1080,10,1280,50>
  property slot OnSelected = null;

  $rect <1080,50,1280,90>
  slot ItemSelected
  {
    var Clock::DayButton button=(Clock::DayButton)sender;
    Selected=button.Date;
    postsignal OnSelected;
  }

  $rect <1280,10,1480,50>
  property Core::Time Selected = null;
}

// This class implements a 'push button' widget. When the user presses the button, \
// a signal is sent to the slot method stored in its @OnActivate property.
$rect <-120,608,80,648>
$output false
class DayButton : Templates::PushButton
{
  $rect <480,310,680,350>
  inherited property Bounds = <0,0,45,40>;

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Bounds = <-2,0,43,40>;
    preset Color = #1D243828;
    preset Visible = false;
  }

  $rect <20,20,160,60>
  object Views::Text Caption
  {
    preset Bounds = <-2,0,43,40>;
    preset String = " ";
    preset Font = Clock::SmallFont;
    preset Color = #FAE9E0FF;
  }

  $rect <180,-10,380,30>
  property Core::Time Date = Clock::Time;

  $rect <180,30,380,70>
  onset Date
  {
    // The value doesn't change - nothing to do.
    if ( pure Date == value )
      return;

    // Remember the property's new value.
    pure Date = value;

    UpdateDay(value);

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <180,70,380,110>
  onget Date
  {
    return pure Date;
  }

  $rect <380,-10,580,30>
  method void UpdateDay( arg Core::Time time )
  {
    Caption.String=string(time.Day,2);
    var Core::Time current=Clock::Time.CurrentTime;

    if(Date.Month==Clock::CalendarTime.Month)
    {
      SimpleTouchHandler.Enabled=true;
      Rectangle.Visible=false;
      if(Date.Day==current.Day &&  Date.Month==current.Month && Date.Year==current.Year) Caption.Color=#67DCFFFF;
      else Caption.Color=#FAE9E0FF;
    }
    else
    {
      SimpleTouchHandler.Enabled=false;
      Rectangle.Visible=true;
      Caption.Color=#404D6344;
    }
  }

  $rect <180,110,380,150>
  property slot OnSelected;

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler SimpleTouchHandler
  {
    preset Point4 = <5,4>;
    preset Point3 = <33,4>;
    preset Point2 = <33,36>;
    preset Point1 = <5,36>;
    preset OnLeave = null;
    preset OnRelease = ChangeState;
    preset OnPress = ChangeState;
  }

  $rect <580,-10,780,30>
  slot ChangeState
  {
    if(!Active)
    {
      Rectangle.Visible=true;
      postsignal OnSelected;
    }
    else
    {
      Rectangle.Visible=false;
    }

    Active=!Active;

  }

  $rect <380,110,580,150>
  onget Active
  {
    return pure Active;
  }

  $rect <380,70,580,110>
  onset Active
  {
    if ( pure Active == value )
      return;

    pure Active = value;
  }

  // The property 'Enabled' determines whether the component is able to react to \
  // user input events. Disabled components will never receive these events.
  // The @Enabled property is reflected in the current state of the component Core::ViewState.Enabled. \
  // This state can be evaluated in the implementation of the @UpdateViewState() \
  // method. For example, the method may show disabled components with pale colors, \
  // etc.
  // Please note, changing the enabled state of the component currently selected \
  // in the @Focus property will cause the framework to select other sibling view, \
  // which will be able to react to keyboard events.
  $rect <380,30,580,70>
  property bool Active = false;

  $rect <20,20,160,60>
  object Views::Line Line
  {
    preset Point2 = <45,40>;
    preset Point1 = <-4,40>;
    preset Width = 3;
    preset Color = #FAE9E0FF;
  }

  $rect <20,20,160,60>
  object Views::Line Line1
  {
    preset Point2 = <45,0>;
    preset Point1 = <-4,0>;
    preset Width = 3;
  }
}

// This class implements the Clock::ListBox widget. This widget is intended to display \
// a list of options and permit the user to select the desired option. Selecting \
// the option sends a signal to the slot method stored in the property @OnSelect.
// Alternatively the property @Outlet can refer to any other 'int32' property the \
// widget should remain synchronized with. When the user selects an option, the affected \
// property is automatically updated to reflect the number of the selected option. \
// On the other hand, when the referred property is modified by another one, the \
// ListBox is automatically notified to remain in sync with the property.
// The total number of available ListBox items (the number of options) is determined \
// by the property @NoOfItems. Which option is actually selected is controlled by \
// the property @SelectedItem.
// The items are loaded dynamically at the runtime. For this purpose a slot method \
// has to be implemented and assigned to the @OnLoadItem property. The ListBox will \
// invoke the slot method automatically each time it needs an item to be loaded. \
// Within the slot method the implementation can access and initialize the affected \
// item by using the variable @View.
// In order to trigger the list to reload one or more items, invoke the method @InvalidateItems(). \
// The list box will thereupon schedule the necessary loading steps automatically.
$rect <89,608,289,648>
$output false
class MonthList : Templates::List
{
  $rect <980,-30,1180,10>
  inherited method Init()
  {
    Clock::CalendarTime.Time = Clock::Time.CurrentTime.Time;
    Clock::CalendarTime.Day=1;


    Month=Clock::CalendarTime.Month;
    Year=Clock::CalendarTime.Year;


  }

  $rect <779,20,979,60>
  inherited property Bounds = <0,0,311,361>;

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Bounds = <0,0,311,121>;
    preset Color = #0F1E3528;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle1
  {
    preset Bounds = <0,0,311,44>;
    preset Color = #0F1E3528;
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <-1,91,44,121>;
    preset String = "Su";
    preset Font = Clock::SmallFont;
    preset Color = #FAE9E0FF;
  }

  $rect <20,20,160,60>
  object Views::Text Text1
  {
    preset Bounds = <44,91,89,121>;
    preset String = "M";
    preset Font = Clock::SmallFont;
    preset Color = #FAE9E0FF;
  }

  $rect <20,20,160,60>
  object Views::Text Text2
  {
    preset Bounds = <89,91,134,121>;
    preset String = "Tu";
    preset Font = Clock::SmallFont;
    preset Color = #FAE9E0FF;
  }

  $rect <20,20,160,60>
  object Views::Text Text3
  {
    preset Bounds = <134,91,179,121>;
    preset String = "W";
    preset Font = Clock::SmallFont;
    preset Color = #FAE9E0FF;
  }

  $rect <20,20,160,60>
  object Views::Text Text4
  {
    preset Bounds = <179,91,224,121>;
    preset String = "Th";
    preset Font = Clock::SmallFont;
    preset Color = #FAE9E0FF;
  }

  $rect <20,20,160,60>
  object Views::Text Text5
  {
    preset Bounds = <224,91,269,121>;
    preset String = "F";
    preset Font = Clock::SmallFont;
    preset Color = #FAE9E0FF;
  }

  $rect <20,20,160,60>
  object Views::Text Text6
  {
    preset Bounds = <269,91,314,121>;
    preset String = "Sa";
    preset Font = Clock::SmallFont;
    preset Color = #FAE9E0FF;
  }

  $rect <20,20,160,60>
  object Views::Image Image
  {
    preset Bounds = <0,0,50,44>;
    preset Color = #FAE9E0FF;
    preset FrameNumber = 2;
    preset Bitmap = Resources::NavigationIconsMedium;
  }

  $rect <20,20,160,60>
  object Views::Image Image1
  {
    preset Bounds = <261,0,311,44>;
    preset Color = #FAE9E0FF;
    preset FrameNumber = 3;
    preset Bitmap = Resources::NavigationIconsMedium;
  }

  $rect <20,20,160,60>
  object Core::VerticalList VerticalList
  {
    preset Bounds = <-1,121,311,361>;
    preset OnLoadItem = OnLoadItem;
    preset Endless = false;
    preset SlideHandler = null;
    preset ScrollOffset = 0;
    preset ItemHeight = 40;
    preset NoOfItems = 6;
    preset ItemClass = Clock::WeekItem;
  }

  // This method is called by 'VerticalList1' every time the list loads or updates \
  // an item.
  $rect <779,-30,979,10>
  slot OnLoadItem
  {
    /*

      Hint:

      - The code below demonstrates a simple usage of the list component.

      - The list component creates and manages automatically view item instances of
        the class specified in its property 'ItemClass'. In this example it is the
        class 'Views::Text'.

      - When you change the 'ItemClass' property you will also need to replace
        accordingly all 'Views::Text' occurrences in the below code.

      - You will also need to adapt the initialization of the 'itemView'.

    */

    // Get the number of the item to load. The list component takes care of the
    // creation of the corresponding item view. Just access it ...
    var int32       itemNo   = VerticalList.Item;
    var Clock::WeekItem itemView = (Clock::WeekItem)VerticalList.View;

    // The implementation of this slot method does not match the item class
    // specified in the associated list component. Or the slot method is not
    // called in context of the OnLoadItem list operation. 
    if ( itemView == null )
      return;

    // Configure the item view ...                                                     
    itemView.FillButtons(FitToDayOfWeek(Clock::CalendarTime).Add( Clock::TimeSpan.Initialize2( 7*itemNo,0,0,0 )));
    itemView.OnSelected=ItemSelected;
    // Ensure that the item has correct size. The position of the item will be
    // managed by the list component.
    itemView.Bounds.size = point( VerticalList.Bounds.w, VerticalList.ItemHeight );
  }

  $rect <980,80,1180,120>
  method Core::Time FitToDayOfWeek( arg Core::Time time )
  {
    return time.Subtract( Clock::TimeSpan.Initialize2( time.DayOfWeek, 0, 0, 0 ) );
  }

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler Next
  {
    preset Point4 = <156,0>;
    preset Point3 = <312,0>;
    preset Point2 = <312,44>;
    preset Point1 = <156,44>;
    preset OnDrag = null;
    preset OnEnter = null;
    preset OnPress = OnNext;
    preset RetargetOffset = 8;
    preset RetargetCondition = Core::RetargetReason[];
  }

  $rect <790,250,990,290>
  slot OnNext
  {
    if(Month==12 && Year==9999) return;
    Month++;

    UpdateCalendarTime();

    VerticalList.InvalidateItems( 0, 5 );
  }

  $rect <1180,80,1380,120>
  property int32 Month;

  $rect <1180,120,1380,160>
  onset Month
  {
    // The value doesn't change - nothing to do.
    if ( pure Month == value )
      return;

    // Remember the property's new value.

    pure Month = value;
    if(Month>12) 
    {
      Month=1;
      Year++;
    }
    if(Month<1)
    {
      Month=12;
      Year--;
    }

    MonthList.ScrollOffset=-157*(Month-1);

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <1180,160,1380,200>
  onget Month
  {
    return pure Month;
  }

  $rect <1390,80,1590,120>
  property int32 Year;

  $rect <1390,120,1590,160>
  onset Year
  {
    // The value doesn't change - nothing to do.
    if ( pure Year == value )
      return;

    // Remember the property's new value.
    pure Year = value;

    YearList.ScrollOffset=-157*(Year-1970);

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <1390,160,1590,200>
  onget Year
  {
    return pure Year;
  }

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler Prev
  {
    preset Point4 = <0,0>;
    preset Point3 = <156,0>;
    preset Point2 = <156,44>;
    preset Point1 = <0,44>;
    preset OnDrag = null;
    preset OnHold = null;
    preset OnPress = OnPrev;
    preset RetargetDelay = 1000;
    preset RetargetOffset = 8;
    preset RetargetCondition = Core::RetargetReason[WipeRight];
  }

  $rect <790,290,990,330>
  slot OnPrev
  {
    if(Month==1 && Year==1970) return;
    Month--;

    UpdateCalendarTime();

    VerticalList.InvalidateItems( 0, 5 );
  }

  // The property 'Bounds' defines the position and the size of the view in the coordinates \
  // of the corresponding @Owner.
  $rect <1180,-30,1380,10>
  property slot OnSelected = null;

  $rect <1180,10,1380,50>
  slot ItemSelected
  {
    var Clock::WeekItem item =(Clock::WeekItem)sender;
    Selected=item.Selected;
    postsignal OnSelected;
  }

  $rect <1380,-30,1580,10>
  property Core::Time Selected = null;

  $rect <20,20,160,60>
  object Core::HorizontalList YearList
  {
    preset Bounds = <-2,44,155,91>;
    preset OnLoadItem = OnLoadYearItem;
    preset SlideHandler = YearSlideHandler;
    preset ItemWidth = 157;
    preset NoOfItems = 10000;
    preset ItemClass = Views::Text;
  }

  // This method is called by 'HorizontalList' every time the list loads or updates \
  // an item.
  $rect <480,250,680,290>
  slot OnLoadYearItem
  {
    /*

      Hint:

      - The code below demonstrates a simple usage of the list component.

      - The list component creates and manages automatically view item instances of
        the class specified in its property 'ItemClass'. In this example it is the
        class 'Views::Image'.

      - When you change the 'ItemClass' property you will also need to replace
        accordingly all 'Views::Image' occurrences in the below code.

      - You will also need to adapt the initialization of the 'itemView'.

    */

    // Get the number of the item to load. The list component takes care of the
    // creation of the corresponding item view. Just access it ...
    var int32        itemNo   = YearList.Item;
    var Views::Text itemView = (Views::Text)YearList.View;

    // The implementation of this slot method does not match the item class
    // specified in the associated list component. Or the slot method is not
    // called in context of the OnLoadItem list operation. 
    if ( itemView == null )
      return;

    itemView.String=string(1970+itemNo);
    itemView.Color=#FAE9E0FF;
    itemView.Font=Clock::SmallFont;

    // Ensure that the item has correct size. The position of the item will be
    // managed by the list component.
    itemView.Bounds.size = point( YearList.ItemWidth, YearList.Bounds.h );
  }

  $rect <20,20,160,60>
  object Core::HorizontalList MonthList
  {
    preset Bounds = <155,44,310,91>;
    preset OnLoadItem = OnLoadMonthItem;
    preset Endless = true;
    preset SlideHandler = MonthSlideHandler;
    preset ItemWidth = 157;
    preset NoOfItems = 12;
    preset ItemClass = Views::Text;
  }

  // This method is called by 'HorizontalList' every time the list loads or updates \
  // an item.
  $rect <480,290,680,330>
  slot OnLoadMonthItem
  {
    /*

      Hint:

      - The code below demonstrates a simple usage of the list component.

      - The list component creates and manages automatically view item instances of
        the class specified in its property 'ItemClass'. In this example it is the
        class 'Views::Image'.

      - When you change the 'ItemClass' property you will also need to replace
        accordingly all 'Views::Image' occurrences in the below code.

      - You will also need to adapt the initialization of the 'itemView'.

    */

    // Get the number of the item to load. The list component takes care of the
    // creation of the corresponding item view. Just access it ...
    var int32        itemNo   = MonthList.Item;
    var Views::Text itemView = (Views::Text)MonthList.View;


    if ( itemView == null )
      return;

    itemView.String=Clock::Time.getMonthName(itemNo+1,true);
    itemView.Color=#FAE9E0FF;
    itemView.Font=Clock::SmallFont;

    // Ensure that the item has correct size. The position of the item will be
    // managed by the list component.
    itemView.Bounds.size = point( YearList.ItemWidth, YearList.Bounds.h );
  }

  $rect <20,20,160,60>
  object Core::SlideTouchHandler YearSlideHandler
  {
    preset Bounds = <1,44,156,91>;
    preset MinOffset = <157,0>;
    preset OnEnd = OnGetYearMonthItem;
    preset SnapNext = <157,0>;
  }

  $rect <20,20,160,60>
  object Core::SlideTouchHandler MonthSlideHandler
  {
    preset Bounds = <156,44,311,91>;
    preset MinOffset = <157,0>;
    preset OnEnd = OnGetYearMonthItem;
    preset SnapNext = <157,0>;
  }

  $rect <480,330,680,370>
  slot OnGetYearMonthItem
  {
    Year = 1970+YearList.GetItemAtPosition( <76,67> );
    Month = MonthList.GetItemAtPosition( <233,67> ) + 1;

    UpdateCalendarTime();

    VerticalList.InvalidateItems( 0, 5 );
  }

  $rect <20,20,160,60>
  object Views::Bevel Bevel
  {
    preset Bounds = <155,0,311,44>;
    preset Width = 2;
    preset ColorL = #FFFFFF3A;
    preset ColorR = #FFFFFF72;
    preset ColorB = #FFFFFF72;
    preset ColorT = #FFFFFF3A;
  }

  $rect <20,20,160,60>
  object Views::Bevel Bevel1
  {
    preset Bounds = <0,0,155,44>;
    preset Width = 2;
    preset ColorL = #FFFFFF3A;
    preset ColorR = #FFFFFF72;
    preset ColorB = #FFFFFF72;
    preset ColorT = #FFFFFF3A;
  }

  $rect <980,119,1180,159>
  method void UpdateCalendarTime()
  {
    Clock::CalendarTime.Month=Month;
    Clock::CalendarTime.Year=Year;
  }
}

$rect <440,670,630,710>
$output false
autoobject Core::TimeSpan TimeSpan;

$rect <440,710,629,750>
$output false
autoobject Core::Time CalendarTime;

// Screens
note group Note
{
  attr Bounds = <59,30,299,400>;
}

$rect <-120,659,80,699>
$output false
class EventItemComponent : Core::Group
{
  $rect <10,200,210,240>
  inherited property Bounds = rect(0,0,$ScreenSize.x,100);

  $rect <10,160,210,200>
  inherited property Visible = true;

  $rect <210,120,410,160>
  property Resources::Bitmap Icon;

  $rect <210,160,410,200>
  onset Icon
  {
    // The value doesn't change - nothing to do.
    if ( pure Icon == value )
      return;

    // Remember the property's new value.
    pure Icon = value;

    Image.Bitmap=value;
    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <210,200,410,240>
  onget Icon
  {
    return pure Icon;
  }

  $rect <410,120,610,160>
  property string Caption;

  $rect <410,160,610,200>
  onset Caption
  {
    // The value doesn't change - nothing to do.
    if ( pure Caption == value )
      return;

    // Remember the property's new value.
    pure Caption = value;

    Text.String=value
    ;
    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <410,200,610,240>
  onget Caption
  {
    return pure Caption;
  }

  $rect <610,120,810,160>
  property int64 TriggerTime;

  $rect <610,160,810,200>
  onset TriggerTime
  {
    // The value doesn't change - nothing to do.
    if ( pure TriggerTime == value )
      return;

    // Remember the property's new value.
    pure TriggerTime = value;

    Text1.String=Clock::Time.Initialize( TriggerTime ).String;
    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <610,200,810,240>
  onget TriggerTime
  {
    return pure TriggerTime;
  }

  $rect <20,20,160,60>
  object Core::Outline Outline
  {
    preset Bounds = <0,0,640,100>;
    preset SlideHandler = SlideTouchHandler;
    preset ScrollOffset = <0,0>;
    preset Formation = Core::Formation.None;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle1
  {
    preset Bounds = <0,0,502,100>;
    preset ColorBR = #FFFFFF00;
    preset ColorTR = #FFFFFF00;
    preset Color = #2760807B;
    preset Embedded = true;
  }

  $rect <20,20,160,60>
  object Views::Image Image
  {
    preset Bounds = <0,0,100,100>;
    preset Color = #FAE9E0FF;
    preset Bitmap = Resources::DefaultBitmap;
    preset Embedded = true;
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <100,0,640,50>;
    preset String = "Caption";
    preset Font = Clock::SmallFont;
    preset Color = #FAE9E0FF;
    preset Embedded = true;
  }

  $rect <20,20,160,60>
  object Views::Text Text1
  {
    preset Bounds = <100,50,640,100>;
    preset Alignment = Views::TextAlignment[AlignHorzAuto, AlignHorzCenter, AlignVertCenter];
    preset String = "Caption";
    preset Font = Clock::SmallFont;
    preset Color = #FAE9E0FF;
    preset Embedded = true;
  }

  $rect <810,120,1010,160>
  property int32 ImageFrame;

  $rect <810,160,1010,200>
  onset ImageFrame
  {
    // The value doesn't change - nothing to do.
    if ( pure ImageFrame == value )
      return;

    // Remember the property's new value.
    pure ImageFrame = value;

    Image.FrameNumber=ImageFrame;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <810,200,1010,240>
  onget ImageFrame
  {
    return pure ImageFrame;
  }

  $rect <210,250,410,290>
  property int32 Index;

  $rect <210,290,410,330>
  onset Index
  {
    // The value doesn't change - nothing to do.
    if ( pure Index == value )
      return;

    // Remember the property's new value.
    pure Index = value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <210,330,410,370>
  onget Index
  {
    return pure Index;
  }

  $rect <20,20,160,60>
  object Clock::SlideTouchHandler SlideTouchHandler
  {
    preset Bounds = <0,0,640,100>;
    preset MaxOffset = <0,0>;
    preset MinOffset = <0,0>;
    preset Offset = <0,0>;
    preset OnSlide = OnSlide;
    preset OnEnd = OnEndSlider;
    preset OnStart = null;
    preset SlideVert = false;
    preset RubberBandScrolling = true;
  }

  $rect <1010,160,1210,200>
  slot OnEndSlider
  {
    if(SlideTouchHandler.Offset.x>SlideTouchHandler.Bounds.w/2)
      {
        Clock::Device.RemoveEvent( Index );
      }  
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Bounds = <0,0,0,100>;
    preset Color = #4FA8C300;
  }

  $rect <1010,119,1210,159>
  slot OnSlide
  {
    Rectangle.Bounds.w=SlideTouchHandler.Offset.x;
    Image1.Bounds.w=SlideTouchHandler.Offset.x;
    var int32 value=(SlideTouchHandler.Offset.x<=0)?0:SlideTouchHandler.Offset.x*255/(SlideTouchHandler.Bounds.w/2);
    Rectangle.Color.alpha=uint8(value>255?255:value);
    Image1.Opacity=uint8(value>255?255:value);


  }

  $rect <20,20,160,60>
  object Views::Image Image1
  {
    preset Bounds = <0,0,0,100>;
    preset Color = #FAE9E0FF;
    preset Alignment = Views::ImageAlignment[AlignHorzLeft, AlignVertCenter];
    preset FrameNumber = 4;
    preset Bitmap = Resources::SymbolIconsExtraLarge;
    preset Opacity = 0;
  }

  $rect <419,250,619,290>
  method void Reset()
  {
    SlideTouchHandler.Offset=<0,0>;
    Outline.ScrollOffset=<0,0>;
    Image1.Opacity=0;
    Image1.Bounds.w=0;
    Rectangle.Color=#A35C6E00;
    Rectangle.Bounds.w=0;
  }
}

// Widgets
note group Note1
{
  attr Bounds = <-130,419,300,820>;
}

$rect <80,350,280,390>
$output false
class RunningEvents : Core::Group
{
  $rect <-259,620,-59,660>
  inherited property Bounds = <0,0,640,522>;

  $rect <-59,619,141,659>
  slot WipeUpSlot
  {
    var Clock::Base owner=(Clock::Base) Owner;
    owner.SlideUp.Enabled=true;
    owner.PresentDialog(new Clock::ClockScreen, Effects::SlideUpCentered, null, null, null, null, null, null, null, false );

  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Bounds = <0,0,640,480>;
    preset Color = #1D243858;
    preset Visible = true;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle1
  {
    preset Bounds = <0,439,640,480>;
    preset ColorBL = #0F1E35FF;
    preset ColorBR = #0F1E35FF;
    preset ColorTR = #0F1E3553;
    preset ColorTL = #0F1E3553;
  }

  $rect <20,20,160,60>
  object Views::Image Image
  {
    preset Bounds = <295,430,345,480>;
    preset Color = #ecdfcfFF;
    preset Bitmap = Resources::NavigationIconsMedium;
    preset Visible = true;
  }

  $rect <20,20,160,60>
  object Core::WipeTouchHandler WipeUp
  {
    preset Bounds = <0,430,640,479>;
    preset OnTop = WipeUpSlot;
    preset Enabled = true;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle2
  {
    preset Bounds = <0,480,640,521>;
    preset ColorBL = #FFFFFFFF;
    preset ColorBR = #FFFFFFFF;
    preset ColorTR = #FFFFFFFF;
    preset ColorTL = #FFFFFFFF;
    preset Color = #0F1E35FF;
  }

  $rect <20,20,160,60>
  object Core::HorizontalList HorizontalList
  {
    preset Bounds = <0,480,640,522>;
    preset OnLoadItem = OnLoadHorizontalList;
    preset ItemWidth = 60;
    preset NoOfItems = 0;
    preset ItemClass = Views::Image;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle3
  {
    preset Bounds = <0,480,480,522>;
    preset ColorBL = #FFFFFF00;
    preset ColorBR = #FFFFFFFF;
    preset ColorTR = #FFFFFFFF;
    preset ColorTL = #FFFFFF00;
    preset Color = #0F1E35FF;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle4
  {
    preset Bounds = <480,480,640,522>;
    preset ColorBL = #FFFFFFFF;
    preset ColorBR = #FFFFFFFF;
    preset ColorTR = #FFFFFFFF;
    preset ColorTL = #FFFFFFFF;
    preset Color = #0F1E35FF;
  }

  // This method is called by 'HorizontalList' every time the list loads or updates \
  // an item.
  $rect <160,619,360,659>
  slot OnLoadHorizontalList
  {
    /*

      Hint:

      - The code below demonstrates a simple usage of the list component.

      - The list component creates and manages automatically view item instances of
        the class specified in its property 'ItemClass'. In this example it is the
        class 'Views::Image'.

      - When you change the 'ItemClass' property you will also need to replace
        accordingly all 'Views::Image' occurrences in the below code.

      - You will also need to adapt the initialization of the 'itemView'.

    */

    // Get the number of the item to load. The list component takes care of the
    // creation of the corresponding item view. Just access it ...
    var int32        itemNo   = HorizontalList.Item;
    var Views::Image itemView = (Views::Image)HorizontalList.View;

    // The implementation of this slot method does not match the item class
    // specified in the associated list component. Or the slot method is not
    // called in context of the OnLoadItem list operation. 
    if ( itemView == null )
      return;

    var Clock::Event event= Clock::Device.GetEvent( itemNo );

    itemView.Bitmap=Clock::IconsSmall;
    switch(event.Type)
    {
      case Clock::EventType.Alarm:
        itemView.FrameNumber=2;
      case Clock::EventType.Calendar:
        itemView.FrameNumber=3;
      default:;
    }



    // Ensure that the item has correct size. The position of the item will be
    // managed by the list component.
    itemView.Bounds.size = point( HorizontalList.ItemWidth, HorizontalList.Bounds.h );
  }

  $rect <20,20,160,60>
  object Core::VerticalList VerticalList
  {
    preset Bounds = <0,0,640,430>;
    preset OnLoadItem = OnLoadVerticalList;
    preset SlideHandler = SlideTouchHandler;
    preset ItemHeight = 110;
    preset NoOfItems = 0;
    preset ItemClass = Clock::EventItemComponent;
  }

  $rect <20,20,160,60>
  object Core::SlideTouchHandler SlideTouchHandler
  {
    preset Bounds = <0,0,640,430>;
    preset SlideHorz = false;
    preset RetargetCondition = Core::RetargetReason[WipeRight];
    preset Enabled = true;
  }

  // This method is called by 'VerticalList' every time the list loads or updates \
  // an item.
  $rect <160,659,360,699>
  slot OnLoadVerticalList
  {
    /*

      Hint:

      - The code below demonstrates a simple usage of the list component.

      - The list component creates and manages automatically view item instances of
        the class specified in its property 'ItemClass'. In this example it is the
        class 'Views::Text'.

      - When you change the 'ItemClass' property you will also need to replace
        accordingly all 'Views::Text' occurrences in the below code.

      - You will also need to adapt the initialization of the 'itemView'.

    */

    // Get the number of the item to load. The list component takes care of the
    // creation of the corresponding item view. Just access it ...
    var int32       itemNo   = VerticalList.Item;
    var Clock::EventItemComponent itemView = (Clock::EventItemComponent)VerticalList.View;

    // The implementation of this slot method does not match the item class
    // specified in the associated list component. Or the slot method is not
    // called in context of the OnLoadItem list operation. 
    if ( itemView == null )
      return;

    // Configure the item view ...

    var Clock::Event event= Clock::Device.GetEvent( itemNo );
    itemView.Reset();
    itemView.Icon=Clock::IconsLarge;
    itemView.TriggerTime=event.TriggerTime+event.Snooze;
    itemView.Index=itemNo;
    switch(event.Type)
    {
    case Clock::EventType.Alarm:
    {
      itemView.Caption="Alarm Event";
      if(event.IsScheduled) itemView.Caption+=" [Scheduled]";
      itemView.ImageFrame=2;
    }
    case Clock::EventType.Calendar:
    {
      itemView.Caption="Calendar Event";
      itemView.ImageFrame=3;
    }
    default:;
    }

    if(event.Snooze>0) itemView.Caption+="[Reminder]";

    // Ensure that the item has correct size. The position of the item will be
    // managed by the list component.
    itemView.Bounds.size = point( VerticalList.Bounds.w, VerticalList.ItemHeight );
  }

  $rect <450,610,650,650>
  object Core::SystemEventHandler SystemEventHandler
  {
    preset OnEvent = onEvent;
    preset Event = Clock::Device.EventChanged;
  }

  // This slot method is executed when the associated system event handler 'SystemEventHandler' \
  // receives an event.
  $rect <650,610,850,650>
  slot onEvent
  {
    var int32 eventNo=Clock::Device.GetEventsCount();
    VerticalList.NoOfItems=eventNo;
    HorizontalList.NoOfItems=eventNo;

    VerticalList.InvalidateItems( 0, VerticalList.NoOfItems );
    HorizontalList.InvalidateItems( 0, HorizontalList.NoOfItems );

  }

  $rect <20,20,160,60>
  object Views::Border Border
  {
    preset Bounds = <0,439,640,479>;
    preset Color = #0F1E358C;
  }

  $reorder UpdateViewState 1
  $reorder InvalidateLayout 1
  $reorder InvalidateViewState 1
  $reorder InvalidateArea 1
  $reorder GetIndexOfView 1
  $reorder GetViewAtIndex 1
  $reorder CountViews 1
  $reorder FindViewInDirection 1
  $reorder FindViewWithinArea 1
  $reorder FindViewAtPosition 1
  $reorder FindPrevView 1
  $reorder FindNextView 1
  $reorder FindSiblingView 1
  $reorder GetContentArea 1
  $reorder FadeGroup 1
  $reorder RestackBehind 1
  $reorder RestackBack 1
  $reorder RestackTop 1
  $reorder Restack 1
  $reorder RemoveAll 1
  $reorder Remove 1
  $reorder AddBehind 1
  $reorder Add 1
  $reorder Focus 1
  $reorder Buffered 1
  $reorder Enabled 1
  $reorder Opacity 1
  $reorder Embedded 1
  $reorder AlphaBlended 1
  $reorder Visible 1
  $reorder WipeUpSlot 1
  $reorder Rectangle 1
  $reorder Rectangle1 1
  $reorder Image 1
  $reorder WipeUp 1
}

$rect <690,150,890,190>
$output false
resource Resources::Bitmap IconsLarge
{
  attr bitmapfile FileName = .\Resources\IconsLarge.png;
  attr bitmapdithering Dithering = Auto;
  attr framesize FrameSize = <100,100>;
  attr framedelay FrameDelay;
  attr bitmapformat Format = Alpha8;
  attr bitmapmode Mode = Default;
}

$rect <690,190,890,230>
$output false
resource Resources::Bitmap IconsSmall
{
  attr bitmapfile FileName = .\Resources\IconsSmall.png;
  attr bitmapdithering Dithering = Auto;
  attr framesize FrameSize = <40,40>;
  attr framedelay FrameDelay;
  attr bitmapformat Format = Alpha8;
  attr bitmapmode Mode = Default;
}

$rect <690,380,890,420>
$output false
class Event
{
  $rect <180,70,380,110>
  property int64 TriggerTime;

  $rect <180,110,380,150>
  onset TriggerTime
  {
    // The value doesn't change - nothing to do.
    if ( pure TriggerTime == value )
      return;

    // Remember the property's new value.
    pure TriggerTime = value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <180,150,380,190>
  onget TriggerTime
  {
    return pure TriggerTime;
  }

  $rect <380,70,580,110>
  array bool ScheduledDays[ 7 ] =
  (
    Default[0] = false;
    Default[1] = false;
    Default[2] = false;
    Default[3] = false;
    Default[4] = false;
    Default[5] = false;
    Default[6] = false;
  );

  $rect <580,70,780,110>
  property Clock::EventType Type;

  $rect <580,110,780,150>
  onset Type
  {
    // The value doesn't change - nothing to do.
    if ( pure Type == value )
      return;

    // Remember the property's new value.
    pure Type = value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <580,150,780,190>
  onget Type
  {
    return pure Type;
  }

  $rect <180,210,380,250>
  method bool IsTriggered( arg int64 currentTime )
  {
    if(TriggerTime + Snooze==currentTime) return true;
    return false;
  }

  $rect <180,250,380,290>
  method bool IsExpired( arg int64 currentTime )
  {
    if(TriggerTime + Snooze<=currentTime) return !IsScheduled;
    return false;
  }

  $rect <780,70,980,110>
  property int64 Snooze = 0;

  $rect <780,110,980,150>
  onset Snooze
  {
    // The value doesn't change - nothing to do.
    if ( pure Snooze == value )
      return;

    if(value > 10)
      return;

    // Remember the property's new value.
    pure Snooze = value;

    Clock::Device.EventChanged.Trigger( null, null );
    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <780,150,980,190>
  onget Snooze
  {
    return pure Snooze;
  }

  $rect <580,200,780,240>
  property bool IsScheduled;

  $rect <580,240,780,280>
  onset IsScheduled
  {
    // The value doesn't change - nothing to do.
    if ( pure IsScheduled == value )
      return;

    // Remember the property's new value.
    pure IsScheduled = value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <580,280,780,320>
  onget IsScheduled
  {
    return pure IsScheduled;
  }
}

$rect <690,420,890,460>
$output false
enum EventType
{
  $rect <10,10,210,50>
  item Alarm;

  $rect <220,10,420,50>
  item Calendar;
}

$rect <490,420,690,460>
vclass DeviceSimulation : Clock::DeviceClass
{
  $rect <20,20,210,60>
  inherited method GetEventsCount()
  {
    var int32 result=0;
    while(Events[result]!=null)
     result++;

    return result;
  }

  $rect <20,140,220,180>
  inherited method GetEvent()
  {
    return Events[index];
  }

  $rect <20,100,220,140>
  inherited method AddEvent()
  {
    var int32 eventNo=GetEventsCount();
    if(eventNo>=Events.size)
      return false;

    for(;eventNo>0;eventNo--)
      Events[eventNo]=Events[eventNo-1];
    Events[0]=event;

    EventChanged.Trigger( null, null );
    return true;


  }

  $rect <20,60,220,100>
  inherited method RemoveEvent()
  {
    if(index<0 || index>GetEventsCount()-1) return false;
    var int32 eventNo=GetEventsCount();

    for(;index<eventNo;index++)
      {
      Events[index]=(index==Events.size-1)?null:Events[index+1];
      }

    EventChanged.Trigger( null, null );
    return true;
  }

  $rect <240,20,440,60>
  array Clock::Event Events[ 32 ];

  $reorder GetEventsCount 1
  $reorder GetEvent 1
  $reorder AddEvent 1
  $reorder RemoveEvent 1
}

// Device
note group Note2
{
  attr Bounds = <480,300,900,500>;
}

// This component implements a generic alert.
$rect <-119,710,81,750>
$output false
class Alert : Templates::Panel
{
  $rect <490,230,690,270>
  inherited method Init()
  {
    Int32Effect.Enabled=true;
  }

  $rect <490,190,690,230>
  inherited property Bounds = <0,0,465,177>;

  $rect <690,130,890,170>
  onset OnButton1
  {
    // The value doesn't change - nothing to do.
    if ( pure OnButton1 == value )
      return;

    // Remember the property's new value.
    pure OnButton1 = value;

  }

  $rect <690,40,890,80>
  onset Button1Label
  {
    // The value doesn't change - nothing to do.
    if ( pure Button1Label == value )
      return;

    // Remember the property's new value.
    pure Button1Label = value;

    // ... and update the text displayed in the alert
    PushButton1.Label = value;

    // Changing the label can also affect the width of the alert itself.
    // Therefore trigger the routine to recalculate the alert size
    postsignal autoResize;
  }

  $rect <490,130,690,170>
  onset Message
  {
    // The value doesn't change - nothing to do.
    if ( pure Message == value )
      return;

    // Remember the property's new value.
    pure Message = value;

    // ... and update the text displayed in the alert
    MessageText.String = value;

  }

  $rect <490,40,690,80>
  onset Caption
  {
    // The value doesn't change - nothing to do.
    if ( pure Caption == value )
      return;

    // Remember the property's new value.
    pure Caption = value;

    // ... and update the text displayed in the alert
    CaptionText.String = value;

  }

  $rect <20,20,160,60>
  object Views::Rectangle Background
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,0,465,177>;
    preset ColorBL = #FFFFFFD7;
    preset ColorBR = #FFFFFFD7;
    preset ColorTR = #FFFFFF7B;
    preset ColorTL = #FFFFFF7B;
    preset Color = #4FA8C3FF;
  }

  $rect <20,20,160,60>
  object Views::Border Border
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,0,465,177>;
    preset Width = 3;
    preset Color = #276080FF;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Bounds = <0,2,465,80>;
    preset Color = #276080FF;
  }

  $rect <20,20,160,60>
  object Views::Text MessageText
  {
    preset Bounds = <0,80,465,130>;
    preset WrapText = true;
    preset Alignment = Views::TextAlignment[AlignHorzAuto, AlignHorzCenter, AlignVertCenter];
    preset String = "Message";
    preset Font = Resources::FontMedium;
    preset Color = #FAE9E0FF;
  }

  $rect <20,20,160,60>
  object Views::Text CaptionText
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToRight, AlignToTop, ResizeHorz];
    preset Bounds = <74,16,450,66>;
    preset String = "Caption";
    preset Font = Resources::FontLarge;
    preset Color = #FAE9E0FF;
  }

  // The property 'OnButton1' can store a slot method to signal when the user activates \
  // the first push button.
  $rect <690,90,890,130>
  property slot OnButton1 = null;

  // The property 'Button1Label' stores the text to display in the first push button.
  $rect <690,0,890,40>
  property string Button1Label = "Ok";

  // The property 'Message' stores the text to display in the message area of the \
  // alert.
  $rect <490,90,690,130>
  property string Message = "Caption";

  // The property 'Caption' stores the text to display in the header of the alert. 
  $rect <490,0,690,40>
  property string Caption = "Caption";

  $rect <1090,40,1290,80>
  onset Icon
  {
    // The value doesn't change - nothing to do.
    if ( pure Icon == value )
      return;

    // Remember the property's new value.
    pure Icon = value;

    // ... and update the text displayed in the alert
    Image.Bitmap = value;

  }

  // The property 'Caption' stores the text to display in the header of the alert. 
  $rect <1090,0,1290,40>
  property Resources::Bitmap Icon = Resources::DefaultBitmap;

  $rect <20,20,160,60>
  object Views::Image Image
  {
    preset Bounds = <14,11,74,71>;
    preset Color = #FAE9E0FF;
    preset Bitmap = Resources::DefaultBitmap;
  }

  $rect <1090,90,1290,130>
  object Effects::Int32Effect Int32Effect
  {
    preset OnFinished = OnFinished;
    preset OnAnimate = OnAnimate;
    preset NoOfCycles = 1;
    preset CycleDuration = 300000;
    preset InitialDelay = 0;
    preset Enabled = true;
    preset Value2 = 300;
  }

  $rect <1090,130,1290,170>
  slot OnFinished
  {
    postsignal OnIgnored;
  }

  $rect <1090,170,1290,210>
  slot OnAnimate
  {
    Message="-"+string(Int32Effect.Value/3600,2)+":"+string(Int32Effect.Value/60,2)+":"+string(Int32Effect.Value%60,2);
  }

  $rect <690,170,890,210>
  slot OnButton1Press
  {
    postsignal OnButton1;
  }

  $rect <1290,130,1490,170>
  onset OnIgnored
  {
    // The value doesn't change - nothing to do.
    if ( pure OnIgnored == value )
      return;

    // Remember the property's new value.
    pure OnIgnored = value;

  }

  // The property 'OnButton1' can store a slot method to signal when the user activates \
  // the first push button.
  $rect <1290,90,1490,130>
  property slot OnIgnored = null;

  $rect <690,220,890,260>
  property int32 Index;

  $rect <690,260,890,300>
  onset Index
  {
    // The value doesn't change - nothing to do.
    if ( pure Index == value )
      return;

    // Remember the property's new value.
    pure Index = value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <690,300,890,340>
  onget Index
  {
    return pure Index;
  }

  $rect <1290,0,1490,40>
  property int32 IconFrame;

  $rect <1290,40,1490,80>
  onset IconFrame
  {
    // The value doesn't change - nothing to do.
    if ( pure IconFrame == value )
      return;

    // Remember the property's new value.
    pure IconFrame = value;
    Image.FrameNumber=value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <20,20,160,60>
  object Clock::DefaultButton PushButton1
  {
    preset Bounds = <90,130,223,166>;
    preset OnPress = OnButton1Press;
    preset IconColor = #FAE9E0FF;
    preset Color = #276080FF;
    preset LabelColor = #FAE9E0FF;
    preset Label = "OK";
    preset Font = Resources::FontMedium;
  }

  $rect <20,20,160,60>
  object Clock::DefaultButton PushButton2
  {
    preset Bounds = <242,130,375,166>;
    preset OnPress = OnButton2Press;
    preset IconColor = #FAE9E0FF;
    preset Color = #276080FF;
    preset LabelColor = #FAE9E0FF;
    preset Label = "Snooze";
    preset Font = Resources::FontMedium;
  }

  $rect <890,130,1090,170>
  onset OnButton2
  {
    // The value doesn't change - nothing to do.
    if ( pure OnButton2 == value )
      return;

    // Remember the property's new value.
    pure OnButton2 = value;

  }

  $rect <890,40,1090,80>
  onset Button2Label
  {
    // The value doesn't change - nothing to do.
    if ( pure Button2Label == value )
      return;

    // Remember the property's new value.
    pure Button2Label = value;

    // ... and update the text displayed in the alert
    PushButton1.Label = value;

    // Changing the label can also affect the width of the alert itself.
    // Therefore trigger the routine to recalculate the alert size
    postsignal autoResize;
  }

  // The property 'OnButton1' can store a slot method to signal when the user activates \
  // the first push button.
  $rect <890,90,1090,130>
  property slot OnButton2 = null;

  // The property 'Button1Label' stores the text to display in the first push button.
  $rect <890,0,1090,40>
  property string Button2Label = "Snooze";

  $rect <890,170,1090,210>
  slot OnButton2Press
  {
    postsignal OnButton2;
  }

  $rect <900,220,1100,260>
  property Clock::Event Sender;

  $rect <900,260,1100,300>
  onset Sender
  {
    // The value doesn't change - nothing to do.
    if ( pure Sender == value )
      return;

    // Remember the property's new value.
    pure Sender = value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <900,300,1100,340>
  onget Sender
  {
    return pure Sender;
  }
}

$rect <690,230,890,270>
$output false
resource Resources::Bitmap IconsMedium
{
  attr bitmapfile FileName = .\Resources\IconsMedium.png;
  attr bitmapdithering Dithering = Auto;
  attr framesize FrameSize = <60,60>;
  attr framedelay FrameDelay;
  attr bitmapformat Format = Alpha8;
  attr bitmapmode Mode = Default;
}

// This class implements a 'push button' widget. When the user presses the button, \
// a signal is sent to the slot method stored in its @OnActivate property.
$rect <-119,759,81,799>
$output false
class FunctionalitiesButton : Templates::PushButton
{
  $rect <480,310,680,350>
  inherited property Bounds = <0,0,100,100>;

  // Touch screen events
  note group Note1
  {
    attr Bounds = <10,150,230,290>;
  }

  // This internal slot method is called when the user releases the touch screen \
  // after touching the button's area. This activates the button.
  $rect <20,230,220,270>
  slot onReleaseTouch
  {
    postsignal OnRelease;
    FillPath2.Visible=false;
  }

  // This internal slot method is called when the user touches the button's area.
  $rect <20,190,220,230>
  slot onPressTouch
  {
    postsignal OnPress;
    FillPath2.Visible=true;
  }

  // The property 'OnActivate' can refer to a slot method, which will receive a signal \
  // as soon as the user has activated the button. Thereupon the method's logic will \
  // be executed.
  $rect <450,130,650,170>
  property slot OnPress = null;

  $rect <450,10,650,50>
  property int32 FrameNumber = 0;

  $rect <450,50,650,90>
  onset FrameNumber
  {
    // The value doesn't change - nothing to do.
    if ( pure FrameNumber == value )
      return;

    // Remember the property's new value.
    pure FrameNumber = value;

    Image.FrameNumber=value;
    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <650,10,850,50>
  property Resources::Bitmap Bitmap = Resources::DefaultBitmap;

  $rect <650,50,850,90>
  onset Bitmap
  {
    // The value doesn't change - nothing to do.
    if ( pure Bitmap == value )
      return;

    // Remember the property's new value.
    pure Bitmap = value;

    Image.Bitmap=value;
    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  // The property 'OnActivate' can refer to a slot method, which will receive a signal \
  // as soon as the user has activated the button. Thereupon the method's logic will \
  // be executed.
  $rect <250,130,450,170>
  property slot OnRelease = null;

  $rect <250,10,450,50>
  property color IconColor = #FFFFFFFF;

  $rect <250,50,450,90>
  onset IconColor
  {
    // The value doesn't change - nothing to do.
    if ( pure IconColor == value )
      return;

    // Remember the property's new value.
    pure IconColor = value;

    Image.Color=IconColor;
    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <850,10,1050,50>
  property color Color = #FFFFFFFF;

  $rect <850,50,1050,90>
  onset Color
  {
    // The value doesn't change - nothing to do.
    if ( pure Color == value )
      return;

    // Remember the property's new value.
    pure Color = value;

    FillPath1.ColorBL=value;
    FillPath1.ColorTR=value;
    FillPath1.ColorTL=value;
    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <850,-70,1050,-30>
  property color ShadowColor = #FFFFFFFF;

  $rect <850,-30,1050,10>
  onset ShadowColor
  {
    // The value doesn't change - nothing to do.
    if ( pure ShadowColor == value )
      return;

    // Remember the property's new value.
    pure ShadowColor = value;

    FillPath.Color=value;
    FillPath1.ColorBR=value;
    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <20,20,160,60>
  object Views::FillPath FillPath
  {
    preset Bounds = <0,0,100,100>;
    preset Color = #0F1E35FF;
    preset Offset = <50,50>;
    preset FillRule = Graphics::FillRule.EvenOdd;
    preset Path = ArcPath;
  }

  $rect <480,230,680,270>
  object Graphics::ArcPath ArcPath
  {
    preset EndAngle = 360;
    preset Radius = 50;
    preset Style = Graphics::ArcStyle.Pie;
  }

  $rect <480,270,680,310>
  object Graphics::ArcPath ArcPath1
  {
    preset EndAngle = 360;
    preset InnerRadius = 30;
    preset Radius = 49;
    preset Style = Graphics::ArcStyle.Pie;
  }

  $rect <20,20,160,60>
  object Views::FillPath FillPath1
  {
    preset Bounds = <0,0,100,100>;
    preset ColorBR = #0F1E35FF;
    preset Color = #FFFFFFFF;
    preset Offset = <50,50>;
    preset FillRule = Graphics::FillRule.EvenOdd;
    preset Path = ArcPath1;
  }

  $rect <20,20,160,60>
  object Views::Image Image
  {
    preset Bounds = <0,2,100,100>;
    preset Bitmap = Resources::DefaultBitmap;
  }

  $rect <20,20,160,60>
  object Views::FillPath FillPath2
  {
    preset Bounds = <0,0,100,100>;
    preset Color = #0000003A;
    preset Offset = <50,50>;
    preset FillRule = Graphics::FillRule.EvenOdd;
    preset Path = ArcPath;
    preset Visible = false;
  }

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler SimpleTouchHandler
  {
    preset Point4 = <11,11>;
    preset Point3 = <91,11>;
    preset Point2 = <91,91>;
    preset Point1 = <11,91>;
    preset OnRelease = onReleaseTouch;
    preset OnPress = onPressTouch;
  }
}

// This class implements a 'push button' widget. When the user presses the button, \
// a signal is sent to the slot method stored in its @OnActivate property.
$rect <90,710,290,750>
$output false
class DefaultButton : Templates::PushButton
{
  $rect <250,250,450,290>
  inherited property Bounds = <0,0,100,100>;

  $rect <860,190,1060,230>
  inherited method UpdateViewState()
  {
    super( aState );

    var bool isEnabled  = aState.contains( Core::ViewState[ Enabled  ]);

    switch(isEnabled)
    {
      case true:
      {
        CurrentColor=Color;
        SimpleTouchHandler.Enabled=true;
      }
      case false:
      {
        CurrentColor=#6F7586FF;
        SimpleTouchHandler.Enabled=false;
      }
      default:;
    }
  }

  // Touch screen events
  note group Note1
  {
    attr Bounds = <10,150,230,290>;
  }

  // This internal slot method is called when the user releases the touch screen \
  // after touching the button's area. This activates the button.
  $rect <20,230,220,270>
  slot onReleaseTouch
  {
    postsignal OnRelease;
    Rectangle2.Visible=false;
  }

  // This internal slot method is called when the user touches the button's area.
  $rect <20,190,220,230>
  slot onPressTouch
  {
    postsignal OnPress;
    Rectangle2.Visible=true;
  }

  // The property 'OnActivate' can refer to a slot method, which will receive a signal \
  // as soon as the user has activated the button. Thereupon the method's logic will \
  // be executed.
  $rect <450,190,650,230>
  property slot OnPress = null;

  $rect <450,10,650,50>
  property int32 FrameNumber = 0;

  $rect <450,50,650,90>
  onset FrameNumber
  {
    // The value doesn't change - nothing to do.
    if ( pure FrameNumber == value )
      return;

    // Remember the property's new value.
    pure FrameNumber = value;

    Image.FrameNumber=value;
    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <650,10,850,50>
  property Resources::Bitmap Bitmap = Resources::DefaultBitmap;

  $rect <650,50,850,90>
  onset Bitmap
  {
    // The value doesn't change - nothing to do.
    if ( pure Bitmap == value )
      return;

    // Remember the property's new value.
    pure Bitmap = value;

    Image.Bitmap=value;
    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  // The property 'OnActivate' can refer to a slot method, which will receive a signal \
  // as soon as the user has activated the button. Thereupon the method's logic will \
  // be executed.
  $rect <250,190,450,230>
  property slot OnRelease = null;

  $rect <250,10,450,50>
  property color IconColor = #FFFFFFFF;

  $rect <250,50,450,90>
  onset IconColor
  {
    // The value doesn't change - nothing to do.
    if ( pure IconColor == value )
      return;

    // Remember the property's new value.
    pure IconColor = value;

    Image.Color=IconColor;
    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <850,10,1050,50>
  property color Color;

  $rect <850,50,1050,90>
  onset Color
  {
    // The value doesn't change - nothing to do.
    if ( pure Color == value )
      return;

    // Remember the property's new value.
    pure Color = value;

    CurrentColor=Color;
    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <250,90,450,130>
  property color LabelColor = #FFFFFFFF;

  $rect <250,130,450,170>
  onset LabelColor
  {
    // The value doesn't change - nothing to do.
    if ( pure LabelColor == value )
      return;

    // Remember the property's new value.
    pure LabelColor = value;

    Text.Color=LabelColor;
    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <450,90,650,130>
  property string Label;

  $rect <450,130,650,170>
  onset Label
  {
    // The value doesn't change - nothing to do.
    if ( pure Label == value )
      return;

    // Remember the property's new value.
    pure Label = value;

    Text.String=Label;
    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <650,90,850,130>
  property Resources::Font Font;

  $rect <650,130,850,170>
  onset Font
  {
    // The value doesn't change - nothing to do.
    if ( pure Font == value )
      return;

    // Remember the property's new value.
    pure Font = value;

    Text.Font=Font;
    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,1,100,101>;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle1
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,1,100,101>;
    preset ColorBL = #FFFFFF86;
    preset ColorBR = #FFFFFF86;
    preset ColorTR = #FFFFFF00;
    preset ColorTL = #FFFFFF00;
    preset Color = #DCDCDCFF;
  }

  $rect <20,20,160,60>
  object Views::Image Image
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,2,100,100>;
    preset Alignment = Views::ImageAlignment[AlignHorzCenter, AlignVertCenter];
    preset Bitmap = null;
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,0,100,100>;
    preset Alignment = Views::TextAlignment[AlignHorzAuto, AlignHorzCenter, AlignVertCenter];
    preset String = "";
    preset Font = Resources::DefaultFont;
  }

  $rect <850,90,1050,130>
  property color CurrentColor;

  $rect <850,130,1050,170>
  onset CurrentColor
  {
    // The value doesn't change - nothing to do.
    if ( pure CurrentColor == value )
      return;

    // Remember the property's new value.
    pure CurrentColor = value;

    Rectangle.Color=value;
    Rectangle1.Color=value-#23232300;
    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle2
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,2,100,102>;
    preset Color = #0000003A;
    preset Visible = false;
  }

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler SimpleTouchHandler
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Point4 = <0,2>;
    preset Point3 = <100,2>;
    preset Point2 = <100,100>;
    preset Point1 = <0,100>;
    preset OnRelease = onReleaseTouch;
    preset OnPress = onPressTouch;
  }
}

$rect <90,759,280,799>
$output false
class SlideTouchHandler : Core::SlideTouchHandler
{
  $rect <10,10,160,50>
  inherited slot timerSlot
  {
    // Receiving a pending signal after the animation was stopped. Ignore it
    if ( timer == null )
      return;

    var float timeX       = float( timer.Time - startTimeX ) * 0.001;
    var float timeY       = float( timer.Time - startTimeY ) * 0.001;
    var float timeX2      = timeX * timeX;
    var float timeY2      = timeY * timeY;
    var float newSpeedX   = accelerationX * timeX + speedX;
    var float newSpeedY   = accelerationY * timeY + speedY;
    var point newOffset   = point( int32( accelerationX * 0.5 * timeX2 + speedX * timeX + startX ),
                                   int32( accelerationY * 0.5 * timeY2 + speedY * timeY + startY ));
    var float parkingTime = float( RubberBandEffectDuration ) * 0.001;

    // 'Rubber band' effect for the horizontal movement. Stop it as soon as the end position has
    // been reached
    if ( parkingX && ( timeX >= parkingTime ))
    {
      newOffset.x   = endX;
      speedX        = 0.0;
      accelerationX = 0.0;
      startX        = float( newOffset.x );
      parkingX      = false;
    }

    // 'Rubber band' effect in horizontal direction? Calculate the next position by using a
    // fast-in - ease-out timing
    else if ( parkingX )
    {
      var float f = 1.0 - math_pow( 1.0 - ( timeX / parkingTime ), RubberBandEffectElasticity ) ;
      newOffset.x = int32( startX + ( float( endX ) - startX ) * f );
    }


    // 'Rubber band' effect for the vertical movement. Stop it as soon as the end position has
    // been reached
    if ( parkingY && ( timeY >= parkingTime ))
    {
      newOffset.y   = endY;
      speedY        = 0.0;
      accelerationY = 0.0;
      startY        = float( newOffset.y );
      parkingY      = false;
    }

    // 'Rubber band' effect in horizontal direction? Calculate the next position by using a
    // fast-in - ease-out timing
    else if ( parkingY )
    {
      var float f = 1.0 - math_pow( 1.0 - ( timeY / parkingTime ), RubberBandEffectElasticity ) ;
      newOffset.y = int32( startY + ( float( endY ) - startY ) * f );
    }

    // Inverting the animation direction? This will stop the animation
    if ((( speedX > 0.0 ) && ( newSpeedX < 0.0 )) || ( speedX < 0.0 ) && ( newSpeedX > 0.0 ))
    {
      newSpeedX   = 0.0;
      newOffset.x = Offset.x;
    }

    // Inverting the animation direction? This will stop the animation
    if ((( speedY > 0.0 ) && ( newSpeedY < 0.0 )) || ( speedY < 0.0 ) && ( newSpeedY > 0.0 ))
    {
      newSpeedY   = 0.0;
      newOffset.y = Offset.y;
    }

    // Content outside the boundary area -> activate the 'rubber band' effect.
    if ( !parkingX && ( newOffset.x < MinOffset.x ))
    {
      startX        = newOffset.x;
      endX          = MinOffset.x;
      startTimeX    = timer.Time;
      parkingX      = true;
    }

    // Content outside the boundary area -> activate the 'rubber band' effect.
    else if ( !parkingX && ( newOffset.x > Bounds.w/2 ) && ( newOffset.x < Bounds.w ))
    {
      startX        = newOffset.x;
      endX          = Bounds.w;
      startTimeX    = timer.Time;
      parkingX      = true;
    }
    else if ( !parkingX && ( newOffset.x > MaxOffset.x ))
    {
      startX        = newOffset.x;
      endX          = MaxOffset.x;
      startTimeX    = timer.Time;
      parkingX      = true;
    }

    // Content outside the boundary area -> activate the 'rubber band' effect.
    if ( !parkingY && ( newOffset.y < MinOffset.y ))
    {
      startY        = newOffset.y;
      endY          = MinOffset.y;
      startTimeY    = timer.Time;
      parkingY      = true;
    }

    // Content outside the boundary area -> activate the 'rubber band' effect.
    else if ( !parkingY && ( newOffset.y > MaxOffset.y ))
    {
      startY        = newOffset.y;
      endY          = MaxOffset.y;
      startTimeY    = timer.Time;
      parkingY      = true;
    }

    // If the animation speed fall below 20 px/sec stop the animation in 
    // this direction. 
    if ( !parkingX && ( speedX != 0.0 ) && ( newSpeedX > -20.0 ) && ( newSpeedX < 20.0 ))
    {
      // Reach the predetermined final position
      newOffset.x   = endX;
      speedX        = 0.0;
      accelerationX = 0.0;
      startX        = float( newOffset.x );
    }

    // If the animation speed fall below 20 px/sec stop the animation in 
    // this direction. 
    if ( !parkingY && ( speedY != 0.0 ) && ( newSpeedY > -20.0 ) && ( newSpeedY < 20.0 ))
    {
      // Reach the predetermined final position
      newOffset.y   = endY;
      speedY        = 0.0;
      accelerationY = 0.0;
      startY        = float( newOffset.y );
    }

    if(newOffset.x>=Bounds.w)
    {
      stopAnimation();
      Sliding = false;
      signal privateOnEnd;
      signal OnEnd;
    }

    // At fin drive the owner to adapt the scroll position
    if ( newOffset != Offset )
    {
      Delta  = newOffset - Offset;
      Offset = newOffset;

      signal privateOnSlide;
      signal OnSlide;
    }

    // The animation is done
    if (( speedX == 0.0 ) && ( speedY == 0.0 ) && !parkingX && !parkingY )
    {
      stopAnimation();
      Sliding = false;
      signal privateOnEnd;
      signal OnEnd;
    }
  }
}

$rect <480,70,680,110>
$output false
resource Resources::Bitmap BackgroundImg
{
  attr bitmapfile FileName = .\Resources\BackgroundImg.jpg;
  attr bitmapdithering Dithering = Auto;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapformat Format = Native;
  attr bitmapmode Mode = Default;
}

$rect <56,858,246,898>
$output false
class VerticalList1 : Core::VerticalList
{
  $rect <540,50,730,90>
  object Core::VerticalList VerticalList;
}
